{"ast":null,"code":"// Generated by CoffeeScript 2.4.1\n(function () {\n  var DocumentPosition,\n    NodeType,\n    XMLCData,\n    XMLComment,\n    XMLDeclaration,\n    XMLDocType,\n    XMLDummy,\n    XMLElement,\n    XMLNamedNodeMap,\n    XMLNode,\n    XMLNodeList,\n    XMLProcessingInstruction,\n    XMLRaw,\n    XMLText,\n    getValue,\n    isEmpty,\n    isFunction,\n    isObject,\n    hasProp = {}.hasOwnProperty,\n    splice = [].splice;\n  ({\n    isObject,\n    isFunction,\n    isEmpty,\n    getValue\n  } = require('./Utility'));\n  XMLElement = null;\n  XMLCData = null;\n  XMLComment = null;\n  XMLDeclaration = null;\n  XMLDocType = null;\n  XMLRaw = null;\n  XMLText = null;\n  XMLProcessingInstruction = null;\n  XMLDummy = null;\n  NodeType = null;\n  XMLNodeList = null;\n  XMLNamedNodeMap = null;\n  DocumentPosition = null;\n\n  // Represents a generic XMl element\n  module.exports = XMLNode = function () {\n    class XMLNode {\n      // Initializes a new instance of `XMLNode`\n\n      // `parent` the parent node\n      constructor(parent1) {\n        this.parent = parent1;\n        if (this.parent) {\n          this.options = this.parent.options;\n          this.stringify = this.parent.stringify;\n        }\n        this.value = null;\n        this.children = [];\n        this.baseURI = null;\n        // first execution, load dependencies that are otherwise\n        // circular (so we can't load them at the top)\n        if (!XMLElement) {\n          XMLElement = require('./XMLElement');\n          XMLCData = require('./XMLCData');\n          XMLComment = require('./XMLComment');\n          XMLDeclaration = require('./XMLDeclaration');\n          XMLDocType = require('./XMLDocType');\n          XMLRaw = require('./XMLRaw');\n          XMLText = require('./XMLText');\n          XMLProcessingInstruction = require('./XMLProcessingInstruction');\n          XMLDummy = require('./XMLDummy');\n          NodeType = require('./NodeType');\n          XMLNodeList = require('./XMLNodeList');\n          XMLNamedNodeMap = require('./XMLNamedNodeMap');\n          DocumentPosition = require('./DocumentPosition');\n        }\n      }\n\n      // Sets the parent node of this node and its children recursively\n\n      // `parent` the parent node\n      setParent(parent) {\n        var child, j, len, ref1, results;\n        this.parent = parent;\n        if (parent) {\n          this.options = parent.options;\n          this.stringify = parent.stringify;\n        }\n        ref1 = this.children;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          results.push(child.setParent(this));\n        }\n        return results;\n      }\n\n      // Creates a child element node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      element(name, attributes, text) {\n        var childNode, item, j, k, key, lastChild, len, len1, val;\n        lastChild = null;\n        if (attributes === null && text == null) {\n          [attributes, text] = [{}, null];\n        }\n        if (attributes == null) {\n          attributes = {};\n        }\n        attributes = getValue(attributes);\n        // swap argument order: text <-> attributes\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n        if (name != null) {\n          name = getValue(name);\n        }\n        // expand if array\n        if (Array.isArray(name)) {\n          for (j = 0, len = name.length; j < len; j++) {\n            item = name[j];\n            lastChild = this.element(item);\n          }\n          // evaluate if function\n        } else if (isFunction(name)) {\n          lastChild = this.element(name.apply());\n          // expand if object\n        } else if (isObject(name)) {\n          for (key in name) {\n            if (!hasProp.call(name, key)) continue;\n            val = name[key];\n            if (isFunction(val)) {\n              // evaluate if function\n              val = val.apply();\n            }\n            // assign attributes\n            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n              // skip empty arrays\n            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n              lastChild = this.dummy();\n              // empty objects produce one node\n            } else if (isObject(val) && isEmpty(val)) {\n              lastChild = this.element(key);\n              // skip null and undefined nodes\n            } else if (!this.options.keepNullNodes && val == null) {\n              lastChild = this.dummy();\n\n              // expand list by creating child nodes\n            } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n              for (k = 0, len1 = val.length; k < len1; k++) {\n                item = val[k];\n                childNode = {};\n                childNode[key] = item;\n                lastChild = this.element(childNode);\n              }\n\n              // expand child nodes under parent\n            } else if (isObject(val)) {\n              // if the key is #text expand child nodes under this node to support mixed content\n              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n                lastChild = this.element(val);\n              } else {\n                lastChild = this.element(key);\n                lastChild.element(val);\n              }\n            } else {\n              // text node\n              lastChild = this.element(key, val);\n            }\n          }\n          // skip null nodes\n        } else if (!this.options.keepNullNodes && text === null) {\n          lastChild = this.dummy();\n        } else {\n          // text node\n          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n            lastChild = this.text(text);\n            // cdata node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n            lastChild = this.cdata(text);\n            // comment node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n            lastChild = this.comment(text);\n            // raw text node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n            lastChild = this.raw(text);\n            // processing instruction\n          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n          } else {\n            // element node\n            lastChild = this.node(name, attributes, text);\n          }\n        }\n        if (lastChild == null) {\n          throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n        }\n        return lastChild;\n      }\n\n      // Creates a child element node before the current node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      insertBefore(name, attributes, text) {\n        var child, i, newChild, refChild, removed;\n        // DOM level 1\n        // insertBefore(newChild, refChild) inserts the child node newChild before refChild\n        if (name != null ? name.type : void 0) {\n          newChild = name;\n          refChild = attributes;\n          newChild.setParent(this);\n          if (refChild) {\n            // temporarily remove children starting *with* refChild\n            i = children.indexOf(refChild);\n            removed = children.splice(i);\n\n            // add the new child\n            children.push(newChild);\n\n            // add back removed children after new child\n            Array.prototype.push.apply(children, removed);\n          } else {\n            children.push(newChild);\n          }\n          return newChild;\n        } else {\n          if (this.isRoot) {\n            throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n          }\n\n          // temporarily remove children starting *with* this\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i);\n\n          // add the new child\n          child = this.parent.element(name, attributes, text);\n\n          // add back removed children after new child\n          Array.prototype.push.apply(this.parent.children, removed);\n          return child;\n        }\n      }\n\n      // Creates a child element node after the current node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      insertAfter(name, attributes, text) {\n        var child, i, removed;\n        if (this.isRoot) {\n          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n        }\n\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n\n        // add the new child\n        child = this.parent.element(name, attributes, text);\n\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return child;\n      }\n\n      // Deletes a child element node\n\n      remove() {\n        var i, ref1;\n        if (this.isRoot) {\n          throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n        }\n        i = this.parent.children.indexOf(this);\n        splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n        return this.parent;\n      }\n\n      // Creates a node\n\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      node(name, attributes, text) {\n        var child;\n        if (name != null) {\n          name = getValue(name);\n        }\n        attributes || (attributes = {});\n        attributes = getValue(attributes);\n        // swap argument order: text <-> attributes\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n        child = new XMLElement(this, name, attributes);\n        if (text != null) {\n          child.text(text);\n        }\n        this.children.push(child);\n        return child;\n      }\n\n      // Creates a text node\n\n      // `value` element text\n      text(value) {\n        var child;\n        if (isObject(value)) {\n          this.element(value);\n        }\n        child = new XMLText(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a CDATA node\n\n      // `value` element text without CDATA delimiters\n      cdata(value) {\n        var child;\n        child = new XMLCData(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a comment node\n\n      // `value` comment text\n      comment(value) {\n        var child;\n        child = new XMLComment(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a comment node before the current node\n\n      // `value` comment text\n      commentBefore(value) {\n        var child, i, removed;\n        // temporarily remove children starting *with* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        // add the new child\n        child = this.parent.comment(value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates a comment node after the current node\n\n      // `value` comment text\n      commentAfter(value) {\n        var child, i, removed;\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        // add the new child\n        child = this.parent.comment(value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Adds unescaped raw text\n\n      // `value` text\n      raw(value) {\n        var child;\n        child = new XMLRaw(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Adds a dummy node\n      dummy() {\n        var child;\n        child = new XMLDummy(this);\n        // Normally when a new node is created it is added to the child node collection.\n        // However, dummy nodes are never added to the XML tree. They are created while\n        // converting JS objects to XML nodes in order not to break the recursive function\n        // chain. They can be thought of as invisible nodes. They can be traversed through\n        // by using prev(), next(), up(), etc. functions but they do not exists in the tree.\n\n        // @children.push child\n        return child;\n      }\n\n      // Adds a processing instruction\n\n      // `target` instruction target\n      // `value` instruction value\n      instruction(target, value) {\n        var insTarget, insValue, instruction, j, len;\n        if (target != null) {\n          target = getValue(target);\n        }\n        if (value != null) {\n          value = getValue(value);\n        }\n        if (Array.isArray(target)) {\n          // expand if array\n          for (j = 0, len = target.length; j < len; j++) {\n            insTarget = target[j];\n            this.instruction(insTarget);\n          }\n        } else if (isObject(target)) {\n          // expand if object\n          for (insTarget in target) {\n            if (!hasProp.call(target, insTarget)) continue;\n            insValue = target[insTarget];\n            this.instruction(insTarget, insValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n          instruction = new XMLProcessingInstruction(this, target, value);\n          this.children.push(instruction);\n        }\n        return this;\n      }\n\n      // Creates a processing instruction node before the current node\n\n      // `target` instruction target\n      // `value` instruction value\n      instructionBefore(target, value) {\n        var child, i, removed;\n        // temporarily remove children starting *with* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        // add the new child\n        child = this.parent.instruction(target, value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates a processing instruction node after the current node\n\n      // `target` instruction target\n      // `value` instruction value\n      instructionAfter(target, value) {\n        var child, i, removed;\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        // add the new child\n        child = this.parent.instruction(target, value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates the xml declaration\n\n      // `version` A version number string, e.g. 1.0\n      // `encoding` Encoding declaration, e.g. UTF-8\n      // `standalone` standalone document declaration: true or false\n      declaration(version, encoding, standalone) {\n        var doc, xmldec;\n        doc = this.document();\n        xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n        // Replace XML declaration if exists, otherwise insert at top\n        if (doc.children.length === 0) {\n          doc.children.unshift(xmldec);\n        } else if (doc.children[0].type === NodeType.Declaration) {\n          doc.children[0] = xmldec;\n        } else {\n          doc.children.unshift(xmldec);\n        }\n        return doc.root() || doc;\n      }\n\n      // Creates the document type declaration\n\n      // `pubID` the public identifier of the external subset\n      // `sysID` the system identifier of the external subset\n      dtd(pubID, sysID) {\n        var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n        doc = this.document();\n        doctype = new XMLDocType(doc, pubID, sysID);\n        ref1 = doc.children;\n        // Replace DTD if exists\n        for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n          child = ref1[i];\n          if (child.type === NodeType.DocType) {\n            doc.children[i] = doctype;\n            return doctype;\n          }\n        }\n        ref2 = doc.children;\n        // insert before root node if the root node exists\n        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n          child = ref2[i];\n          if (child.isRoot) {\n            doc.children.splice(i, 0, doctype);\n            return doctype;\n          }\n        }\n        // otherwise append to end\n        doc.children.push(doctype);\n        return doctype;\n      }\n\n      // Gets the parent node\n      up() {\n        if (this.isRoot) {\n          throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n        }\n        return this.parent;\n      }\n\n      // Gets the root node\n      root() {\n        var node;\n        node = this;\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node.rootObject;\n          } else if (node.isRoot) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      }\n\n      // Gets the node representing the XML document\n      document() {\n        var node;\n        node = this;\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      }\n\n      // Ends the document and converts string\n      end(options) {\n        return this.document().end(options);\n      }\n\n      // Gets the previous node\n      prev() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        if (i < 1) {\n          throw new Error(\"Already at the first node. \" + this.debugInfo());\n        }\n        return this.parent.children[i - 1];\n      }\n\n      // Gets the next node\n      next() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        if (i === -1 || i === this.parent.children.length - 1) {\n          throw new Error(\"Already at the last node. \" + this.debugInfo());\n        }\n        return this.parent.children[i + 1];\n      }\n\n      // Imports cloned root from another XML document\n\n      // `doc` the XML document to insert nodes from\n      importDocument(doc) {\n        var child, clonedRoot, j, len, ref1;\n        clonedRoot = doc.root().clone();\n        clonedRoot.parent = this;\n        clonedRoot.isRoot = false;\n        this.children.push(clonedRoot);\n        // set properties if imported element becomes the root node\n        if (this.type === NodeType.Document) {\n          clonedRoot.isRoot = true;\n          clonedRoot.documentObject = this;\n          this.rootObject = clonedRoot;\n          // set dtd name\n          if (this.children) {\n            ref1 = this.children;\n            for (j = 0, len = ref1.length; j < len; j++) {\n              child = ref1[j];\n              if (child.type === NodeType.DocType) {\n                child.name = clonedRoot.name;\n                break;\n              }\n            }\n          }\n        }\n        return this;\n      }\n\n      // Returns debug string for this node\n      debugInfo(name) {\n        var ref1, ref2;\n        name = name || this.name;\n        if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {\n          return \"\";\n        } else if (name == null) {\n          return \"parent: <\" + this.parent.name + \">\";\n        } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {\n          return \"node: <\" + name + \">\";\n        } else {\n          return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n        }\n      }\n\n      // Aliases\n      ele(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n      nod(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n      txt(value) {\n        return this.text(value);\n      }\n      dat(value) {\n        return this.cdata(value);\n      }\n      com(value) {\n        return this.comment(value);\n      }\n      ins(target, value) {\n        return this.instruction(target, value);\n      }\n      doc() {\n        return this.document();\n      }\n      dec(version, encoding, standalone) {\n        return this.declaration(version, encoding, standalone);\n      }\n      e(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n      n(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n      t(value) {\n        return this.text(value);\n      }\n      d(value) {\n        return this.cdata(value);\n      }\n      c(value) {\n        return this.comment(value);\n      }\n      r(value) {\n        return this.raw(value);\n      }\n      i(target, value) {\n        return this.instruction(target, value);\n      }\n      u() {\n        return this.up();\n      }\n\n      // can be deprecated in a future release\n      importXMLBuilder(doc) {\n        return this.importDocument(doc);\n      }\n\n      // Adds or modifies an attribute.\n\n      // `name` attribute name\n      // `value` attribute value\n      attribute(name, value) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n      att(name, value) {\n        return this.attribute(name, value);\n      }\n      a(name, value) {\n        return this.attribute(name, value);\n      }\n\n      // Removes an attribute\n\n      // `name` attribute name\n      removeAttribute(name) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      // DOM level 1 functions to be implemented later\n      replaceChild(newChild, oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n      removeChild(oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n      appendChild(newChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n      hasChildNodes() {\n        return this.children.length !== 0;\n      }\n      cloneNode(deep) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n      normalize() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      // DOM level 2\n      isSupported(feature, version) {\n        return true;\n      }\n      hasAttributes() {\n        return this.attribs.length !== 0;\n      }\n\n      // DOM level 3 functions to be implemented later\n      compareDocumentPosition(other) {\n        var ref, res;\n        ref = this;\n        if (ref === other) {\n          return 0;\n        } else if (this.document() !== other.document()) {\n          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n          if (Math.random() < 0.5) {\n            res |= DocumentPosition.Preceding;\n          } else {\n            res |= DocumentPosition.Following;\n          }\n          return res;\n        } else if (ref.isAncestor(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Preceding;\n        } else if (ref.isDescendant(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Following;\n        } else if (ref.isPreceding(other)) {\n          return DocumentPosition.Preceding;\n        } else {\n          return DocumentPosition.Following;\n        }\n      }\n      isSameNode(other) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n      lookupPrefix(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n      isDefaultNamespace(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n      lookupNamespaceURI(prefix) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n      isEqualNode(node) {\n        var i, j, ref1;\n        if (node.nodeType !== this.nodeType) {\n          return false;\n        }\n        if (node.children.length !== this.children.length) {\n          return false;\n        }\n        for (i = j = 0, ref1 = this.children.length - 1; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {\n          if (!this.children[i].isEqualNode(node.children[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n      getFeature(feature, version) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n      setUserData(key, data, handler) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n      getUserData(key) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      // Returns true if other is an inclusive descendant of node,\n      // and false otherwise.\n      contains(other) {\n        if (!other) {\n          return false;\n        }\n        return other === this || this.isDescendant(other);\n      }\n\n      // An object A is called a descendant of an object B, if either A is \n      // a child of B or A is a child of an object C that is a descendant of B.\n      isDescendant(node) {\n        var child, isDescendantChild, j, len, ref1;\n        ref1 = this.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (node === child) {\n            return true;\n          }\n          isDescendantChild = child.isDescendant(node);\n          if (isDescendantChild) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      // An object A is called an ancestor of an object B if and only if\n      // B is a descendant of A.\n      isAncestor(node) {\n        return node.isDescendant(this);\n      }\n\n      // An object A is preceding an object B if A and B are in the \n      // same tree and A comes before B in tree order.\n      isPreceding(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos < thisPos;\n        }\n      }\n\n      // An object A is folllowing an object B if A and B are in the \n      // same tree and A comes after B in tree order.\n      isFollowing(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos > thisPos;\n        }\n      }\n\n      // Returns the preorder position of the given node in the tree, or -1\n      // if the node is not in the tree.\n      treePosition(node) {\n        var found, pos;\n        pos = 0;\n        found = false;\n        this.foreachTreeNode(this.document(), function (childNode) {\n          pos++;\n          if (!found && childNode === node) {\n            return found = true;\n          }\n        });\n        if (found) {\n          return pos;\n        } else {\n          return -1;\n        }\n      }\n\n      // Depth-first preorder traversal through the XML tree\n      foreachTreeNode(node, func) {\n        var child, j, len, ref1, res;\n        node || (node = this.document());\n        ref1 = node.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (res = func(child)) {\n            return res;\n          } else {\n            res = this.foreachTreeNode(child, func);\n            if (res) {\n              return res;\n            }\n          }\n        }\n      }\n    }\n    ;\n\n    // DOM level 1\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function () {\n        return this.name;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function () {\n        return this.type;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function () {\n        return this.value;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function () {\n        return this.parent;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function () {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n        return this.childNodeList;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function () {\n        return this.children[0] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function () {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function () {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function () {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function () {\n        return this.document() || null;\n      }\n    });\n\n    // DOM level 3\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function () {\n        var child, j, len, ref1, str;\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref1 = this.children;\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function (value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n    return XMLNode;\n  }.call(this);\n}).call(this);","map":{"version":3,"names":["DocumentPosition","NodeType","XMLCData","XMLComment","XMLDeclaration","XMLDocType","XMLDummy","XMLElement","XMLNamedNodeMap","XMLNode","XMLNodeList","XMLProcessingInstruction","XMLRaw","XMLText","getValue","isEmpty","isFunction","isObject","hasProp","hasOwnProperty","splice","require","module","exports","constructor","parent1","parent","options","stringify","value","children","baseURI","setParent","child","j","len","ref1","results","length","push","element","name","attributes","text","childNode","item","k","key","lastChild","len1","val","Array","isArray","apply","call","ignoreDecorators","convertAttKey","indexOf","attribute","substr","separateArrayItems","dummy","keepNullNodes","convertTextKey","convertCDataKey","cdata","convertCommentKey","comment","convertRawKey","raw","convertPIKey","instruction","node","Error","debugInfo","insertBefore","i","newChild","refChild","removed","type","prototype","isRoot","insertAfter","remove","concat","commentBefore","commentAfter","target","insTarget","insValue","instructionBefore","instructionAfter","declaration","version","encoding","standalone","doc","xmldec","document","unshift","Declaration","root","dtd","pubID","sysID","doctype","ref2","DocType","up","Document","rootObject","end","prev","next","importDocument","clonedRoot","clone","documentObject","ele","nod","txt","dat","com","ins","dec","e","n","t","d","c","r","u","importXMLBuilder","att","a","removeAttribute","replaceChild","oldChild","removeChild","appendChild","hasChildNodes","cloneNode","deep","normalize","isSupported","feature","hasAttributes","attribs","compareDocumentPosition","other","ref","res","Disconnected","ImplementationSpecific","Math","random","Preceding","Following","isAncestor","Contains","isDescendant","isPreceding","isSameNode","lookupPrefix","namespaceURI","isDefaultNamespace","lookupNamespaceURI","prefix","isEqualNode","nodeType","getFeature","setUserData","data","handler","getUserData","contains","isDescendantChild","nodePos","thisPos","treePosition","isFollowing","found","pos","foreachTreeNode","func","Object","defineProperty","get","childNodeList","nodes","str","Element","DocumentFragment","textContent","set"],"sources":["C:/Users/SashinTulsiram/Documents/Software/react-frontend-bulma/react-app/node_modules/xmlbuilder/lib/XMLNode.js"],"sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var DocumentPosition, NodeType, XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNamedNodeMap, XMLNode, XMLNodeList, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty, isFunction, isObject,\n    hasProp = {}.hasOwnProperty,\n    splice = [].splice;\n\n  ({isObject, isFunction, isEmpty, getValue} = require('./Utility'));\n\n  XMLElement = null;\n\n  XMLCData = null;\n\n  XMLComment = null;\n\n  XMLDeclaration = null;\n\n  XMLDocType = null;\n\n  XMLRaw = null;\n\n  XMLText = null;\n\n  XMLProcessingInstruction = null;\n\n  XMLDummy = null;\n\n  NodeType = null;\n\n  XMLNodeList = null;\n\n  XMLNamedNodeMap = null;\n\n  DocumentPosition = null;\n\n  // Represents a generic XMl element\n  module.exports = XMLNode = (function() {\n    class XMLNode {\n      // Initializes a new instance of `XMLNode`\n\n      // `parent` the parent node\n      constructor(parent1) {\n        this.parent = parent1;\n        if (this.parent) {\n          this.options = this.parent.options;\n          this.stringify = this.parent.stringify;\n        }\n        this.value = null;\n        this.children = [];\n        this.baseURI = null;\n        // first execution, load dependencies that are otherwise\n        // circular (so we can't load them at the top)\n        if (!XMLElement) {\n          XMLElement = require('./XMLElement');\n          XMLCData = require('./XMLCData');\n          XMLComment = require('./XMLComment');\n          XMLDeclaration = require('./XMLDeclaration');\n          XMLDocType = require('./XMLDocType');\n          XMLRaw = require('./XMLRaw');\n          XMLText = require('./XMLText');\n          XMLProcessingInstruction = require('./XMLProcessingInstruction');\n          XMLDummy = require('./XMLDummy');\n          NodeType = require('./NodeType');\n          XMLNodeList = require('./XMLNodeList');\n          XMLNamedNodeMap = require('./XMLNamedNodeMap');\n          DocumentPosition = require('./DocumentPosition');\n        }\n      }\n\n      \n      // Sets the parent node of this node and its children recursively\n\n      // `parent` the parent node\n      setParent(parent) {\n        var child, j, len, ref1, results;\n        this.parent = parent;\n        if (parent) {\n          this.options = parent.options;\n          this.stringify = parent.stringify;\n        }\n        ref1 = this.children;\n        results = [];\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          results.push(child.setParent(this));\n        }\n        return results;\n      }\n\n      // Creates a child element node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      element(name, attributes, text) {\n        var childNode, item, j, k, key, lastChild, len, len1, val;\n        lastChild = null;\n        if (attributes === null && (text == null)) {\n          [attributes, text] = [{}, null];\n        }\n        if (attributes == null) {\n          attributes = {};\n        }\n        attributes = getValue(attributes);\n        // swap argument order: text <-> attributes\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n        if (name != null) {\n          name = getValue(name);\n        }\n        // expand if array\n        if (Array.isArray(name)) {\n          for (j = 0, len = name.length; j < len; j++) {\n            item = name[j];\n            lastChild = this.element(item);\n          }\n        // evaluate if function\n        } else if (isFunction(name)) {\n          lastChild = this.element(name.apply());\n        // expand if object\n        } else if (isObject(name)) {\n          for (key in name) {\n            if (!hasProp.call(name, key)) continue;\n            val = name[key];\n            if (isFunction(val)) {\n              // evaluate if function\n              val = val.apply();\n            }\n            // assign attributes\n            if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {\n              lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);\n            // skip empty arrays\n            } else if (!this.options.separateArrayItems && Array.isArray(val) && isEmpty(val)) {\n              lastChild = this.dummy();\n            // empty objects produce one node\n            } else if (isObject(val) && isEmpty(val)) {\n              lastChild = this.element(key);\n            // skip null and undefined nodes\n            } else if (!this.options.keepNullNodes && (val == null)) {\n              lastChild = this.dummy();\n            \n            // expand list by creating child nodes\n            } else if (!this.options.separateArrayItems && Array.isArray(val)) {\n              for (k = 0, len1 = val.length; k < len1; k++) {\n                item = val[k];\n                childNode = {};\n                childNode[key] = item;\n                lastChild = this.element(childNode);\n              }\n            \n            // expand child nodes under parent\n            } else if (isObject(val)) {\n              // if the key is #text expand child nodes under this node to support mixed content\n              if (!this.options.ignoreDecorators && this.stringify.convertTextKey && key.indexOf(this.stringify.convertTextKey) === 0) {\n                lastChild = this.element(val);\n              } else {\n                lastChild = this.element(key);\n                lastChild.element(val);\n              }\n            } else {\n              \n              // text node\n              lastChild = this.element(key, val);\n            }\n          }\n        // skip null nodes\n        } else if (!this.options.keepNullNodes && text === null) {\n          lastChild = this.dummy();\n        } else {\n          // text node\n          if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {\n            lastChild = this.text(text);\n          // cdata node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {\n            lastChild = this.cdata(text);\n          // comment node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {\n            lastChild = this.comment(text);\n          // raw text node\n          } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {\n            lastChild = this.raw(text);\n          // processing instruction\n          } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {\n            lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);\n          } else {\n            // element node\n            lastChild = this.node(name, attributes, text);\n          }\n        }\n        if (lastChild == null) {\n          throw new Error(\"Could not create any elements with: \" + name + \". \" + this.debugInfo());\n        }\n        return lastChild;\n      }\n\n      // Creates a child element node before the current node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      insertBefore(name, attributes, text) {\n        var child, i, newChild, refChild, removed;\n        // DOM level 1\n        // insertBefore(newChild, refChild) inserts the child node newChild before refChild\n        if (name != null ? name.type : void 0) {\n          newChild = name;\n          refChild = attributes;\n          newChild.setParent(this);\n          if (refChild) {\n            // temporarily remove children starting *with* refChild\n            i = children.indexOf(refChild);\n            removed = children.splice(i);\n            \n            // add the new child\n            children.push(newChild);\n            \n            // add back removed children after new child\n            Array.prototype.push.apply(children, removed);\n          } else {\n            children.push(newChild);\n          }\n          return newChild;\n        } else {\n          if (this.isRoot) {\n            throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n          }\n          \n          // temporarily remove children starting *with* this\n          i = this.parent.children.indexOf(this);\n          removed = this.parent.children.splice(i);\n          \n          // add the new child\n          child = this.parent.element(name, attributes, text);\n          \n          // add back removed children after new child\n          Array.prototype.push.apply(this.parent.children, removed);\n          return child;\n        }\n      }\n\n      // Creates a child element node after the current node\n\n      // `name` node name or an object describing the XML tree\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      insertAfter(name, attributes, text) {\n        var child, i, removed;\n        if (this.isRoot) {\n          throw new Error(\"Cannot insert elements at root level. \" + this.debugInfo(name));\n        }\n        \n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        \n        // add the new child\n        child = this.parent.element(name, attributes, text);\n        \n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return child;\n      }\n\n      // Deletes a child element node\n\n      remove() {\n        var i, ref1;\n        if (this.isRoot) {\n          throw new Error(\"Cannot remove the root element. \" + this.debugInfo());\n        }\n        i = this.parent.children.indexOf(this);\n        splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;\n        return this.parent;\n      }\n\n      // Creates a node\n\n      // `name` name of the node\n      // `attributes` an object containing name/value pairs of attributes\n      // `text` element text\n      node(name, attributes, text) {\n        var child;\n        if (name != null) {\n          name = getValue(name);\n        }\n        attributes || (attributes = {});\n        attributes = getValue(attributes);\n        // swap argument order: text <-> attributes\n        if (!isObject(attributes)) {\n          [text, attributes] = [attributes, text];\n        }\n        child = new XMLElement(this, name, attributes);\n        if (text != null) {\n          child.text(text);\n        }\n        this.children.push(child);\n        return child;\n      }\n\n      // Creates a text node\n\n      // `value` element text\n      text(value) {\n        var child;\n        if (isObject(value)) {\n          this.element(value);\n        }\n        child = new XMLText(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a CDATA node\n\n      // `value` element text without CDATA delimiters\n      cdata(value) {\n        var child;\n        child = new XMLCData(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a comment node\n\n      // `value` comment text\n      comment(value) {\n        var child;\n        child = new XMLComment(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Creates a comment node before the current node\n\n      // `value` comment text\n      commentBefore(value) {\n        var child, i, removed;\n        // temporarily remove children starting *with* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        // add the new child\n        child = this.parent.comment(value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates a comment node after the current node\n\n      // `value` comment text\n      commentAfter(value) {\n        var child, i, removed;\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        // add the new child\n        child = this.parent.comment(value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Adds unescaped raw text\n\n      // `value` text\n      raw(value) {\n        var child;\n        child = new XMLRaw(this, value);\n        this.children.push(child);\n        return this;\n      }\n\n      // Adds a dummy node\n      dummy() {\n        var child;\n        child = new XMLDummy(this);\n        // Normally when a new node is created it is added to the child node collection.\n        // However, dummy nodes are never added to the XML tree. They are created while\n        // converting JS objects to XML nodes in order not to break the recursive function\n        // chain. They can be thought of as invisible nodes. They can be traversed through\n        // by using prev(), next(), up(), etc. functions but they do not exists in the tree.\n\n        // @children.push child\n        return child;\n      }\n\n      // Adds a processing instruction\n\n      // `target` instruction target\n      // `value` instruction value\n      instruction(target, value) {\n        var insTarget, insValue, instruction, j, len;\n        if (target != null) {\n          target = getValue(target);\n        }\n        if (value != null) {\n          value = getValue(value);\n        }\n        if (Array.isArray(target)) { // expand if array\n          for (j = 0, len = target.length; j < len; j++) {\n            insTarget = target[j];\n            this.instruction(insTarget);\n          }\n        } else if (isObject(target)) { // expand if object\n          for (insTarget in target) {\n            if (!hasProp.call(target, insTarget)) continue;\n            insValue = target[insTarget];\n            this.instruction(insTarget, insValue);\n          }\n        } else {\n          if (isFunction(value)) {\n            value = value.apply();\n          }\n          instruction = new XMLProcessingInstruction(this, target, value);\n          this.children.push(instruction);\n        }\n        return this;\n      }\n\n      // Creates a processing instruction node before the current node\n\n      // `target` instruction target\n      // `value` instruction value\n      instructionBefore(target, value) {\n        var child, i, removed;\n        // temporarily remove children starting *with* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i);\n        // add the new child\n        child = this.parent.instruction(target, value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates a processing instruction node after the current node\n\n      // `target` instruction target\n      // `value` instruction value\n      instructionAfter(target, value) {\n        var child, i, removed;\n        // temporarily remove children starting *after* this\n        i = this.parent.children.indexOf(this);\n        removed = this.parent.children.splice(i + 1);\n        // add the new child\n        child = this.parent.instruction(target, value);\n        // add back removed children after new child\n        Array.prototype.push.apply(this.parent.children, removed);\n        return this;\n      }\n\n      // Creates the xml declaration\n\n      // `version` A version number string, e.g. 1.0\n      // `encoding` Encoding declaration, e.g. UTF-8\n      // `standalone` standalone document declaration: true or false\n      declaration(version, encoding, standalone) {\n        var doc, xmldec;\n        doc = this.document();\n        xmldec = new XMLDeclaration(doc, version, encoding, standalone);\n        // Replace XML declaration if exists, otherwise insert at top\n        if (doc.children.length === 0) {\n          doc.children.unshift(xmldec);\n        } else if (doc.children[0].type === NodeType.Declaration) {\n          doc.children[0] = xmldec;\n        } else {\n          doc.children.unshift(xmldec);\n        }\n        return doc.root() || doc;\n      }\n\n      // Creates the document type declaration\n\n      // `pubID` the public identifier of the external subset\n      // `sysID` the system identifier of the external subset\n      dtd(pubID, sysID) {\n        var child, doc, doctype, i, j, k, len, len1, ref1, ref2;\n        doc = this.document();\n        doctype = new XMLDocType(doc, pubID, sysID);\n        ref1 = doc.children;\n        // Replace DTD if exists\n        for (i = j = 0, len = ref1.length; j < len; i = ++j) {\n          child = ref1[i];\n          if (child.type === NodeType.DocType) {\n            doc.children[i] = doctype;\n            return doctype;\n          }\n        }\n        ref2 = doc.children;\n        // insert before root node if the root node exists\n        for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {\n          child = ref2[i];\n          if (child.isRoot) {\n            doc.children.splice(i, 0, doctype);\n            return doctype;\n          }\n        }\n        // otherwise append to end\n        doc.children.push(doctype);\n        return doctype;\n      }\n\n      // Gets the parent node\n      up() {\n        if (this.isRoot) {\n          throw new Error(\"The root node has no parent. Use doc() if you need to get the document object.\");\n        }\n        return this.parent;\n      }\n\n      // Gets the root node\n      root() {\n        var node;\n        node = this;\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node.rootObject;\n          } else if (node.isRoot) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      }\n\n      // Gets the node representing the XML document\n      document() {\n        var node;\n        node = this;\n        while (node) {\n          if (node.type === NodeType.Document) {\n            return node;\n          } else {\n            node = node.parent;\n          }\n        }\n      }\n\n      // Ends the document and converts string\n      end(options) {\n        return this.document().end(options);\n      }\n\n      // Gets the previous node\n      prev() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        if (i < 1) {\n          throw new Error(\"Already at the first node. \" + this.debugInfo());\n        }\n        return this.parent.children[i - 1];\n      }\n\n      // Gets the next node\n      next() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        if (i === -1 || i === this.parent.children.length - 1) {\n          throw new Error(\"Already at the last node. \" + this.debugInfo());\n        }\n        return this.parent.children[i + 1];\n      }\n\n      // Imports cloned root from another XML document\n\n      // `doc` the XML document to insert nodes from\n      importDocument(doc) {\n        var child, clonedRoot, j, len, ref1;\n        clonedRoot = doc.root().clone();\n        clonedRoot.parent = this;\n        clonedRoot.isRoot = false;\n        this.children.push(clonedRoot);\n        // set properties if imported element becomes the root node\n        if (this.type === NodeType.Document) {\n          clonedRoot.isRoot = true;\n          clonedRoot.documentObject = this;\n          this.rootObject = clonedRoot;\n          // set dtd name\n          if (this.children) {\n            ref1 = this.children;\n            for (j = 0, len = ref1.length; j < len; j++) {\n              child = ref1[j];\n              if (child.type === NodeType.DocType) {\n                child.name = clonedRoot.name;\n                break;\n              }\n            }\n          }\n        }\n        return this;\n      }\n\n      \n      // Returns debug string for this node\n      debugInfo(name) {\n        var ref1, ref2;\n        name = name || this.name;\n        if ((name == null) && !((ref1 = this.parent) != null ? ref1.name : void 0)) {\n          return \"\";\n        } else if (name == null) {\n          return \"parent: <\" + this.parent.name + \">\";\n        } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {\n          return \"node: <\" + name + \">\";\n        } else {\n          return \"node: <\" + name + \">, parent: <\" + this.parent.name + \">\";\n        }\n      }\n\n      // Aliases\n      ele(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      nod(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      txt(value) {\n        return this.text(value);\n      }\n\n      dat(value) {\n        return this.cdata(value);\n      }\n\n      com(value) {\n        return this.comment(value);\n      }\n\n      ins(target, value) {\n        return this.instruction(target, value);\n      }\n\n      doc() {\n        return this.document();\n      }\n\n      dec(version, encoding, standalone) {\n        return this.declaration(version, encoding, standalone);\n      }\n\n      e(name, attributes, text) {\n        return this.element(name, attributes, text);\n      }\n\n      n(name, attributes, text) {\n        return this.node(name, attributes, text);\n      }\n\n      t(value) {\n        return this.text(value);\n      }\n\n      d(value) {\n        return this.cdata(value);\n      }\n\n      c(value) {\n        return this.comment(value);\n      }\n\n      r(value) {\n        return this.raw(value);\n      }\n\n      i(target, value) {\n        return this.instruction(target, value);\n      }\n\n      u() {\n        return this.up();\n      }\n\n      // can be deprecated in a future release\n      importXMLBuilder(doc) {\n        return this.importDocument(doc);\n      }\n\n      // Adds or modifies an attribute.\n\n      // `name` attribute name\n      // `value` attribute value\n      attribute(name, value) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      att(name, value) {\n        return this.attribute(name, value);\n      }\n\n      a(name, value) {\n        return this.attribute(name, value);\n      }\n\n      // Removes an attribute\n\n      // `name` attribute name\n      removeAttribute(name) {\n        throw new Error(\"attribute() applies to element nodes only.\");\n      }\n\n      // DOM level 1 functions to be implemented later\n      replaceChild(newChild, oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      removeChild(oldChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      appendChild(newChild) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      hasChildNodes() {\n        return this.children.length !== 0;\n      }\n\n      cloneNode(deep) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      normalize() {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      // DOM level 2\n      isSupported(feature, version) {\n        return true;\n      }\n\n      hasAttributes() {\n        return this.attribs.length !== 0;\n      }\n\n      // DOM level 3 functions to be implemented later\n      compareDocumentPosition(other) {\n        var ref, res;\n        ref = this;\n        if (ref === other) {\n          return 0;\n        } else if (this.document() !== other.document()) {\n          res = DocumentPosition.Disconnected | DocumentPosition.ImplementationSpecific;\n          if (Math.random() < 0.5) {\n            res |= DocumentPosition.Preceding;\n          } else {\n            res |= DocumentPosition.Following;\n          }\n          return res;\n        } else if (ref.isAncestor(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Preceding;\n        } else if (ref.isDescendant(other)) {\n          return DocumentPosition.Contains | DocumentPosition.Following;\n        } else if (ref.isPreceding(other)) {\n          return DocumentPosition.Preceding;\n        } else {\n          return DocumentPosition.Following;\n        }\n      }\n\n      isSameNode(other) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupPrefix(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isDefaultNamespace(namespaceURI) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      lookupNamespaceURI(prefix) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      isEqualNode(node) {\n        var i, j, ref1;\n        if (node.nodeType !== this.nodeType) {\n          return false;\n        }\n        if (node.children.length !== this.children.length) {\n          return false;\n        }\n        for (i = j = 0, ref1 = this.children.length - 1; (0 <= ref1 ? j <= ref1 : j >= ref1); i = 0 <= ref1 ? ++j : --j) {\n          if (!this.children[i].isEqualNode(node.children[i])) {\n            return false;\n          }\n        }\n        return true;\n      }\n\n      getFeature(feature, version) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      setUserData(key, data, handler) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      getUserData(key) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n\n      // Returns true if other is an inclusive descendant of node,\n      // and false otherwise.\n      contains(other) {\n        if (!other) {\n          return false;\n        }\n        return other === this || this.isDescendant(other);\n      }\n\n      // An object A is called a descendant of an object B, if either A is \n      // a child of B or A is a child of an object C that is a descendant of B.\n      isDescendant(node) {\n        var child, isDescendantChild, j, len, ref1;\n        ref1 = this.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (node === child) {\n            return true;\n          }\n          isDescendantChild = child.isDescendant(node);\n          if (isDescendantChild) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      // An object A is called an ancestor of an object B if and only if\n      // B is a descendant of A.\n      isAncestor(node) {\n        return node.isDescendant(this);\n      }\n\n      // An object A is preceding an object B if A and B are in the \n      // same tree and A comes before B in tree order.\n      isPreceding(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos < thisPos;\n        }\n      }\n\n      // An object A is folllowing an object B if A and B are in the \n      // same tree and A comes after B in tree order.\n      isFollowing(node) {\n        var nodePos, thisPos;\n        nodePos = this.treePosition(node);\n        thisPos = this.treePosition(this);\n        if (nodePos === -1 || thisPos === -1) {\n          return false;\n        } else {\n          return nodePos > thisPos;\n        }\n      }\n\n      // Returns the preorder position of the given node in the tree, or -1\n      // if the node is not in the tree.\n      treePosition(node) {\n        var found, pos;\n        pos = 0;\n        found = false;\n        this.foreachTreeNode(this.document(), function(childNode) {\n          pos++;\n          if (!found && childNode === node) {\n            return found = true;\n          }\n        });\n        if (found) {\n          return pos;\n        } else {\n          return -1;\n        }\n      }\n\n      \n      // Depth-first preorder traversal through the XML tree\n      foreachTreeNode(node, func) {\n        var child, j, len, ref1, res;\n        node || (node = this.document());\n        ref1 = node.children;\n        for (j = 0, len = ref1.length; j < len; j++) {\n          child = ref1[j];\n          if (res = func(child)) {\n            return res;\n          } else {\n            res = this.foreachTreeNode(child, func);\n            if (res) {\n              return res;\n            }\n          }\n        }\n      }\n\n    };\n\n    // DOM level 1\n    Object.defineProperty(XMLNode.prototype, 'nodeName', {\n      get: function() {\n        return this.name;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeType', {\n      get: function() {\n        return this.type;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nodeValue', {\n      get: function() {\n        return this.value;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'parentNode', {\n      get: function() {\n        return this.parent;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'childNodes', {\n      get: function() {\n        if (!this.childNodeList || !this.childNodeList.nodes) {\n          this.childNodeList = new XMLNodeList(this.children);\n        }\n        return this.childNodeList;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'firstChild', {\n      get: function() {\n        return this.children[0] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'lastChild', {\n      get: function() {\n        return this.children[this.children.length - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'previousSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i - 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'nextSibling', {\n      get: function() {\n        var i;\n        i = this.parent.children.indexOf(this);\n        return this.parent.children[i + 1] || null;\n      }\n    });\n\n    Object.defineProperty(XMLNode.prototype, 'ownerDocument', {\n      get: function() {\n        return this.document() || null;\n      }\n    });\n\n    // DOM level 3\n    Object.defineProperty(XMLNode.prototype, 'textContent', {\n      get: function() {\n        var child, j, len, ref1, str;\n        if (this.nodeType === NodeType.Element || this.nodeType === NodeType.DocumentFragment) {\n          str = '';\n          ref1 = this.children;\n          for (j = 0, len = ref1.length; j < len; j++) {\n            child = ref1[j];\n            if (child.textContent) {\n              str += child.textContent;\n            }\n          }\n          return str;\n        } else {\n          return null;\n        }\n      },\n      set: function(value) {\n        throw new Error(\"This DOM method is not implemented.\" + this.debugInfo());\n      }\n    });\n\n    return XMLNode;\n\n  }).call(this);\n\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}