{"ast":null,"code":"'use strict';\n\n/*eslint-disable no-bitwise*/\n\n// A trick for browserified version.\n// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined\nvar NodeBuffer = require('buffer').Buffer;\nvar Type = require('../type');\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\nfunction resolveYamlBinary(data) {\n  if (null === data) {\n    return false;\n  }\n  var code,\n    idx,\n    bitlen = 0,\n    len = 0,\n    max = data.length,\n    map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) {\n      continue;\n    }\n\n    // Fail on illegal characters\n    if (code < 0) {\n      return false;\n    }\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return bitlen % 8 === 0;\n}\nfunction constructYamlBinary(data) {\n  var code,\n    idx,\n    tailbits,\n    input = data.replace(/[\\r\\n=]/g, ''),\n    // remove CR/LF & padding to simplify scan\n    max = input.length,\n    map = BASE64_MAP,\n    bits = 0,\n    result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 4 === 0 && idx) {\n      result.push(bits >> 16 & 0xFF);\n      result.push(bits >> 8 & 0xFF);\n      result.push(bits & 0xFF);\n    }\n    bits = bits << 6 | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = max % 4 * 6;\n  if (tailbits === 0) {\n    result.push(bits >> 16 & 0xFF);\n    result.push(bits >> 8 & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push(bits >> 10 & 0xFF);\n    result.push(bits >> 2 & 0xFF);\n  } else if (tailbits === 12) {\n    result.push(bits >> 4 & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    return new NodeBuffer(result);\n  }\n  return result;\n}\nfunction representYamlBinary(object /*, style*/) {\n  var result = '',\n    bits = 0,\n    idx,\n    tail,\n    max = object.length,\n    map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if (idx % 3 === 0 && idx) {\n      result += map[bits >> 18 & 0x3F];\n      result += map[bits >> 12 & 0x3F];\n      result += map[bits >> 6 & 0x3F];\n      result += map[bits & 0x3F];\n    }\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n  if (tail === 0) {\n    result += map[bits >> 18 & 0x3F];\n    result += map[bits >> 12 & 0x3F];\n    result += map[bits >> 6 & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[bits >> 10 & 0x3F];\n    result += map[bits >> 4 & 0x3F];\n    result += map[bits << 2 & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[bits >> 2 & 0x3F];\n    result += map[bits << 4 & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n  return result;\n}\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});","map":{"version":3,"names":["NodeBuffer","require","Buffer","Type","BASE64_MAP","resolveYamlBinary","data","code","idx","bitlen","len","max","length","map","indexOf","charAt","constructYamlBinary","tailbits","input","replace","bits","result","push","representYamlBinary","object","tail","isBinary","isBuffer","module","exports","kind","resolve","construct","predicate","represent"],"sources":["C:/Users/SashinTulsiram/Documents/Software/react-frontend-bulma/node_modules/svgo/node_modules/js-yaml/lib/js-yaml/type/binary.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable no-bitwise*/\n\n// A trick for browserified version.\n// Since we make browserifier to ignore `buffer` module, NodeBuffer will be undefined\nvar NodeBuffer = require('buffer').Buffer;\nvar Type       = require('../type');\n\n\n// [ 64, 65, 66 ] -> [ padding, CR, LF ]\nvar BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\nfunction resolveYamlBinary(data) {\n  if (null === data) {\n    return false;\n  }\n\n  var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;\n\n  // Convert one by one.\n  for (idx = 0; idx < max; idx++) {\n    code = map.indexOf(data.charAt(idx));\n\n    // Skip CR/LF\n    if (code > 64) { continue; }\n\n    // Fail on illegal characters\n    if (code < 0) { return false; }\n\n    bitlen += 6;\n  }\n\n  // If there are any bits left, source was corrupted\n  return (bitlen % 8) === 0;\n}\n\nfunction constructYamlBinary(data) {\n  var code, idx, tailbits,\n      input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n      max = input.length,\n      map = BASE64_MAP,\n      bits = 0,\n      result = [];\n\n  // Collect by 6*4 bits (3 bytes)\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 4 === 0) && idx) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    }\n\n    bits = (bits << 6) | map.indexOf(input.charAt(idx));\n  }\n\n  // Dump tail\n\n  tailbits = (max % 4) * 6;\n\n  if (tailbits === 0) {\n    result.push((bits >> 16) & 0xFF);\n    result.push((bits >> 8) & 0xFF);\n    result.push(bits & 0xFF);\n  } else if (tailbits === 18) {\n    result.push((bits >> 10) & 0xFF);\n    result.push((bits >> 2) & 0xFF);\n  } else if (tailbits === 12) {\n    result.push((bits >> 4) & 0xFF);\n  }\n\n  // Wrap into Buffer for NodeJS and leave Array for browser\n  if (NodeBuffer) {\n    return new NodeBuffer(result);\n  }\n\n  return result;\n}\n\nfunction representYamlBinary(object /*, style*/) {\n  var result = '', bits = 0, idx, tail,\n      max = object.length,\n      map = BASE64_MAP;\n\n  // Convert every three bytes to 4 ASCII characters.\n\n  for (idx = 0; idx < max; idx++) {\n    if ((idx % 3 === 0) && idx) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    }\n\n    bits = (bits << 8) + object[idx];\n  }\n\n  // Dump tail\n\n  tail = max % 3;\n\n  if (tail === 0) {\n    result += map[(bits >> 18) & 0x3F];\n    result += map[(bits >> 12) & 0x3F];\n    result += map[(bits >> 6) & 0x3F];\n    result += map[bits & 0x3F];\n  } else if (tail === 2) {\n    result += map[(bits >> 10) & 0x3F];\n    result += map[(bits >> 4) & 0x3F];\n    result += map[(bits << 2) & 0x3F];\n    result += map[64];\n  } else if (tail === 1) {\n    result += map[(bits >> 2) & 0x3F];\n    result += map[(bits << 4) & 0x3F];\n    result += map[64];\n    result += map[64];\n  }\n\n  return result;\n}\n\nfunction isBinary(object) {\n  return NodeBuffer && NodeBuffer.isBuffer(object);\n}\n\nmodule.exports = new Type('tag:yaml.org,2002:binary', {\n  kind: 'scalar',\n  resolve: resolveYamlBinary,\n  construct: constructYamlBinary,\n  predicate: isBinary,\n  represent: representYamlBinary\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}