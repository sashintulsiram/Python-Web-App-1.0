{"ast":null,"code":"/* global a2c */\n'use strict';\n\nvar regPathInstructions = /([MmLlHhVvCcSsQqTtAaZz])\\s*/,\n  regPathData = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)([eE][-+]?\\d+)?/g,\n  regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/,\n  transform2js = require('./_transforms').transform2js,\n  transformsMultiply = require('./_transforms').transformsMultiply,\n  transformArc = require('./_transforms').transformArc,\n  collections = require('./_collections.js'),\n  referencesProps = collections.referencesProps,\n  defaultStrokeWidth = collections.attrsGroupsDefaults.presentation['stroke-width'],\n  cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n  removeLeadingZero = require('../lib/svgo/tools').removeLeadingZero,\n  prevCtrlPoint;\n\n/**\n * Convert path string to JS representation.\n *\n * @param {String} pathString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\nexports.path2js = function (path) {\n  if (path.pathJS) return path.pathJS;\n  var paramsLength = {\n      // Number of parameters of every path command\n      H: 1,\n      V: 1,\n      M: 2,\n      L: 2,\n      T: 2,\n      Q: 4,\n      S: 4,\n      C: 6,\n      A: 7,\n      h: 1,\n      v: 1,\n      m: 2,\n      l: 2,\n      t: 2,\n      q: 4,\n      s: 4,\n      c: 6,\n      a: 7\n    },\n    pathData = [],\n    // JS representation of the path data\n    instruction,\n    // current instruction context\n    startMoveto = false;\n\n  // splitting path string into array like ['M', '10 50', 'L', '20 30']\n  path.attr('d').value.split(regPathInstructions).forEach(function (data) {\n    if (!data) return;\n    if (!startMoveto) {\n      if (data == 'M' || data == 'm') {\n        startMoveto = true;\n      } else return;\n    }\n\n    // instruction item\n    if (regPathInstructions.test(data)) {\n      instruction = data;\n\n      // z - instruction w/o data\n      if (instruction == 'Z' || instruction == 'z') {\n        pathData.push({\n          instruction: 'z'\n        });\n      }\n      // data item\n    } else {\n      data = data.match(regPathData);\n      if (!data) return;\n      data = data.map(Number);\n\n      // Subsequent moveto pairs of coordinates are threated as implicit lineto commands\n      // http://www.w3.org/TR/SVG/paths.html#PathDataMovetoCommands\n      if (instruction == 'M' || instruction == 'm') {\n        pathData.push({\n          instruction: pathData.length == 0 ? 'M' : instruction,\n          data: data.splice(0, 2)\n        });\n        instruction = instruction == 'M' ? 'L' : 'l';\n      }\n      for (var pair = paramsLength[instruction]; data.length;) {\n        pathData.push({\n          instruction: instruction,\n          data: data.splice(0, pair)\n        });\n      }\n    }\n  });\n\n  // First moveto is actually absolute. Subsequent coordinates were separated above.\n  if (pathData.length && pathData[0].instruction == 'm') {\n    pathData[0].instruction = 'M';\n  }\n  path.pathJS = pathData;\n  return pathData;\n};\n\n/**\n * Convert relative Path data to absolute.\n *\n * @param {Array} data input data\n * @return {Array} output data\n */\nvar relative2absolute = exports.relative2absolute = function (data) {\n  var currentPoint = [0, 0],\n    subpathPoint = [0, 0],\n    i;\n  data = data.map(function (item) {\n    var instruction = item.instruction,\n      itemData = item.data && item.data.slice();\n    if (instruction == 'M') {\n      set(currentPoint, itemData);\n      set(subpathPoint, itemData);\n    } else if ('mlcsqt'.indexOf(instruction) > -1) {\n      for (i = 0; i < itemData.length; i++) {\n        itemData[i] += currentPoint[i % 2];\n      }\n      set(currentPoint, itemData);\n      if (instruction == 'm') {\n        set(subpathPoint, itemData);\n      }\n    } else if (instruction == 'a') {\n      itemData[5] += currentPoint[0];\n      itemData[6] += currentPoint[1];\n      set(currentPoint, itemData);\n    } else if (instruction == 'h') {\n      itemData[0] += currentPoint[0];\n      currentPoint[0] = itemData[0];\n    } else if (instruction == 'v') {\n      itemData[0] += currentPoint[1];\n      currentPoint[1] = itemData[0];\n    } else if ('MZLCSQTA'.indexOf(instruction) > -1) {\n      set(currentPoint, itemData);\n    } else if (instruction == 'H') {\n      currentPoint[0] = itemData[0];\n    } else if (instruction == 'V') {\n      currentPoint[1] = itemData[0];\n    } else if (instruction == 'z') {\n      set(currentPoint, subpathPoint);\n    }\n    return instruction == 'z' ? {\n      instruction: 'z'\n    } : {\n      instruction: instruction.toUpperCase(),\n      data: itemData\n    };\n  });\n  return data;\n};\n\n/**\n * Apply transformation(s) to the Path data.\n *\n * @param {Object} elem current element\n * @param {Array} path input path data\n * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)\n * @return {Array} output path data\n */\nexports.applyTransforms = function (elem, path, params) {\n  // if there are no 'stroke' attr and references to other objects such as\n  // gradiends or clip-path which are also subjects to transform.\n  if (!elem.hasAttr('transform') || !elem.attr('transform').value || elem.someAttr(function (attr) {\n    return ~referencesProps.indexOf(attr.name) && ~attr.value.indexOf('url(');\n  })) return path;\n  var matrix = transformsMultiply(transform2js(elem.attr('transform').value)),\n    stroke = elem.computedAttr('stroke'),\n    transformPrecision = params.transformPrecision,\n    newPoint,\n    scale;\n  if (stroke && stroke.value != 'none') {\n    if (!params.applyTransformsStroked || (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) && (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2])) return path;\n    scale = +Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision);\n    if (scale !== 1) {\n      var strokeWidth = elem.computedAttr('stroke-width') || defaultStrokeWidth;\n      if (elem.hasAttr('stroke-width')) {\n        elem.attrs['stroke-width'].value = elem.attrs['stroke-width'].value.trim().replace(regNumericValues, function (num) {\n          return removeLeadingZero(num * scale);\n        });\n      } else {\n        elem.addAttr({\n          name: 'stroke-width',\n          prefix: '',\n          local: 'stroke-width',\n          value: strokeWidth.replace(regNumericValues, function (num) {\n            return removeLeadingZero(num * scale);\n          })\n        });\n      }\n    }\n  }\n  path.forEach(function (pathItem) {\n    if (pathItem.data) {\n      // h -> l\n      if (pathItem.instruction === 'h') {\n        pathItem.instruction = 'l';\n        pathItem.data[1] = 0;\n\n        // v -> l\n      } else if (pathItem.instruction === 'v') {\n        pathItem.instruction = 'l';\n        pathItem.data[1] = pathItem.data[0];\n        pathItem.data[0] = 0;\n      }\n\n      // if there is a translate() transform\n      if (pathItem.instruction === 'M' && (matrix.data[4] !== 0 || matrix.data[5] !== 0)) {\n        // then apply it only to the first absoluted M\n        newPoint = transformPoint(matrix.data, pathItem.data[0], pathItem.data[1]);\n        set(pathItem.data, newPoint);\n        set(pathItem.coords, newPoint);\n\n        // clear translate() data from transform matrix\n        matrix.data[4] = 0;\n        matrix.data[5] = 0;\n      } else {\n        if (pathItem.instruction == 'a') {\n          transformArc(pathItem.data, matrix.data);\n\n          // reduce number of digits in rotation angle\n          if (Math.abs(pathItem.data[2]) > 80) {\n            var a = pathItem.data[0],\n              rotation = pathItem.data[2];\n            pathItem.data[0] = pathItem.data[1];\n            pathItem.data[1] = a;\n            pathItem.data[2] = rotation + (rotation > 0 ? -90 : 90);\n          }\n          newPoint = transformPoint(matrix.data, pathItem.data[5], pathItem.data[6]);\n          pathItem.data[5] = newPoint[0];\n          pathItem.data[6] = newPoint[1];\n        } else {\n          for (var i = 0; i < pathItem.data.length; i += 2) {\n            newPoint = transformPoint(matrix.data, pathItem.data[i], pathItem.data[i + 1]);\n            pathItem.data[i] = newPoint[0];\n            pathItem.data[i + 1] = newPoint[1];\n          }\n        }\n        pathItem.coords[0] = pathItem.base[0] + pathItem.data[pathItem.data.length - 2];\n        pathItem.coords[1] = pathItem.base[1] + pathItem.data[pathItem.data.length - 1];\n      }\n    }\n  });\n\n  // remove transform attr\n  elem.removeAttr('transform');\n  return path;\n};\n\n/**\n * Apply transform 3x3 matrix to x-y point.\n *\n * @param {Array} matrix transform 3x3 matrix\n * @param {Array} point x-y point\n * @return {Array} point with new coordinates\n */\nfunction transformPoint(matrix, x, y) {\n  return [matrix[0] * x + matrix[2] * y + matrix[4], matrix[1] * x + matrix[3] * y + matrix[5]];\n}\n\n/**\n * Compute Cubic Bézie bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n * @param {Float} xd\n * @param {Float} yd\n *\n * @return {Object}\n */\nexports.computeCubicBoundingBox = function (xa, ya, xb, yb, xc, yc, xd, yd) {\n  var minx = Number.POSITIVE_INFINITY,\n    miny = Number.POSITIVE_INFINITY,\n    maxx = Number.NEGATIVE_INFINITY,\n    maxy = Number.NEGATIVE_INFINITY,\n    ts,\n    t,\n    x,\n    y,\n    i;\n\n  // X\n  if (xa < minx) {\n    minx = xa;\n  }\n  if (xa > maxx) {\n    maxx = xa;\n  }\n  if (xd < minx) {\n    minx = xd;\n  }\n  if (xd > maxx) {\n    maxx = xd;\n  }\n  ts = computeCubicFirstDerivativeRoots(xa, xb, xc, xd);\n  for (i = 0; i < ts.length; i++) {\n    t = ts[i];\n    if (t >= 0 && t <= 1) {\n      x = computeCubicBaseValue(t, xa, xb, xc, xd);\n      // y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n      if (x < minx) {\n        minx = x;\n      }\n      if (x > maxx) {\n        maxx = x;\n      }\n    }\n  }\n\n  // Y\n  if (ya < miny) {\n    miny = ya;\n  }\n  if (ya > maxy) {\n    maxy = ya;\n  }\n  if (yd < miny) {\n    miny = yd;\n  }\n  if (yd > maxy) {\n    maxy = yd;\n  }\n  ts = computeCubicFirstDerivativeRoots(ya, yb, yc, yd);\n  for (i = 0; i < ts.length; i++) {\n    t = ts[i];\n    if (t >= 0 && t <= 1) {\n      // x = computeCubicBaseValue(t, xa, xb, xc, xd);\n      y = computeCubicBaseValue(t, ya, yb, yc, yd);\n      if (y < miny) {\n        miny = y;\n      }\n      if (y > maxy) {\n        maxy = y;\n      }\n    }\n  }\n  return {\n    minx: minx,\n    miny: miny,\n    maxx: maxx,\n    maxy: maxy\n  };\n};\n\n// compute the value for the cubic bezier function at time=t\nfunction computeCubicBaseValue(t, a, b, c, d) {\n  var mt = 1 - t;\n  return mt * mt * mt * a + 3 * mt * mt * t * b + 3 * mt * t * t * c + t * t * t * d;\n}\n\n// compute the value for the first derivative of the cubic bezier function at time=t\nfunction computeCubicFirstDerivativeRoots(a, b, c, d) {\n  var result = [-1, -1],\n    tl = -a + 2 * b - c,\n    tr = -Math.sqrt(-a * (c - d) + b * b - b * (c + d) + c * c),\n    dn = -a + 3 * b - 3 * c + d;\n  if (dn !== 0) {\n    result[0] = (tl + tr) / dn;\n    result[1] = (tl - tr) / dn;\n  }\n  return result;\n}\n\n/**\n * Compute Quadratic Bézier bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n *\n * @return {Object}\n */\nexports.computeQuadraticBoundingBox = function (xa, ya, xb, yb, xc, yc) {\n  var minx = Number.POSITIVE_INFINITY,\n    miny = Number.POSITIVE_INFINITY,\n    maxx = Number.NEGATIVE_INFINITY,\n    maxy = Number.NEGATIVE_INFINITY,\n    t,\n    x,\n    y;\n\n  // X\n  if (xa < minx) {\n    minx = xa;\n  }\n  if (xa > maxx) {\n    maxx = xa;\n  }\n  if (xc < minx) {\n    minx = xc;\n  }\n  if (xc > maxx) {\n    maxx = xc;\n  }\n  t = computeQuadraticFirstDerivativeRoot(xa, xb, xc);\n  if (t >= 0 && t <= 1) {\n    x = computeQuadraticBaseValue(t, xa, xb, xc);\n    // y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n    if (x < minx) {\n      minx = x;\n    }\n    if (x > maxx) {\n      maxx = x;\n    }\n  }\n\n  // Y\n  if (ya < miny) {\n    miny = ya;\n  }\n  if (ya > maxy) {\n    maxy = ya;\n  }\n  if (yc < miny) {\n    miny = yc;\n  }\n  if (yc > maxy) {\n    maxy = yc;\n  }\n  t = computeQuadraticFirstDerivativeRoot(ya, yb, yc);\n  if (t >= 0 && t <= 1) {\n    // x = computeQuadraticBaseValue(t, xa, xb, xc);\n    y = computeQuadraticBaseValue(t, ya, yb, yc);\n    if (y < miny) {\n      miny = y;\n    }\n    if (y > maxy) {\n      maxy = y;\n    }\n  }\n  return {\n    minx: minx,\n    miny: miny,\n    maxx: maxx,\n    maxy: maxy\n  };\n};\n\n// compute the value for the quadratic bezier function at time=t\nfunction computeQuadraticBaseValue(t, a, b, c) {\n  var mt = 1 - t;\n  return mt * mt * a + 2 * mt * t * b + t * t * c;\n}\n\n// compute the value for the first derivative of the quadratic bezier function at time=t\nfunction computeQuadraticFirstDerivativeRoot(a, b, c) {\n  var t = -1,\n    denominator = a - 2 * b + c;\n  if (denominator !== 0) {\n    t = (a - b) / denominator;\n  }\n  return t;\n}\n\n/**\n * Convert path array to string.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {String} output path string\n */\nexports.js2path = function (path, data, params) {\n  path.pathJS = data;\n  if (params.collapseRepeated) {\n    data = collapseRepeated(data);\n  }\n  path.attr('d').value = data.reduce(function (pathString, item) {\n    return pathString += item.instruction + (item.data ? cleanupOutData(item.data, params) : '');\n  }, '');\n};\n\n/**\n * Collapse repeated instructions data\n *\n * @param {Array} path input path data\n * @return {Array} output path data\n */\nfunction collapseRepeated(data) {\n  var prev, prevIndex;\n\n  // copy an array and modifieds item to keep original data untouched\n  data = data.reduce(function (newPath, item) {\n    if (prev && item.data && item.instruction == prev.instruction) {\n      // concat previous data with current\n      if (item.instruction != 'M') {\n        prev = newPath[prevIndex] = {\n          instruction: prev.instruction,\n          data: prev.data.concat(item.data),\n          coords: item.coords,\n          base: prev.base\n        };\n      } else {\n        prev.data = item.data;\n        prev.coords = item.coords;\n      }\n    } else {\n      newPath.push(item);\n      prev = item;\n      prevIndex = newPath.length - 1;\n    }\n    return newPath;\n  }, []);\n  return data;\n}\nfunction set(dest, source) {\n  dest[0] = source[source.length - 2];\n  dest[1] = source[source.length - 1];\n  return dest;\n}\n\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @param {Array} path1 JS path representation\n * @param {Array} path2 JS path representation\n * @return {Boolean}\n */\nexports.intersects = function (path1, path2) {\n  if (path1.length < 3 || path2.length < 3) return false; // nothing to fill\n\n  // Collect points of every subpath.\n  var points1 = relative2absolute(path1).reduce(gatherPoints, []),\n    points2 = relative2absolute(path2).reduce(gatherPoints, []);\n\n  // Axis-aligned bounding box check.\n  if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.every(function (set1) {\n    return points2.every(function (set2) {\n      return set1[set1.maxX][0] <= set2[set2.minX][0] || set2[set2.maxX][0] <= set1[set1.minX][0] || set1[set1.maxY][1] <= set2[set2.minY][1] || set2[set2.maxY][1] <= set1[set1.minY][1];\n    });\n  })) return false;\n\n  // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n  var hullNest1 = points1.map(convexHull),\n    hullNest2 = points2.map(convexHull);\n\n  // Check intersection of every subpath of the first path with every subpath of the second.\n  return hullNest1.some(function (hull1) {\n    if (hull1.length < 3) return false;\n    return hullNest2.some(function (hull2) {\n      if (hull2.length < 3) return false;\n      var simplex = [getSupport(hull1, hull2, [1, 0])],\n        // create the initial simplex\n        direction = minus(simplex[0]); // set the direction to point towards the origin\n\n      var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n      while (true) {\n        if (iterations-- == 0) {\n          console.error('Error: infinite loop while processing mergePaths plugin.');\n          return true; // true is the safe value that means “do nothing with paths”\n        }\n        // add a new point\n        simplex.push(getSupport(hull1, hull2, direction));\n        // see if the new point was on the correct side of the origin\n        if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;\n        // process the simplex\n        if (processSimplex(simplex, direction)) return true;\n      }\n    });\n  });\n  function getSupport(a, b, direction) {\n    return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n  }\n\n  // Computes farthest polygon point in particular direction.\n  // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n  // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n  function supportPoint(polygon, direction) {\n    var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY,\n      max = -Infinity,\n      value;\n    while ((value = dot(polygon[index], direction)) > max) {\n      max = value;\n      index = ++index % polygon.length;\n    }\n    return polygon[(index || polygon.length) - 1];\n  }\n};\nfunction processSimplex(simplex, direction) {\n  /* jshint -W004 */\n\n  // we only need to handle to 1-simplex and 2-simplex\n  if (simplex.length == 2) {\n    // 1-simplex\n    var a = simplex[1],\n      b = simplex[0],\n      AO = minus(simplex[1]),\n      AB = sub(b, a);\n    // AO is in the same direction as AB\n    if (dot(AO, AB) > 0) {\n      // get the vector perpendicular to AB facing O\n      set(direction, orth(AB, a));\n    } else {\n      set(direction, AO);\n      // only A remains in the simplex\n      simplex.shift();\n    }\n  } else {\n    // 2-simplex\n    var a = simplex[2],\n      // [a, b, c] = simplex\n      b = simplex[1],\n      c = simplex[0],\n      AB = sub(b, a),\n      AC = sub(c, a),\n      AO = minus(a),\n      ACB = orth(AB, AC),\n      // the vector perpendicular to AB facing away from C\n      ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n    if (dot(ACB, AO) > 0) {\n      if (dot(AB, AO) > 0) {\n        // region 4\n        set(direction, ACB);\n        simplex.shift(); // simplex = [b, a]\n      } else {\n        // region 5\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else if (dot(ABC, AO) > 0) {\n      if (dot(AC, AO) > 0) {\n        // region 6\n        set(direction, ABC);\n        simplex.splice(1, 1); // simplex = [c, a]\n      } else {\n        // region 5 (again)\n        set(direction, AO);\n        simplex.splice(0, 2); // simplex = [a]\n      }\n    } else\n      // region 7\n      return true;\n  }\n  return false;\n}\nfunction minus(v) {\n  return [-v[0], -v[1]];\n}\nfunction sub(v1, v2) {\n  return [v1[0] - v2[0], v1[1] - v2[1]];\n}\nfunction dot(v1, v2) {\n  return v1[0] * v2[0] + v1[1] * v2[1];\n}\nfunction orth(v, from) {\n  var o = [-v[1], v[0]];\n  return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\nfunction gatherPoints(points, item, index, path) {\n  var subPath = points.length && points[points.length - 1],\n    prev = index && path[index - 1],\n    basePoint = subPath.length && subPath[subPath.length - 1],\n    data = item.data,\n    ctrlPoint = basePoint;\n  switch (item.instruction) {\n    case 'M':\n      points.push(subPath = []);\n      break;\n    case 'H':\n      addPoint(subPath, [data[0], basePoint[1]]);\n      break;\n    case 'V':\n      addPoint(subPath, [basePoint[0], data[0]]);\n      break;\n    case 'Q':\n      addPoint(subPath, data.slice(0, 2));\n      prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n      break;\n    case 'T':\n      if (prev.instruction == 'Q' && prev.instruction == 'T') {\n        ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n        addPoint(subPath, ctrlPoint);\n        prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n      }\n      break;\n    case 'C':\n      // Approximate quibic Bezier curve with middle points between control points\n      addPoint(subPath, [.5 * (basePoint[0] + data[0]), .5 * (basePoint[1] + data[1])]);\n      addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n      addPoint(subPath, [.5 * (data[2] + data[4]), .5 * (data[3] + data[5])]);\n      prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n      break;\n    case 'S':\n      if (prev.instruction == 'C' && prev.instruction == 'S') {\n        addPoint(subPath, [basePoint[0] + .5 * prevCtrlPoint[0], basePoint[1] + .5 * prevCtrlPoint[1]]);\n        ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n      }\n      addPoint(subPath, [.5 * (ctrlPoint[0] + data[0]), .5 * (ctrlPoint[1] + data[1])]);\n      addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n      prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n      break;\n    case 'A':\n      // Convert the arc to bezier curves and use the same approximation\n      var curves = a2c.apply(0, basePoint.concat(data));\n      for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length;) {\n        addPoint(subPath, [.5 * (basePoint[0] + cData[0]), .5 * (basePoint[1] + cData[1])]);\n        addPoint(subPath, [.5 * (cData[0] + cData[2]), .5 * (cData[1] + cData[3])]);\n        addPoint(subPath, [.5 * (cData[2] + cData[4]), .5 * (cData[3] + cData[5])]);\n        if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));\n      }\n      break;\n  }\n  // Save final command coordinates\n  if (data && data.length >= 2) addPoint(subPath, data.slice(-2));\n  return points;\n  function toAbsolute(n, i) {\n    return n + basePoint[i % 2];\n  }\n\n  // Writes data about the extreme points on each axle\n  function addPoint(path, point) {\n    if (!path.length || point[1] > path[path.maxY][1]) {\n      path.maxY = path.length;\n      points.maxY = points.length ? Math.max(point[1], points.maxY) : point[1];\n    }\n    if (!path.length || point[0] > path[path.maxX][0]) {\n      path.maxX = path.length;\n      points.maxX = points.length ? Math.max(point[0], points.maxX) : point[0];\n    }\n    if (!path.length || point[1] < path[path.minY][1]) {\n      path.minY = path.length;\n      points.minY = points.length ? Math.min(point[1], points.minY) : point[1];\n    }\n    if (!path.length || point[0] < path[path.minX][0]) {\n      path.minX = path.length;\n      points.minX = points.length ? Math.min(point[0], points.minX) : point[0];\n    }\n    path.push(point);\n  }\n}\n\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @param points An array of [X, Y] coordinates\n */\nfunction convexHull(points) {\n  /* jshint -W004 */\n\n  points.sort(function (a, b) {\n    return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n  });\n  var lower = [],\n    minY = 0,\n    bottom = 0;\n  for (var i = 0; i < points.length; i++) {\n    while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n      lower.pop();\n    }\n    if (points[i][1] < points[minY][1]) {\n      minY = i;\n      bottom = lower.length;\n    }\n    lower.push(points[i]);\n  }\n  var upper = [],\n    maxY = points.length - 1,\n    top = 0;\n  for (var i = points.length; i--;) {\n    while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n      upper.pop();\n    }\n    if (points[i][1] > points[maxY][1]) {\n      maxY = i;\n      top = upper.length;\n    }\n    upper.push(points[i]);\n  }\n\n  // last points are equal to starting points of the other part\n  upper.pop();\n  lower.pop();\n  var hull = lower.concat(upper);\n  hull.minX = 0; // by sorting\n  hull.maxX = lower.length;\n  hull.minY = bottom;\n  hull.maxY = (lower.length + top) % hull.length;\n  return hull;\n}\nfunction cross(o, a, b) {\n  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\n/* Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n */\n\n// jshint ignore: start\nfunction a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n  // for more information of where this Math came from visit:\n  // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n  var _120 = Math.PI * 120 / 180,\n    rad = Math.PI / 180 * (+angle || 0),\n    res = [],\n    rotateX = function (x, y, rad) {\n      return x * Math.cos(rad) - y * Math.sin(rad);\n    },\n    rotateY = function (x, y, rad) {\n      return x * Math.sin(rad) + y * Math.cos(rad);\n    };\n  if (!recursive) {\n    x1 = rotateX(x1, y1, -rad);\n    y1 = rotateY(x1, y1, -rad);\n    x2 = rotateX(x2, y2, -rad);\n    y2 = rotateY(x2, y2, -rad);\n    var x = (x1 - x2) / 2,\n      y = (y1 - y2) / 2;\n    var h = x * x / (rx * rx) + y * y / (ry * ry);\n    if (h > 1) {\n      h = Math.sqrt(h);\n      rx = h * rx;\n      ry = h * ry;\n    }\n    var rx2 = rx * rx,\n      ry2 = ry * ry,\n      k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n      cx = k * rx * y / ry + (x1 + x2) / 2,\n      cy = k * -ry * x / rx + (y1 + y2) / 2,\n      f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),\n      f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n    f1 = x1 < cx ? Math.PI - f1 : f1;\n    f2 = x2 < cx ? Math.PI - f2 : f2;\n    f1 < 0 && (f1 = Math.PI * 2 + f1);\n    f2 < 0 && (f2 = Math.PI * 2 + f2);\n    if (sweep_flag && f1 > f2) {\n      f1 = f1 - Math.PI * 2;\n    }\n    if (!sweep_flag && f2 > f1) {\n      f2 = f2 - Math.PI * 2;\n    }\n  } else {\n    f1 = recursive[0];\n    f2 = recursive[1];\n    cx = recursive[2];\n    cy = recursive[3];\n  }\n  var df = f2 - f1;\n  if (Math.abs(df) > _120) {\n    var f2old = f2,\n      x2old = x2,\n      y2old = y2;\n    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n    x2 = cx + rx * Math.cos(f2);\n    y2 = cy + ry * Math.sin(f2);\n    res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n  }\n  df = f2 - f1;\n  var c1 = Math.cos(f1),\n    s1 = Math.sin(f1),\n    c2 = Math.cos(f2),\n    s2 = Math.sin(f2),\n    t = Math.tan(df / 4),\n    hx = 4 / 3 * rx * t,\n    hy = 4 / 3 * ry * t,\n    m = [-hx * s1, hy * c1, x2 + hx * s2 - x1, y2 - hy * c2 - y1, x2 - x1, y2 - y1];\n  if (recursive) {\n    return m.concat(res);\n  } else {\n    res = m.concat(res);\n    var newres = [];\n    for (var i = 0, n = res.length; i < n; i++) {\n      newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);\n    }\n    return newres;\n  }\n}\n// jshint ignore: end","map":{"version":3,"names":["regPathInstructions","regPathData","regNumericValues","transform2js","require","transformsMultiply","transformArc","collections","referencesProps","defaultStrokeWidth","attrsGroupsDefaults","presentation","cleanupOutData","removeLeadingZero","prevCtrlPoint","exports","path2js","path","pathJS","paramsLength","H","V","M","L","T","Q","S","C","A","h","v","m","l","t","q","s","c","a","pathData","instruction","startMoveto","attr","value","split","forEach","data","test","push","match","map","Number","length","splice","pair","relative2absolute","currentPoint","subpathPoint","i","item","itemData","slice","set","indexOf","toUpperCase","applyTransforms","elem","params","hasAttr","someAttr","name","matrix","stroke","computedAttr","transformPrecision","newPoint","scale","applyTransformsStroked","Math","sqrt","toFixed","strokeWidth","attrs","trim","replace","num","addAttr","prefix","local","pathItem","transformPoint","coords","abs","rotation","base","removeAttr","x","y","computeCubicBoundingBox","xa","ya","xb","yb","xc","yc","xd","yd","minx","POSITIVE_INFINITY","miny","maxx","NEGATIVE_INFINITY","maxy","ts","computeCubicFirstDerivativeRoots","computeCubicBaseValue","b","d","mt","result","tl","tr","dn","computeQuadraticBoundingBox","computeQuadraticFirstDerivativeRoot","computeQuadraticBaseValue","denominator","js2path","collapseRepeated","reduce","pathString","prev","prevIndex","newPath","concat","dest","source","intersects","path1","path2","points1","gatherPoints","points2","maxX","minX","maxY","minY","every","set1","set2","hullNest1","convexHull","hullNest2","some","hull1","hull2","simplex","getSupport","direction","minus","iterations","console","error","dot","processSimplex","sub","supportPoint","polygon","index","max","Infinity","AO","AB","orth","shift","AC","ACB","ABC","v1","v2","from","o","points","subPath","basePoint","ctrlPoint","addPoint","curves","a2c","apply","cData","toAbsolute","n","point","min","sort","lower","bottom","cross","pop","upper","top","hull","x1","y1","rx","ry","angle","large_arc_flag","sweep_flag","x2","y2","recursive","_120","PI","rad","res","rotateX","cos","sin","rotateY","rx2","ry2","k","cx","cy","f1","asin","f2","df","f2old","x2old","y2old","c1","s1","c2","s2","tan","hx","hy","newres"],"sources":["C:/Users/SashinTulsiram/Documents/Software/react-frontend-bulma/node_modules/svgo/plugins/_path.js"],"sourcesContent":["/* global a2c */\n'use strict';\n\nvar regPathInstructions = /([MmLlHhVvCcSsQqTtAaZz])\\s*/,\n    regPathData = /[-+]?(?:\\d*\\.\\d+|\\d+\\.?)([eE][-+]?\\d+)?/g,\n    regNumericValues = /[-+]?(\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?/,\n    transform2js = require('./_transforms').transform2js,\n    transformsMultiply = require('./_transforms').transformsMultiply,\n    transformArc = require('./_transforms').transformArc,\n    collections = require('./_collections.js'),\n    referencesProps = collections.referencesProps,\n    defaultStrokeWidth = collections.attrsGroupsDefaults.presentation['stroke-width'],\n    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    removeLeadingZero = require('../lib/svgo/tools').removeLeadingZero,\n    prevCtrlPoint;\n\n/**\n * Convert path string to JS representation.\n *\n * @param {String} pathString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\nexports.path2js = function(path) {\n    if (path.pathJS) return path.pathJS;\n\n    var paramsLength = { // Number of parameters of every path command\n            H: 1, V: 1, M: 2, L: 2, T: 2, Q: 4, S: 4, C: 6, A: 7,\n            h: 1, v: 1, m: 2, l: 2, t: 2, q: 4, s: 4, c: 6, a: 7\n        },\n        pathData = [],   // JS representation of the path data\n        instruction, // current instruction context\n        startMoveto = false;\n\n    // splitting path string into array like ['M', '10 50', 'L', '20 30']\n    path.attr('d').value.split(regPathInstructions).forEach(function(data) {\n        if (!data) return;\n        if (!startMoveto) {\n            if (data == 'M' || data == 'm') {\n                startMoveto = true;\n            } else return;\n        }\n\n        // instruction item\n        if (regPathInstructions.test(data)) {\n            instruction = data;\n\n            // z - instruction w/o data\n            if (instruction == 'Z' || instruction == 'z') {\n                pathData.push({\n                    instruction: 'z'\n                });\n            }\n        // data item\n        } else {\n            data = data.match(regPathData);\n            if (!data) return;\n\n            data = data.map(Number);\n\n            // Subsequent moveto pairs of coordinates are threated as implicit lineto commands\n            // http://www.w3.org/TR/SVG/paths.html#PathDataMovetoCommands\n            if (instruction == 'M' || instruction == 'm') {\n                pathData.push({\n                    instruction: pathData.length == 0 ? 'M' : instruction,\n                    data: data.splice(0, 2)\n                });\n                instruction = instruction == 'M' ? 'L' : 'l';\n            }\n\n            for (var pair = paramsLength[instruction]; data.length;) {\n                pathData.push({\n                    instruction: instruction,\n                    data: data.splice(0, pair)\n                });\n            }\n        }\n    });\n\n    // First moveto is actually absolute. Subsequent coordinates were separated above.\n    if (pathData.length && pathData[0].instruction == 'm') {\n        pathData[0].instruction = 'M';\n    }\n    path.pathJS = pathData;\n\n    return pathData;\n};\n\n/**\n * Convert relative Path data to absolute.\n *\n * @param {Array} data input data\n * @return {Array} output data\n */\nvar relative2absolute = exports.relative2absolute = function(data) {\n    var currentPoint = [0, 0],\n        subpathPoint = [0, 0],\n        i;\n\n    data = data.map(function(item) {\n\n        var instruction = item.instruction,\n            itemData = item.data && item.data.slice();\n\n        if (instruction == 'M') {\n\n            set(currentPoint, itemData);\n            set(subpathPoint, itemData);\n\n        } else if ('mlcsqt'.indexOf(instruction) > -1) {\n\n            for (i = 0; i < itemData.length; i++) {\n                itemData[i] += currentPoint[i % 2];\n            }\n            set(currentPoint, itemData);\n\n            if (instruction == 'm') {\n                set(subpathPoint, itemData);\n            }\n\n        } else if (instruction == 'a') {\n\n            itemData[5] += currentPoint[0];\n            itemData[6] += currentPoint[1];\n            set(currentPoint, itemData);\n\n        } else if (instruction == 'h') {\n\n            itemData[0] += currentPoint[0];\n            currentPoint[0] = itemData[0];\n\n        } else if (instruction == 'v') {\n\n            itemData[0] += currentPoint[1];\n            currentPoint[1] = itemData[0];\n\n        } else if ('MZLCSQTA'.indexOf(instruction) > -1) {\n\n            set(currentPoint, itemData);\n\n        } else if (instruction == 'H') {\n\n            currentPoint[0] = itemData[0];\n\n        } else if (instruction == 'V') {\n\n            currentPoint[1] = itemData[0];\n\n        } else if (instruction == 'z') {\n\n            set(currentPoint, subpathPoint);\n\n        }\n\n        return instruction == 'z' ?\n            { instruction: 'z' } :\n            {\n                instruction: instruction.toUpperCase(),\n                data: itemData\n            };\n\n    });\n\n    return data;\n};\n\n/**\n * Apply transformation(s) to the Path data.\n *\n * @param {Object} elem current element\n * @param {Array} path input path data\n * @param {Object} params whether to apply transforms to stroked lines and transform precision (used for stroke width)\n * @return {Array} output path data\n */\nexports.applyTransforms = function(elem, path, params) {\n    // if there are no 'stroke' attr and references to other objects such as\n    // gradiends or clip-path which are also subjects to transform.\n    if (!elem.hasAttr('transform') || !elem.attr('transform').value ||\n        elem.someAttr(function(attr) {\n            return ~referencesProps.indexOf(attr.name) && ~attr.value.indexOf('url(');\n        }))\n        return path;\n\n    var matrix = transformsMultiply(transform2js(elem.attr('transform').value)),\n        stroke = elem.computedAttr('stroke'),\n        transformPrecision = params.transformPrecision,\n        newPoint, scale;\n\n    if (stroke && stroke.value != 'none') {\n        if (!params.applyTransformsStroked ||\n            (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) &&\n            (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2]))\n            return path;\n\n        scale = +Math.sqrt(matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]).toFixed(transformPrecision);\n\n        if (scale !== 1) {\n            var strokeWidth = elem.computedAttr('stroke-width') || defaultStrokeWidth;\n\n            if (elem.hasAttr('stroke-width')) {\n                elem.attrs['stroke-width'].value = elem.attrs['stroke-width'].value.trim()\n                    .replace(regNumericValues, function(num) { return removeLeadingZero(num * scale) });\n            } else {\n                elem.addAttr({\n                    name: 'stroke-width',\n                    prefix: '',\n                    local: 'stroke-width',\n                    value: strokeWidth.replace(regNumericValues, function(num) { return removeLeadingZero(num * scale) })\n                });\n            }\n        }\n    }\n\n    path.forEach(function(pathItem) {\n\n        if (pathItem.data) {\n\n            // h -> l\n            if (pathItem.instruction === 'h') {\n\n                pathItem.instruction = 'l';\n                pathItem.data[1] = 0;\n\n            // v -> l\n            } else if (pathItem.instruction === 'v') {\n\n                pathItem.instruction = 'l';\n                pathItem.data[1] = pathItem.data[0];\n                pathItem.data[0] = 0;\n\n            }\n\n            // if there is a translate() transform\n            if (pathItem.instruction === 'M' &&\n                (matrix.data[4] !== 0 ||\n                matrix.data[5] !== 0)\n            ) {\n\n                // then apply it only to the first absoluted M\n                newPoint = transformPoint(matrix.data, pathItem.data[0], pathItem.data[1]);\n                set(pathItem.data, newPoint);\n                set(pathItem.coords, newPoint);\n\n                // clear translate() data from transform matrix\n                matrix.data[4] = 0;\n                matrix.data[5] = 0;\n\n            } else {\n\n                if (pathItem.instruction == 'a') {\n\n                    transformArc(pathItem.data, matrix.data);\n\n                    // reduce number of digits in rotation angle\n                    if (Math.abs(pathItem.data[2]) > 80) {\n                        var a = pathItem.data[0],\n                            rotation = pathItem.data[2];\n                        pathItem.data[0] = pathItem.data[1];\n                        pathItem.data[1] = a;\n                        pathItem.data[2] = rotation + (rotation > 0 ? -90 : 90);\n                    }\n\n                    newPoint = transformPoint(matrix.data, pathItem.data[5], pathItem.data[6]);\n                    pathItem.data[5] = newPoint[0];\n                    pathItem.data[6] = newPoint[1];\n\n                } else {\n\n                    for (var i = 0; i < pathItem.data.length; i += 2) {\n                        newPoint = transformPoint(matrix.data, pathItem.data[i], pathItem.data[i + 1]);\n                        pathItem.data[i] = newPoint[0];\n                        pathItem.data[i + 1] = newPoint[1];\n                    }\n                }\n\n                pathItem.coords[0] = pathItem.base[0] + pathItem.data[pathItem.data.length - 2];\n                pathItem.coords[1] = pathItem.base[1] + pathItem.data[pathItem.data.length - 1];\n\n            }\n\n        }\n\n    });\n\n    // remove transform attr\n    elem.removeAttr('transform');\n\n    return path;\n};\n\n/**\n * Apply transform 3x3 matrix to x-y point.\n *\n * @param {Array} matrix transform 3x3 matrix\n * @param {Array} point x-y point\n * @return {Array} point with new coordinates\n */\nfunction transformPoint(matrix, x, y) {\n\n    return [\n        matrix[0] * x + matrix[2] * y + matrix[4],\n        matrix[1] * x + matrix[3] * y + matrix[5]\n    ];\n\n}\n\n/**\n * Compute Cubic Bézie bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n * @param {Float} xd\n * @param {Float} yd\n *\n * @return {Object}\n */\nexports.computeCubicBoundingBox = function(xa, ya, xb, yb, xc, yc, xd, yd) {\n\n    var minx = Number.POSITIVE_INFINITY,\n        miny = Number.POSITIVE_INFINITY,\n        maxx = Number.NEGATIVE_INFINITY,\n        maxy = Number.NEGATIVE_INFINITY,\n        ts,\n        t,\n        x,\n        y,\n        i;\n\n    // X\n    if (xa < minx) { minx = xa; }\n    if (xa > maxx) { maxx = xa; }\n    if (xd < minx) { minx= xd; }\n    if (xd > maxx) { maxx = xd; }\n\n    ts = computeCubicFirstDerivativeRoots(xa, xb, xc, xd);\n\n    for (i = 0; i < ts.length; i++) {\n\n        t = ts[i];\n\n        if (t >= 0 && t <= 1) {\n            x = computeCubicBaseValue(t, xa, xb, xc, xd);\n            // y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n            if (x < minx) { minx = x; }\n            if (x > maxx) { maxx = x; }\n        }\n\n    }\n\n    // Y\n    if (ya < miny) { miny = ya; }\n    if (ya > maxy) { maxy = ya; }\n    if (yd < miny) { miny = yd; }\n    if (yd > maxy) { maxy = yd; }\n\n    ts = computeCubicFirstDerivativeRoots(ya, yb, yc, yd);\n\n    for (i = 0; i < ts.length; i++) {\n\n        t = ts[i];\n\n        if (t >= 0 && t <= 1) {\n            // x = computeCubicBaseValue(t, xa, xb, xc, xd);\n            y = computeCubicBaseValue(t, ya, yb, yc, yd);\n\n            if (y < miny) { miny = y; }\n            if (y > maxy) { maxy = y; }\n        }\n\n    }\n\n    return {\n        minx: minx,\n        miny: miny,\n        maxx: maxx,\n        maxy: maxy\n    };\n\n};\n\n// compute the value for the cubic bezier function at time=t\nfunction computeCubicBaseValue(t, a, b, c, d) {\n\n    var mt = 1 - t;\n\n    return mt * mt * mt * a + 3 * mt * mt * t * b + 3 * mt * t * t * c + t * t * t * d;\n\n}\n\n// compute the value for the first derivative of the cubic bezier function at time=t\nfunction computeCubicFirstDerivativeRoots(a, b, c, d) {\n\n    var result = [-1, -1],\n        tl = -a + 2 * b - c,\n        tr = -Math.sqrt(-a * (c - d) + b * b - b * (c + d) + c * c),\n        dn = -a + 3 * b - 3 * c + d;\n\n    if (dn !== 0) {\n        result[0] = (tl + tr) / dn;\n        result[1] = (tl - tr) / dn;\n    }\n\n    return result;\n\n}\n\n/**\n * Compute Quadratic Bézier bounding box.\n *\n * @see http://processingjs.nihongoresources.com/bezierinfo/\n *\n * @param {Float} xa\n * @param {Float} ya\n * @param {Float} xb\n * @param {Float} yb\n * @param {Float} xc\n * @param {Float} yc\n *\n * @return {Object}\n */\nexports.computeQuadraticBoundingBox = function(xa, ya, xb, yb, xc, yc) {\n\n    var minx = Number.POSITIVE_INFINITY,\n        miny = Number.POSITIVE_INFINITY,\n        maxx = Number.NEGATIVE_INFINITY,\n        maxy = Number.NEGATIVE_INFINITY,\n        t,\n        x,\n        y;\n\n    // X\n    if (xa < minx) { minx = xa; }\n    if (xa > maxx) { maxx = xa; }\n    if (xc < minx) { minx = xc; }\n    if (xc > maxx) { maxx = xc; }\n\n    t = computeQuadraticFirstDerivativeRoot(xa, xb, xc);\n\n    if (t >= 0 && t <= 1) {\n        x = computeQuadraticBaseValue(t, xa, xb, xc);\n        // y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n        if (x < minx) { minx = x; }\n        if (x > maxx) { maxx = x; }\n    }\n\n    // Y\n    if (ya < miny) { miny = ya; }\n    if (ya > maxy) { maxy = ya; }\n    if (yc < miny) { miny = yc; }\n    if (yc > maxy) { maxy = yc; }\n\n    t = computeQuadraticFirstDerivativeRoot(ya, yb, yc);\n\n    if (t >= 0 && t <=1 ) {\n        // x = computeQuadraticBaseValue(t, xa, xb, xc);\n        y = computeQuadraticBaseValue(t, ya, yb, yc);\n\n        if (y < miny) { miny = y; }\n        if (y > maxy) { maxy = y ; }\n\n    }\n\n    return {\n        minx: minx,\n        miny: miny,\n        maxx: maxx,\n        maxy: maxy\n    };\n\n};\n\n// compute the value for the quadratic bezier function at time=t\nfunction computeQuadraticBaseValue(t, a, b, c) {\n\n    var mt = 1 - t;\n\n    return mt * mt * a + 2 * mt * t * b + t * t * c;\n\n}\n\n// compute the value for the first derivative of the quadratic bezier function at time=t\nfunction computeQuadraticFirstDerivativeRoot(a, b, c) {\n\n    var t = -1,\n        denominator = a - 2 * b + c;\n\n    if (denominator !== 0) {\n        t = (a - b) / denominator;\n    }\n\n    return t;\n\n}\n\n/**\n * Convert path array to string.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {String} output path string\n */\nexports.js2path = function(path, data, params) {\n\n    path.pathJS = data;\n\n    if (params.collapseRepeated) {\n        data = collapseRepeated(data);\n    }\n\n    path.attr('d').value = data.reduce(function(pathString, item) {\n        return pathString += item.instruction + (item.data ? cleanupOutData(item.data, params) : '');\n    }, '');\n\n};\n\n/**\n * Collapse repeated instructions data\n *\n * @param {Array} path input path data\n * @return {Array} output path data\n */\nfunction collapseRepeated(data) {\n\n    var prev,\n        prevIndex;\n\n    // copy an array and modifieds item to keep original data untouched\n    data = data.reduce(function(newPath, item) {\n        if (\n            prev && item.data &&\n            item.instruction == prev.instruction\n        ) {\n            // concat previous data with current\n            if (item.instruction != 'M') {\n                prev = newPath[prevIndex] = {\n                    instruction: prev.instruction,\n                    data: prev.data.concat(item.data),\n                    coords: item.coords,\n                    base: prev.base\n                };\n            } else {\n                prev.data = item.data;\n                prev.coords = item.coords;\n            }\n        } else {\n            newPath.push(item);\n            prev = item;\n            prevIndex = newPath.length - 1;\n        }\n\n        return newPath;\n    }, []);\n\n    return data;\n\n}\n\nfunction set(dest, source) {\n    dest[0] = source[source.length - 2];\n    dest[1] = source[source.length - 1];\n    return dest;\n}\n\n/**\n * Checks if two paths have an intersection by checking convex hulls\n * collision using Gilbert-Johnson-Keerthi distance algorithm\n * http://entropyinteractive.com/2011/04/gjk-algorithm/\n *\n * @param {Array} path1 JS path representation\n * @param {Array} path2 JS path representation\n * @return {Boolean}\n */\nexports.intersects = function(path1, path2) {\n    if (path1.length < 3 || path2.length < 3) return false; // nothing to fill\n\n    // Collect points of every subpath.\n    var points1 = relative2absolute(path1).reduce(gatherPoints, []),\n        points2 = relative2absolute(path2).reduce(gatherPoints, []);\n\n    // Axis-aligned bounding box check.\n    if (points1.maxX <= points2.minX || points2.maxX <= points1.minX ||\n        points1.maxY <= points2.minY || points2.maxY <= points1.minY ||\n        points1.every(function (set1) {\n            return points2.every(function (set2) {\n                return set1[set1.maxX][0] <= set2[set2.minX][0] ||\n                    set2[set2.maxX][0] <= set1[set1.minX][0] ||\n                    set1[set1.maxY][1] <= set2[set2.minY][1] ||\n                    set2[set2.maxY][1] <= set1[set1.minY][1];\n            });\n        })\n    ) return false;\n\n    // Get a convex hull from points of each subpath. Has the most complexity O(n·log n).\n    var hullNest1 = points1.map(convexHull),\n        hullNest2 = points2.map(convexHull);\n\n    // Check intersection of every subpath of the first path with every subpath of the second.\n    return hullNest1.some(function(hull1) {\n        if (hull1.length < 3) return false;\n\n        return hullNest2.some(function(hull2) {\n            if (hull2.length < 3) return false;\n\n            var simplex = [getSupport(hull1, hull2, [1, 0])], // create the initial simplex\n                direction = minus(simplex[0]); // set the direction to point towards the origin\n\n            var iterations = 1e4; // infinite loop protection, 10 000 iterations is more than enough\n            while (true) {\n                if (iterations-- == 0) {\n                    console.error('Error: infinite loop while processing mergePaths plugin.');\n                    return true; // true is the safe value that means “do nothing with paths”\n                }\n                // add a new point\n                simplex.push(getSupport(hull1, hull2, direction));\n                // see if the new point was on the correct side of the origin\n                if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;\n                // process the simplex\n                if (processSimplex(simplex, direction)) return true;\n            }\n        });\n    });\n\n    function getSupport(a, b, direction) {\n        return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));\n    }\n\n    // Computes farthest polygon point in particular direction.\n    // Thanks to knowledge of min/max x and y coordinates we can choose a quadrant to search in.\n    // Since we're working on convex hull, the dot product is increasing until we find the farthest point.\n    function supportPoint(polygon, direction) {\n        var index = direction[1] >= 0 ?\n                direction[0] < 0 ? polygon.maxY : polygon.maxX :\n                direction[0] < 0 ? polygon.minX : polygon.minY,\n            max = -Infinity,\n            value;\n        while ((value = dot(polygon[index], direction)) > max) {\n            max = value;\n            index = ++index % polygon.length;\n        }\n        return polygon[(index || polygon.length) - 1];\n    }\n};\n\nfunction processSimplex(simplex, direction) {\n    /* jshint -W004 */\n\n    // we only need to handle to 1-simplex and 2-simplex\n    if (simplex.length == 2) { // 1-simplex\n        var a = simplex[1],\n            b = simplex[0],\n            AO = minus(simplex[1]),\n            AB = sub(b, a);\n        // AO is in the same direction as AB\n        if (dot(AO, AB) > 0) {\n            // get the vector perpendicular to AB facing O\n            set(direction, orth(AB, a));\n        } else {\n            set(direction, AO);\n            // only A remains in the simplex\n            simplex.shift();\n        }\n    } else { // 2-simplex\n        var a = simplex[2], // [a, b, c] = simplex\n            b = simplex[1],\n            c = simplex[0],\n            AB = sub(b, a),\n            AC = sub(c, a),\n            AO = minus(a),\n            ACB = orth(AB, AC), // the vector perpendicular to AB facing away from C\n            ABC = orth(AC, AB); // the vector perpendicular to AC facing away from B\n\n        if (dot(ACB, AO) > 0) {\n            if (dot(AB, AO) > 0) { // region 4\n                set(direction, ACB);\n                simplex.shift(); // simplex = [b, a]\n            } else { // region 5\n                set(direction, AO);\n                simplex.splice(0, 2); // simplex = [a]\n            }\n        } else if (dot(ABC, AO) > 0) {\n            if (dot(AC, AO) > 0) { // region 6\n                set(direction, ABC);\n                simplex.splice(1, 1); // simplex = [c, a]\n            } else { // region 5 (again)\n                set(direction, AO);\n                simplex.splice(0, 2); // simplex = [a]\n            }\n        } else // region 7\n            return true;\n    }\n    return false;\n}\n\nfunction minus(v) {\n    return [-v[0], -v[1]];\n}\n\nfunction sub(v1, v2) {\n    return [v1[0] - v2[0], v1[1] - v2[1]];\n}\n\nfunction dot(v1, v2) {\n    return v1[0] * v2[0] + v1[1] * v2[1];\n}\n\nfunction orth(v, from) {\n    var o = [-v[1], v[0]];\n    return dot(o, minus(from)) < 0 ? minus(o) : o;\n}\n\nfunction gatherPoints(points, item, index, path) {\n\n    var subPath = points.length && points[points.length - 1],\n        prev = index && path[index - 1],\n        basePoint = subPath.length && subPath[subPath.length - 1],\n        data = item.data,\n        ctrlPoint = basePoint;\n\n    switch (item.instruction) {\n        case 'M':\n            points.push(subPath = []);\n            break;\n        case 'H':\n            addPoint(subPath, [data[0], basePoint[1]]);\n            break;\n        case 'V':\n            addPoint(subPath, [basePoint[0], data[0]]);\n            break;\n        case 'Q':\n            addPoint(subPath, data.slice(0, 2));\n            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]]; // Save control point for shorthand\n            break;\n        case 'T':\n            if (prev.instruction == 'Q' && prev.instruction == 'T') {\n                ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n                addPoint(subPath, ctrlPoint);\n                prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];\n            }\n            break;\n        case 'C':\n            // Approximate quibic Bezier curve with middle points between control points\n            addPoint(subPath, [.5 * (basePoint[0] + data[0]), .5 * (basePoint[1] + data[1])]);\n            addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n            addPoint(subPath, [.5 * (data[2] + data[4]), .5 * (data[3] + data[5])]);\n            prevCtrlPoint = [data[4] - data[2], data[5] - data[3]]; // Save control point for shorthand\n            break;\n        case 'S':\n            if (prev.instruction == 'C' && prev.instruction == 'S') {\n                addPoint(subPath, [basePoint[0] + .5 * prevCtrlPoint[0], basePoint[1] + .5 * prevCtrlPoint[1]]);\n                ctrlPoint = [basePoint[0] + prevCtrlPoint[0], basePoint[1] + prevCtrlPoint[1]];\n            }\n            addPoint(subPath, [.5 * (ctrlPoint[0] + data[0]), .5 * (ctrlPoint[1]+ data[1])]);\n            addPoint(subPath, [.5 * (data[0] + data[2]), .5 * (data[1] + data[3])]);\n            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];\n            break;\n        case 'A':\n            // Convert the arc to bezier curves and use the same approximation\n            var curves = a2c.apply(0, basePoint.concat(data));\n            for (var cData; (cData = curves.splice(0,6).map(toAbsolute)).length;) {\n                addPoint(subPath, [.5 * (basePoint[0] + cData[0]), .5 * (basePoint[1] + cData[1])]);\n                addPoint(subPath, [.5 * (cData[0] + cData[2]), .5 * (cData[1] + cData[3])]);\n                addPoint(subPath, [.5 * (cData[2] + cData[4]), .5 * (cData[3] + cData[5])]);\n                if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));\n            }\n            break;\n    }\n    // Save final command coordinates\n    if (data && data.length >= 2) addPoint(subPath, data.slice(-2));\n    return points;\n\n    function toAbsolute(n, i) { return n + basePoint[i % 2] }\n\n    // Writes data about the extreme points on each axle\n    function addPoint(path, point) {\n        if (!path.length || point[1] > path[path.maxY][1]) {\n            path.maxY = path.length;\n            points.maxY = points.length ? Math.max(point[1], points.maxY) : point[1];\n        }\n        if (!path.length || point[0] > path[path.maxX][0]) {\n            path.maxX = path.length;\n            points.maxX = points.length ? Math.max(point[0], points.maxX) : point[0];\n        }\n        if (!path.length || point[1] < path[path.minY][1]) {\n            path.minY = path.length;\n            points.minY = points.length ? Math.min(point[1], points.minY) : point[1];\n        }\n        if (!path.length || point[0] < path[path.minX][0]) {\n            path.minX = path.length;\n            points.minX = points.length ? Math.min(point[0], points.minX) : point[0];\n        }\n        path.push(point);\n    }\n}\n\n/**\n * Forms a convex hull from set of points of every subpath using monotone chain convex hull algorithm.\n * http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain\n *\n * @param points An array of [X, Y] coordinates\n */\nfunction convexHull(points) {\n    /* jshint -W004 */\n\n    points.sort(function(a, b) {\n        return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];\n    });\n\n    var lower = [],\n        minY = 0,\n        bottom = 0;\n    for (var i = 0; i < points.length; i++) {\n        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points[i]) <= 0) {\n            lower.pop();\n        }\n        if (points[i][1] < points[minY][1]) {\n            minY = i;\n            bottom = lower.length;\n        }\n        lower.push(points[i]);\n    }\n\n    var upper = [],\n        maxY = points.length - 1,\n        top = 0;\n    for (var i = points.length; i--;) {\n        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points[i]) <= 0) {\n            upper.pop();\n        }\n        if (points[i][1] > points[maxY][1]) {\n            maxY = i;\n            top = upper.length;\n        }\n        upper.push(points[i]);\n    }\n\n    // last points are equal to starting points of the other part\n    upper.pop();\n    lower.pop();\n\n    var hull = lower.concat(upper);\n\n    hull.minX = 0; // by sorting\n    hull.maxX = lower.length;\n    hull.minY = bottom;\n    hull.maxY = (lower.length + top) % hull.length;\n\n    return hull;\n}\n\nfunction cross(o, a, b) {\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n}\n\n/* Based on code from Snap.svg (Apache 2 license). http://snapsvg.io/\n * Thanks to Dmitry Baranovskiy for his great work!\n */\n\n// jshint ignore: start\nfunction a2c(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {\n    // for more information of where this Math came from visit:\n    // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n    var _120 = Math.PI * 120 / 180,\n        rad = Math.PI / 180 * (+angle || 0),\n        res = [],\n        rotateX = function(x, y, rad) { return x * Math.cos(rad) - y * Math.sin(rad) },\n        rotateY = function(x, y, rad) { return x * Math.sin(rad) + y * Math.cos(rad) };\n    if (!recursive) {\n        x1 = rotateX(x1, y1, -rad);\n        y1 = rotateY(x1, y1, -rad);\n        x2 = rotateX(x2, y2, -rad);\n        y2 = rotateY(x2, y2, -rad);\n        var x = (x1 - x2) / 2,\n            y = (y1 - y2) / 2;\n        var h = (x * x) / (rx * rx) + (y * y) / (ry * ry);\n        if (h > 1) {\n            h = Math.sqrt(h);\n            rx = h * rx;\n            ry = h * ry;\n        }\n        var rx2 = rx * rx,\n            ry2 = ry * ry,\n            k = (large_arc_flag == sweep_flag ? -1 : 1) *\n                Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x))),\n            cx = k * rx * y / ry + (x1 + x2) / 2,\n            cy = k * -ry * x / rx + (y1 + y2) / 2,\n            f1 = Math.asin(((y1 - cy) / ry).toFixed(9)),\n            f2 = Math.asin(((y2 - cy) / ry).toFixed(9));\n\n        f1 = x1 < cx ? Math.PI - f1 : f1;\n        f2 = x2 < cx ? Math.PI - f2 : f2;\n        f1 < 0 && (f1 = Math.PI * 2 + f1);\n        f2 < 0 && (f2 = Math.PI * 2 + f2);\n        if (sweep_flag && f1 > f2) {\n            f1 = f1 - Math.PI * 2;\n        }\n        if (!sweep_flag && f2 > f1) {\n            f2 = f2 - Math.PI * 2;\n        }\n    } else {\n        f1 = recursive[0];\n        f2 = recursive[1];\n        cx = recursive[2];\n        cy = recursive[3];\n    }\n    var df = f2 - f1;\n    if (Math.abs(df) > _120) {\n        var f2old = f2,\n            x2old = x2,\n            y2old = y2;\n        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);\n        x2 = cx + rx * Math.cos(f2);\n        y2 = cy + ry * Math.sin(f2);\n        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);\n    }\n    df = f2 - f1;\n    var c1 = Math.cos(f1),\n        s1 = Math.sin(f1),\n        c2 = Math.cos(f2),\n        s2 = Math.sin(f2),\n        t = Math.tan(df / 4),\n        hx = 4 / 3 * rx * t,\n        hy = 4 / 3 * ry * t,\n        m = [\n            - hx * s1, hy * c1,\n            x2 + hx * s2 - x1, y2 - hy * c2 - y1,\n            x2 - x1, y2 - y1\n        ];\n    if (recursive) {\n        return m.concat(res);\n    } else {\n        res = m.concat(res);\n        var newres = [];\n        for (var i = 0, n = res.length; i < n; i++) {\n            newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);\n        }\n        return newres;\n    }\n}\n// jshint ignore: end\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}