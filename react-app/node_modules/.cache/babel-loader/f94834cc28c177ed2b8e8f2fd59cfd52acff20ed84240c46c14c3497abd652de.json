{"ast":null,"code":"'use strict';\n\nexports.type = 'perItem';\nexports.active = true;\nexports.description = 'optimizes path data: writes in shorter form, applies transformations';\nexports.params = {\n  applyTransforms: true,\n  applyTransformsStroked: true,\n  straightCurves: true,\n  lineShorthands: true,\n  curveSmoothShorthands: true,\n  floatPrecision: 3,\n  transformPrecision: 5,\n  removeUseless: true,\n  collapseRepeated: true,\n  utilizeAbsolute: true,\n  leadingZero: true,\n  negativeExtraSpace: true\n};\nvar pathElems = require('./_collections.js').pathElems,\n  path2js = require('./_path.js').path2js,\n  js2path = require('./_path.js').js2path,\n  applyTransforms = require('./_path.js').applyTransforms,\n  cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n  precision,\n  error,\n  hasMarkerMid;\n\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see http://www.w3.org/TR/SVG/paths.html#PathData\n *\n * @param {Object} item current iteration item\n * @param {Object} params plugin params\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\nexports.fn = function (item, params) {\n  if (item.isElem(pathElems) && item.hasAttr('d')) {\n    precision = params.floatPrecision;\n    error = precision !== false ? +Math.pow(.1, precision).toFixed(precision) : 1e-2;\n    hasMarkerMid = item.hasAttr('marker-mid');\n    var data = path2js(item);\n\n    // TODO: get rid of functions returns\n    if (data.length) {\n      convertToRelative(data);\n      if (params.applyTransforms) {\n        data = applyTransforms(item, data, params);\n      }\n      data = filters(data, params);\n      if (params.utilizeAbsolute) {\n        data = convertToMixed(data, params);\n      }\n      js2path(item, data, params);\n    }\n  }\n};\n\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\nfunction convertToRelative(path) {\n  var point = [0, 0],\n    subpathPoint = [0, 0],\n    baseItem;\n  path.forEach(function (item, index) {\n    var instruction = item.instruction,\n      data = item.data;\n\n    // data !== !z\n    if (data) {\n      // already relative\n      // recalculate current point\n      if ('mcslqta'.indexOf(instruction) > -1) {\n        point[0] += data[data.length - 2];\n        point[1] += data[data.length - 1];\n        if (instruction === 'm') {\n          subpathPoint[0] = point[0];\n          subpathPoint[1] = point[1];\n          baseItem = item;\n        }\n      } else if (instruction === 'h') {\n        point[0] += data[0];\n      } else if (instruction === 'v') {\n        point[1] += data[0];\n      }\n\n      // convert absolute path data coordinates to relative\n      // if \"M\" was not transformed from \"m\"\n      // M → m\n      if (instruction === 'M') {\n        if (index > 0) instruction = 'm';\n        data[0] -= point[0];\n        data[1] -= point[1];\n        subpathPoint[0] = point[0] += data[0];\n        subpathPoint[1] = point[1] += data[1];\n        baseItem = item;\n      }\n\n      // L → l\n      // T → t\n      else if ('LT'.indexOf(instruction) > -1) {\n        instruction = instruction.toLowerCase();\n\n        // x y\n        // 0 1\n        data[0] -= point[0];\n        data[1] -= point[1];\n        point[0] += data[0];\n        point[1] += data[1];\n\n        // C → c\n      } else if (instruction === 'C') {\n        instruction = 'c';\n\n        // x1 y1 x2 y2 x y\n        // 0  1  2  3  4 5\n        data[0] -= point[0];\n        data[1] -= point[1];\n        data[2] -= point[0];\n        data[3] -= point[1];\n        data[4] -= point[0];\n        data[5] -= point[1];\n        point[0] += data[4];\n        point[1] += data[5];\n\n        // S → s\n        // Q → q\n      } else if ('SQ'.indexOf(instruction) > -1) {\n        instruction = instruction.toLowerCase();\n\n        // x1 y1 x y\n        // 0  1  2 3\n        data[0] -= point[0];\n        data[1] -= point[1];\n        data[2] -= point[0];\n        data[3] -= point[1];\n        point[0] += data[2];\n        point[1] += data[3];\n\n        // A → a\n      } else if (instruction === 'A') {\n        instruction = 'a';\n\n        // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n        // 0  1  2               3              4          5 6\n        data[5] -= point[0];\n        data[6] -= point[1];\n        point[0] += data[5];\n        point[1] += data[6];\n\n        // H → h\n      } else if (instruction === 'H') {\n        instruction = 'h';\n        data[0] -= point[0];\n        point[0] += data[0];\n\n        // V → v\n      } else if (instruction === 'V') {\n        instruction = 'v';\n        data[0] -= point[1];\n        point[1] += data[0];\n      }\n      item.instruction = instruction;\n      item.data = data;\n\n      // store absolute coordinates for later use\n      item.coords = point.slice(-2);\n    }\n\n    // !data === z, reset current point\n    else if (instruction == 'z') {\n      if (baseItem) {\n        item.coords = baseItem.coords;\n      }\n      point[0] = subpathPoint[0];\n      point[1] = subpathPoint[1];\n    }\n    item.base = index > 0 ? path[index - 1].coords : [0, 0];\n  });\n  return path;\n}\n\n/**\n * Main filters loop.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\nfunction filters(path, params) {\n  var relSubpoint = [0, 0],\n    pathBase = [0, 0],\n    prev = {};\n  path = path.filter(function (item, index) {\n    var instruction = item.instruction,\n      data = item.data;\n    if (data) {\n      var sdata;\n      if (instruction === 's') {\n        sdata = [0, 0].concat(data);\n        if ('cs'.indexOf(prev.instruction) > -1) {\n          var pdata = prev.data,\n            n = pdata.length;\n\n          // (-x, -y) of the prev tangent point relative to the current point\n          sdata[0] = pdata[n - 2] - pdata[n - 4];\n          sdata[1] = pdata[n - 1] - pdata[n - 3];\n        }\n      }\n\n      // Rounding relative coordinates, taking in account accummulating error\n      // to get closer to absolute coordinates. Sum of rounded value remains same:\n      // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n      if (precision !== false) {\n        if ('mltqsc'.indexOf(instruction) > -1) {\n          for (var i = data.length; i--;) {\n            data[i] += item.base[i % 2] - relSubpoint[i % 2];\n          }\n        } else if (instruction == 'h') {\n          data[0] += item.base[0] - relSubpoint[0];\n        } else if (instruction == 'v') {\n          data[0] += item.base[1] - relSubpoint[1];\n        } else if (instruction == 'a') {\n          data[5] += item.base[0] - relSubpoint[0];\n          data[6] += item.base[1] - relSubpoint[1];\n        }\n        roundData(data);\n        if (instruction == 'h') relSubpoint[0] += data[0];else if (instruction == 'v') relSubpoint[1] += data[0];else {\n          relSubpoint[0] += data[data.length - 2];\n          relSubpoint[1] += data[data.length - 1];\n        }\n        roundData(relSubpoint);\n        if (instruction.toLowerCase() == 'm') {\n          pathBase[0] = relSubpoint[0];\n          pathBase[1] = relSubpoint[1];\n        }\n      }\n\n      // convert straight curves into lines segments\n      if (params.straightCurves) {\n        // c\n        if (instruction === 'c' && isCurveStraightLine([0, data[0], data[2], data[4]], [0, data[1], data[3], data[5]])) {\n          instruction = 'l';\n          data = data.slice(-2);\n        }\n\n        // s\n        else if (instruction === 's' && isCurveStraightLine([0, sdata[0], sdata[2], sdata[4]], [0, sdata[1], sdata[3], sdata[5]])) {\n          instruction = 'l';\n          data = data.slice(-2);\n        }\n\n        // q\n        else if (instruction === 'q' && isCurveStraightLine([0, data[0], data[2]], [0, data[1], data[3]])) {\n          // save the original one for the future potential q + t conversion\n          item.original = {\n            instruction: instruction,\n            data: data\n          };\n          instruction = 'l';\n          data = data.slice(-2);\n        } else if (instruction === 't') {\n          // q (original) + t\n          if (prev.original && prev.original.instruction === 'q') {\n            if (isCurveStraightLine([prev.original.data[0], prev.original.data[2], data[0]], [prev.original.data[1], prev.original.data[3], data[1]])) {\n              instruction = 'l';\n              data = data.slice(-2);\n            } else {\n              prev.instruction = 'q';\n              prev.data = prev.original.data;\n            }\n          }\n\n          // [^qt] + t\n          else if ('qt'.indexOf(prev.instruction) < 0) {\n            instruction = 'l';\n            data = data.slice(-2);\n          }\n        }\n\n        // a\n        else if (instruction === 'a' && (data[0] === 0 || data[1] === 0)) {\n          instruction = 'l';\n          data = data.slice(-2);\n        }\n      }\n\n      // horizontal and vertical line shorthands\n      // l 50 0 → h 50\n      // l 0 50 → v 50\n      if (params.lineShorthands && instruction === 'l') {\n        if (data[1] === 0) {\n          instruction = 'h';\n          data.pop();\n        } else if (data[0] === 0) {\n          instruction = 'v';\n          data.shift();\n        }\n      }\n\n      // collapse repeated commands\n      // h 20 h 30 -> h 50\n      if (params.collapseRepeated && !hasMarkerMid && 'mhv'.indexOf(instruction) > -1 && prev.instruction && instruction == prev.instruction.toLowerCase() && (instruction != 'h' && instruction != 'v' || prev.data[0] >= 0 == item.data[0] >= 0)) {\n        prev.data[0] += data[0];\n        if (instruction != 'h' && instruction != 'v') {\n          prev.data[1] += data[1];\n        }\n        prev.coords = item.coords;\n        if (prev.original) prev.original = null;\n        path[index] = prev;\n        return false;\n      }\n\n      // convert curves into smooth shorthands\n      if (params.curveSmoothShorthands && prev.instruction) {\n        // curveto\n        if (instruction === 'c') {\n          // c + c → c + s\n          if (prev.instruction === 'c' && data[0] === -(prev.data[2] - prev.data[4]) && data[1] === -(prev.data[3] - prev.data[5])) {\n            instruction = 's';\n            data = data.slice(2);\n          }\n\n          // s + c → s + s\n          else if (prev.instruction === 's' && data[0] === -(prev.data[0] - prev.data[2]) && data[1] === -(prev.data[1] - prev.data[3])) {\n            instruction = 's';\n            data = data.slice(2);\n          }\n\n          // [^cs] + c → [^cs] + s\n          else if ('cs'.indexOf(prev.instruction) === -1 && data[0] === 0 && data[1] === 0) {\n            instruction = 's';\n            data = data.slice(2);\n          }\n        }\n\n        // quadratic Bézier curveto\n        else if (instruction === 'q') {\n          // q + q → q + t\n          if (prev.instruction === 'q' && data[0] === prev.data[2] - prev.data[0] && data[1] === prev.data[3] - prev.data[1]) {\n            instruction = 't';\n            data = data.slice(2);\n          }\n\n          // t + q → t + t\n          else if (prev.instruction === 't' && data[2] === prev.data[0] && data[3] === prev.data[1]) {\n            instruction = 't';\n            data = data.slice(2);\n          }\n        }\n      }\n\n      // remove useless non-first path segments\n      if (params.removeUseless) {\n        // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n        if ('lhvqtcs'.indexOf(instruction) > -1 && data.every(function (i) {\n          return i === 0;\n        })) {\n          path[index] = prev;\n          return false;\n        }\n\n        // a 25,25 -30 0,1 0,0\n        if (instruction === 'a' && data[5] === 0 && data[6] === 0) {\n          path[index] = prev;\n          return false;\n        }\n      }\n      item.instruction = instruction;\n      item.data = data;\n      prev = item;\n    } else {\n      // z resets coordinates\n      relSubpoint[0] = pathBase[0];\n      relSubpoint[1] = pathBase[1];\n      if (prev.instruction == 'z') return false;\n      prev = item;\n    }\n    return true;\n  });\n  return path;\n}\n\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\nfunction convertToMixed(path, params) {\n  var prev = path[0];\n  path = path.filter(function (item, index) {\n    if (index == 0) return true;\n    if (!item.data) {\n      prev = item;\n      return true;\n    }\n    var instruction = item.instruction,\n      data = item.data,\n      adata = data && data.slice(0);\n    if ('mltqsc'.indexOf(instruction) > -1) {\n      for (var i = adata.length; i--;) {\n        adata[i] += item.base[i % 2];\n      }\n    } else if (instruction == 'h') {\n      adata[0] += item.base[0];\n    } else if (instruction == 'v') {\n      adata[0] += item.base[1];\n    } else if (instruction == 'a') {\n      adata[5] += item.base[0];\n      adata[6] += item.base[1];\n    }\n    roundData(adata);\n    var absoluteDataStr = cleanupOutData(adata, params),\n      relativeDataStr = cleanupOutData(data, params);\n\n    // Convert to absolute coordinates if it's shorter.\n    // v-20 -> V0\n    // Don't convert if it fits following previous instruction.\n    // l20 30-10-50 instead of l20 30L20 30\n    if (absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && instruction == prev.instruction && prev.instruction.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 || 0 < data[0] && data[0] < 1 && prev.data[prev.data.length - 1] % 1))) {\n      item.instruction = instruction.toUpperCase();\n      item.data = adata;\n    }\n    prev = item;\n    return true;\n  });\n  return path;\n}\n\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.349 to 2.35.\n *\n * @param {Array} data input data array\n * @param {Number} fixed number of decimals\n * @return {Array} output data array\n */\nfunction roundData(data) {\n  function round(data) {\n    for (var i = data.length; i--;) {\n      data[i] = +data[i].toFixed(precision);\n    }\n    return data;\n  }\n  function strongRound(data) {\n    for (var i = data.length; i--;) {\n      var rounded = +data[i].toFixed(precision - 1);\n      data[i] = +Math.abs(rounded - data[i]).toFixed(precision) > error ? +data[i].toFixed(precision) : rounded;\n    }\n    return data;\n  }\n  roundData = precision > 0 ? strongRound : round; // jshint ignore: line\n\n  return roundData(data);\n}\n\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @param {Array} xs array of curve points x-coordinates\n * @param {Array} ys array of curve points y-coordinates\n * @return {Boolean}\n */\n\nfunction isCurveStraightLine(xs, ys) {\n  // Get line equation a·x + b·y + c = 0 coefficients a, b, c by start and end points.\n  var i = xs.length - 1,\n    a = ys[0] - ys[i],\n    // y1 − y2\n    b = xs[i] - xs[0],\n    // x2 − x1\n    c = xs[0] * ys[i] - xs[i] * ys[0],\n    // x1·y2 − x2·y1\n    d = 1 / (a * a + b * b); // same part for all points\n\n  if (!isFinite(d)) return false; // curve that ends at start point isn't the case\n\n  // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n  while (--i) {\n    if (Math.sqrt(Math.pow(c - a * xs[i] - b * ys[i], 2) * d) > error) return false;\n  }\n  return true;\n}","map":{"version":3,"names":["exports","type","active","description","params","applyTransforms","applyTransformsStroked","straightCurves","lineShorthands","curveSmoothShorthands","floatPrecision","transformPrecision","removeUseless","collapseRepeated","utilizeAbsolute","leadingZero","negativeExtraSpace","pathElems","require","path2js","js2path","cleanupOutData","precision","error","hasMarkerMid","fn","item","isElem","hasAttr","Math","pow","toFixed","data","length","convertToRelative","filters","convertToMixed","path","point","subpathPoint","baseItem","forEach","index","instruction","indexOf","toLowerCase","coords","slice","base","relSubpoint","pathBase","prev","filter","sdata","concat","pdata","n","i","roundData","isCurveStraightLine","original","pop","shift","every","adata","absoluteDataStr","relativeDataStr","charCodeAt","toUpperCase","round","strongRound","rounded","abs","xs","ys","a","b","c","d","isFinite","sqrt"],"sources":["C:/Users/SashinTulsiram/Documents/Software/react-frontend-bulma/node_modules/svgo/plugins/convertPathData.js"],"sourcesContent":["'use strict';\n\nexports.type = 'perItem';\n\nexports.active = true;\n\nexports.description = 'optimizes path data: writes in shorter form, applies transformations';\n\nexports.params = {\n    applyTransforms: true,\n    applyTransformsStroked: true,\n    straightCurves: true,\n    lineShorthands: true,\n    curveSmoothShorthands: true,\n    floatPrecision: 3,\n    transformPrecision: 5,\n    removeUseless: true,\n    collapseRepeated: true,\n    utilizeAbsolute: true,\n    leadingZero: true,\n    negativeExtraSpace: true\n};\n\nvar pathElems = require('./_collections.js').pathElems,\n    path2js = require('./_path.js').path2js,\n    js2path = require('./_path.js').js2path,\n    applyTransforms = require('./_path.js').applyTransforms,\n    cleanupOutData = require('../lib/svgo/tools').cleanupOutData,\n    precision,\n    error,\n    hasMarkerMid;\n\n/**\n * Convert absolute Path to relative,\n * collapse repeated instructions,\n * detect and convert Lineto shorthands,\n * remove useless instructions like \"l0,0\",\n * trim useless delimiters and leading zeros,\n * decrease accuracy of floating-point numbers.\n *\n * @see http://www.w3.org/TR/SVG/paths.html#PathData\n *\n * @param {Object} item current iteration item\n * @param {Object} params plugin params\n * @return {Boolean} if false, item will be filtered out\n *\n * @author Kir Belevich\n */\nexports.fn = function(item, params) {\n\n    if (item.isElem(pathElems) && item.hasAttr('d')) {\n\n        precision = params.floatPrecision;\n        error = precision !== false ? +Math.pow(.1, precision).toFixed(precision) : 1e-2;\n        hasMarkerMid = item.hasAttr('marker-mid');\n\n        var data = path2js(item);\n\n        // TODO: get rid of functions returns\n        if (data.length) {\n            convertToRelative(data);\n\n            if (params.applyTransforms) {\n                data = applyTransforms(item, data, params);\n            }\n\n            data = filters(data, params);\n\n            if (params.utilizeAbsolute) {\n                data = convertToMixed(data, params);\n            }\n\n            js2path(item, data, params);\n        }\n\n    }\n\n};\n\n/**\n * Convert absolute path data coordinates to relative.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\nfunction convertToRelative(path) {\n\n    var point = [0, 0],\n        subpathPoint = [0, 0],\n        baseItem;\n\n    path.forEach(function(item, index) {\n\n        var instruction = item.instruction,\n            data = item.data;\n\n        // data !== !z\n        if (data) {\n\n            // already relative\n            // recalculate current point\n            if ('mcslqta'.indexOf(instruction) > -1) {\n\n                point[0] += data[data.length - 2];\n                point[1] += data[data.length - 1];\n\n                if (instruction === 'm') {\n                    subpathPoint[0] = point[0];\n                    subpathPoint[1] = point[1];\n                    baseItem = item;\n                }\n\n            } else if (instruction === 'h') {\n\n                point[0] += data[0];\n\n            } else if (instruction === 'v') {\n\n                point[1] += data[0];\n\n            }\n\n            // convert absolute path data coordinates to relative\n            // if \"M\" was not transformed from \"m\"\n            // M → m\n            if (instruction === 'M') {\n\n                if (index > 0) instruction = 'm';\n\n                data[0] -= point[0];\n                data[1] -= point[1];\n\n                subpathPoint[0] = point[0] += data[0];\n                subpathPoint[1] = point[1] += data[1];\n\n                baseItem = item;\n\n            }\n\n            // L → l\n            // T → t\n            else if ('LT'.indexOf(instruction) > -1) {\n\n                instruction = instruction.toLowerCase();\n\n                // x y\n                // 0 1\n                data[0] -= point[0];\n                data[1] -= point[1];\n\n                point[0] += data[0];\n                point[1] += data[1];\n\n            // C → c\n            } else if (instruction === 'C') {\n\n                instruction = 'c';\n\n                // x1 y1 x2 y2 x y\n                // 0  1  2  3  4 5\n                data[0] -= point[0];\n                data[1] -= point[1];\n                data[2] -= point[0];\n                data[3] -= point[1];\n                data[4] -= point[0];\n                data[5] -= point[1];\n\n                point[0] += data[4];\n                point[1] += data[5];\n\n            // S → s\n            // Q → q\n            } else if ('SQ'.indexOf(instruction) > -1) {\n\n                instruction = instruction.toLowerCase();\n\n                // x1 y1 x y\n                // 0  1  2 3\n                data[0] -= point[0];\n                data[1] -= point[1];\n                data[2] -= point[0];\n                data[3] -= point[1];\n\n                point[0] += data[2];\n                point[1] += data[3];\n\n            // A → a\n            } else if (instruction === 'A') {\n\n                instruction = 'a';\n\n                // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n                // 0  1  2               3              4          5 6\n                data[5] -= point[0];\n                data[6] -= point[1];\n\n                point[0] += data[5];\n                point[1] += data[6];\n\n            // H → h\n            } else if (instruction === 'H') {\n\n                instruction = 'h';\n\n                data[0] -= point[0];\n\n                point[0] += data[0];\n\n            // V → v\n            } else if (instruction === 'V') {\n\n                instruction = 'v';\n\n                data[0] -= point[1];\n\n                point[1] += data[0];\n\n            }\n\n            item.instruction = instruction;\n            item.data = data;\n\n            // store absolute coordinates for later use\n            item.coords = point.slice(-2);\n\n        }\n\n        // !data === z, reset current point\n        else if (instruction == 'z') {\n            if (baseItem) {\n                item.coords = baseItem.coords;\n            }\n            point[0] = subpathPoint[0];\n            point[1] = subpathPoint[1];\n        }\n\n        item.base = index > 0 ? path[index - 1].coords : [0, 0];\n\n    });\n\n    return path;\n\n}\n\n/**\n * Main filters loop.\n *\n * @param {Array} path input path data\n * @param {Object} params plugin params\n * @return {Array} output path data\n */\nfunction filters(path, params) {\n\n    var relSubpoint = [0, 0],\n        pathBase = [0, 0],\n        prev = {};\n\n    path = path.filter(function(item, index) {\n\n        var instruction = item.instruction,\n            data = item.data;\n\n        if (data) {\n\n            var sdata;\n\n            if (instruction === 's') {\n                sdata = [0, 0].concat(data);\n\n                if ('cs'.indexOf(prev.instruction) > -1) {\n                    var pdata = prev.data,\n                        n = pdata.length;\n\n                    // (-x, -y) of the prev tangent point relative to the current point\n                    sdata[0] = pdata[n - 2] - pdata[n - 4];\n                    sdata[1] = pdata[n - 1] - pdata[n - 3];\n                }\n\n            }\n\n            // Rounding relative coordinates, taking in account accummulating error\n            // to get closer to absolute coordinates. Sum of rounded value remains same:\n            // l .25 3 .25 2 .25 3 .25 2 -> l .3 3 .2 2 .3 3 .2 2\n            if (precision !== false) {\n                if ('mltqsc'.indexOf(instruction) > -1) {\n                    for (var i = data.length; i--;) {\n                        data[i] += item.base[i % 2] - relSubpoint[i % 2];\n                    }\n                } else if (instruction == 'h') {\n                    data[0] += item.base[0] - relSubpoint[0];\n                } else if (instruction == 'v') {\n                    data[0] += item.base[1] - relSubpoint[1];\n                } else if (instruction == 'a') {\n                    data[5] += item.base[0] - relSubpoint[0];\n                    data[6] += item.base[1] - relSubpoint[1];\n                }\n                roundData(data);\n\n                if      (instruction == 'h') relSubpoint[0] += data[0];\n                else if (instruction == 'v') relSubpoint[1] += data[0];\n                else {\n                    relSubpoint[0] += data[data.length - 2];\n                    relSubpoint[1] += data[data.length - 1];\n                }\n                roundData(relSubpoint);\n\n                if (instruction.toLowerCase() == 'm') {\n                    pathBase[0] = relSubpoint[0];\n                    pathBase[1] = relSubpoint[1];\n                }\n            }\n\n            // convert straight curves into lines segments\n            if (params.straightCurves) {\n\n                // c\n                if (\n                    instruction === 'c' &&\n                    isCurveStraightLine(\n                        [ 0, data[0], data[2], data[4] ],\n                        [ 0, data[1], data[3], data[5] ]\n                    )\n                ) {\n                    instruction = 'l';\n                    data = data.slice(-2);\n                }\n\n                // s\n                else if (\n                    instruction === 's' &&\n                    isCurveStraightLine(\n                        [ 0, sdata[0], sdata[2], sdata[4] ],\n                        [ 0, sdata[1], sdata[3], sdata[5] ]\n                    )\n                ) {\n                    instruction = 'l';\n                    data = data.slice(-2);\n                }\n\n                // q\n                else if (\n                    instruction === 'q' &&\n                    isCurveStraightLine(\n                        [ 0, data[0], data[2] ],\n                        [ 0, data[1], data[3] ]\n                    )\n                ) {\n                    // save the original one for the future potential q + t conversion\n                    item.original = {\n                        instruction: instruction,\n                        data: data\n                    };\n\n                    instruction = 'l';\n                    data = data.slice(-2);\n                }\n\n                else if (instruction === 't') {\n\n                    // q (original) + t\n                    if (\n                        prev.original &&\n                        prev.original.instruction === 'q'\n                    ) {\n                        if (isCurveStraightLine(\n                            [ prev.original.data[0], prev.original.data[2], data[0] ],\n                            [ prev.original.data[1], prev.original.data[3], data[1] ]\n                        )) {\n                            instruction = 'l';\n                            data = data.slice(-2);\n                        } else {\n                            prev.instruction = 'q';\n                            prev.data = prev.original.data;\n                        }\n                    }\n\n                    // [^qt] + t\n                    else if ('qt'.indexOf(prev.instruction) < 0) {\n                        instruction = 'l';\n                        data = data.slice(-2);\n                    }\n\n                }\n\n                // a\n                else if (\n                    instruction === 'a' &&\n                    (data[0] === 0 || data[1] === 0)\n                ) {\n                    instruction = 'l';\n                    data = data.slice(-2);\n                }\n            }\n\n            // horizontal and vertical line shorthands\n            // l 50 0 → h 50\n            // l 0 50 → v 50\n            if (\n                params.lineShorthands &&\n                instruction === 'l'\n            ) {\n                if (data[1] === 0) {\n                    instruction = 'h';\n                    data.pop();\n                } else if (data[0] === 0) {\n                    instruction = 'v';\n                    data.shift();\n                }\n            }\n\n            // collapse repeated commands\n            // h 20 h 30 -> h 50\n            if (\n                params.collapseRepeated &&\n                !hasMarkerMid &&\n                ('mhv'.indexOf(instruction) > -1) &&\n                prev.instruction &&\n                instruction == prev.instruction.toLowerCase() &&\n                (\n                    (instruction != 'h' && instruction != 'v') ||\n                    (prev.data[0] >= 0) == (item.data[0] >= 0)\n            )) {\n                prev.data[0] += data[0];\n                if (instruction != 'h' && instruction != 'v') {\n                    prev.data[1] += data[1];\n                }\n                prev.coords = item.coords;\n                if (prev.original) prev.original = null;\n                path[index] = prev;\n                return false;\n            }\n\n            // convert curves into smooth shorthands\n            if (params.curveSmoothShorthands && prev.instruction) {\n\n                // curveto\n                if (instruction === 'c') {\n\n                    // c + c → c + s\n                    if (\n                        prev.instruction === 'c' &&\n                        data[0] === -(prev.data[2] - prev.data[4]) &&\n                        data[1] === -(prev.data[3] - prev.data[5])\n                    ) {\n                        instruction = 's';\n                        data = data.slice(2);\n                    }\n\n                    // s + c → s + s\n                    else if (\n                        prev.instruction === 's' &&\n                        data[0] === -(prev.data[0] - prev.data[2]) &&\n                        data[1] === -(prev.data[1] - prev.data[3])\n                    ) {\n                        instruction = 's';\n                        data = data.slice(2);\n                    }\n\n                    // [^cs] + c → [^cs] + s\n                    else if (\n                        'cs'.indexOf(prev.instruction) === -1 &&\n                        data[0] === 0 &&\n                        data[1] === 0\n                    ) {\n                        instruction = 's';\n                        data = data.slice(2);\n                    }\n\n                }\n\n                // quadratic Bézier curveto\n                else if (instruction === 'q') {\n\n                    // q + q → q + t\n                    if (\n                        prev.instruction === 'q' &&\n                        data[0] === (prev.data[2] - prev.data[0]) &&\n                        data[1] === (prev.data[3] - prev.data[1])\n                    ) {\n                        instruction = 't';\n                        data = data.slice(2);\n                    }\n\n                    // t + q → t + t\n                    else if (\n                        prev.instruction === 't' &&\n                        data[2] === prev.data[0] &&\n                        data[3] === prev.data[1]\n                    ) {\n                        instruction = 't';\n                        data = data.slice(2);\n                    }\n\n                }\n\n            }\n\n            // remove useless non-first path segments\n            if (params.removeUseless) {\n\n                // l 0,0 / h 0 / v 0 / q 0,0 0,0 / t 0,0 / c 0,0 0,0 0,0 / s 0,0 0,0\n                if (\n                    (\n                     'lhvqtcs'.indexOf(instruction) > -1\n                    ) &&\n                    data.every(function(i) { return i === 0; })\n                ) {\n                    path[index] = prev;\n                    return false;\n                }\n\n                // a 25,25 -30 0,1 0,0\n                if (\n                    instruction === 'a' &&\n                    data[5] === 0 &&\n                    data[6] === 0\n                ) {\n                    path[index] = prev;\n                    return false;\n                }\n\n            }\n\n            item.instruction = instruction;\n            item.data = data;\n\n            prev = item;\n\n        } else {\n\n            // z resets coordinates\n            relSubpoint[0] = pathBase[0];\n            relSubpoint[1] = pathBase[1];\n            if (prev.instruction == 'z') return false;\n            prev = item;\n\n        }\n\n        return true;\n\n    });\n\n    return path;\n\n}\n\n/**\n * Writes data in shortest form using absolute or relative coordinates.\n *\n * @param {Array} data input path data\n * @return {Boolean} output\n */\nfunction convertToMixed(path, params) {\n\n    var prev = path[0];\n\n    path = path.filter(function(item, index) {\n\n        if (index == 0) return true;\n        if (!item.data) {\n            prev = item;\n            return true;\n        }\n\n        var instruction = item.instruction,\n            data = item.data,\n            adata = data && data.slice(0);\n\n        if ('mltqsc'.indexOf(instruction) > -1) {\n            for (var i = adata.length; i--;) {\n                adata[i] += item.base[i % 2];\n            }\n        } else if (instruction == 'h') {\n                adata[0] += item.base[0];\n        } else if (instruction == 'v') {\n                adata[0] += item.base[1];\n        } else if (instruction == 'a') {\n                adata[5] += item.base[0];\n                adata[6] += item.base[1];\n        }\n\n        roundData(adata);\n\n        var absoluteDataStr = cleanupOutData(adata, params),\n            relativeDataStr = cleanupOutData(data, params);\n\n        // Convert to absolute coordinates if it's shorter.\n        // v-20 -> V0\n        // Don't convert if it fits following previous instruction.\n        // l20 30-10-50 instead of l20 30L20 30\n        if (\n            absoluteDataStr.length < relativeDataStr.length &&\n            !(\n                params.negativeExtraSpace &&\n                instruction == prev.instruction &&\n                prev.instruction.charCodeAt(0) > 96 &&\n                absoluteDataStr.length == relativeDataStr.length - 1 &&\n                (data[0] < 0 || 0 < data[0] && data[0] < 1 && prev.data[prev.data.length - 1] % 1)\n            )\n        ) {\n            item.instruction = instruction.toUpperCase();\n            item.data = adata;\n        }\n\n        prev = item;\n\n        return true;\n\n    });\n\n    return path;\n\n}\n\n/**\n * Decrease accuracy of floating-point numbers\n * in path data keeping a specified number of decimals.\n * Smart rounds values like 2.349 to 2.35.\n *\n * @param {Array} data input data array\n * @param {Number} fixed number of decimals\n * @return {Array} output data array\n */\nfunction roundData(data) {\n\n    function round(data) {\n        for (var i = data.length; i--;) {\n            data[i] = +data[i].toFixed(precision);\n        }\n        return data;\n    }\n\n    function strongRound(data) {\n        for (var i = data.length; i--;) {\n            var rounded = +data[i].toFixed(precision - 1);\n            data[i] = +Math.abs(rounded - data[i]).toFixed(precision) > error ?\n                +data[i].toFixed(precision) :\n                rounded;\n        }\n        return data;\n    }\n\n    roundData = precision > 0 ? strongRound : round; // jshint ignore: line\n\n    return roundData(data);\n\n}\n\n/**\n * Checks if a curve is a straight line by measuring distance\n * from middle points to the line formed by end points.\n *\n * @param {Array} xs array of curve points x-coordinates\n * @param {Array} ys array of curve points y-coordinates\n * @return {Boolean}\n */\n\nfunction isCurveStraightLine(xs, ys) {\n\n    // Get line equation a·x + b·y + c = 0 coefficients a, b, c by start and end points.\n    var i = xs.length - 1,\n        a = ys[0] - ys[i], // y1 − y2\n        b = xs[i] - xs[0], // x2 − x1\n        c = xs[0] * ys[i] - xs[i] * ys[0], // x1·y2 − x2·y1\n        d = 1 / (a * a + b * b); // same part for all points\n\n    if (!isFinite(d)) return false; // curve that ends at start point isn't the case\n\n    // Distance from point (x0, y0) to the line is sqrt((c − a·x0 − b·y0)² / (a² + b²))\n    while (--i) {\n        if (Math.sqrt(Math.pow(c - a * xs[i] - b * ys[i], 2) * d) > error)\n            return false;\n    }\n\n    return true;\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}