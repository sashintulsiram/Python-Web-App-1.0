{"ast":null,"code":"/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n  'use strict';\n\n  // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n  // Rhino, and plain browser loading.\n\n  /* istanbul ignore next */\n  if (typeof define === 'function' && define.amd) {\n    define(['exports'], factory);\n  } else if (typeof exports !== 'undefined') {\n    factory(exports);\n  } else {\n    factory(root.esprima = {});\n  }\n})(this, function (exports) {\n  'use strict';\n\n  var Token, TokenName, FnExprTokens, Syntax, PlaceHolders, Messages, Regex, source, strict, sourceType, index, lineNumber, lineStart, hasLineTerminator, lastIndex, lastLineNumber, lastLineStart, startIndex, startLineNumber, startLineStart, scanning, length, lookahead, state, extra, isBindingElement, isAssignmentTarget, firstCoverInitializedNameError;\n  Token = {\n    BooleanLiteral: 1,\n    EOF: 2,\n    Identifier: 3,\n    Keyword: 4,\n    NullLiteral: 5,\n    NumericLiteral: 6,\n    Punctuator: 7,\n    StringLiteral: 8,\n    RegularExpression: 9,\n    Template: 10\n  };\n  TokenName = {};\n  TokenName[Token.BooleanLiteral] = 'Boolean';\n  TokenName[Token.EOF] = '<end>';\n  TokenName[Token.Identifier] = 'Identifier';\n  TokenName[Token.Keyword] = 'Keyword';\n  TokenName[Token.NullLiteral] = 'Null';\n  TokenName[Token.NumericLiteral] = 'Numeric';\n  TokenName[Token.Punctuator] = 'Punctuator';\n  TokenName[Token.StringLiteral] = 'String';\n  TokenName[Token.RegularExpression] = 'RegularExpression';\n  TokenName[Token.Template] = 'Template';\n\n  // A function following one of those tokens is an expression.\n  FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new', 'return', 'case', 'delete', 'throw', 'void',\n  // assignment operators\n  '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=', '&=', '|=', '^=', ',',\n  // binary/unary operators\n  '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&', '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=', '<=', '<', '>', '!=', '!=='];\n  Syntax = {\n    AssignmentExpression: 'AssignmentExpression',\n    AssignmentPattern: 'AssignmentPattern',\n    ArrayExpression: 'ArrayExpression',\n    ArrayPattern: 'ArrayPattern',\n    ArrowFunctionExpression: 'ArrowFunctionExpression',\n    BlockStatement: 'BlockStatement',\n    BinaryExpression: 'BinaryExpression',\n    BreakStatement: 'BreakStatement',\n    CallExpression: 'CallExpression',\n    CatchClause: 'CatchClause',\n    ClassBody: 'ClassBody',\n    ClassDeclaration: 'ClassDeclaration',\n    ClassExpression: 'ClassExpression',\n    ConditionalExpression: 'ConditionalExpression',\n    ContinueStatement: 'ContinueStatement',\n    DoWhileStatement: 'DoWhileStatement',\n    DebuggerStatement: 'DebuggerStatement',\n    EmptyStatement: 'EmptyStatement',\n    ExportAllDeclaration: 'ExportAllDeclaration',\n    ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n    ExportNamedDeclaration: 'ExportNamedDeclaration',\n    ExportSpecifier: 'ExportSpecifier',\n    ExpressionStatement: 'ExpressionStatement',\n    ForStatement: 'ForStatement',\n    ForInStatement: 'ForInStatement',\n    FunctionDeclaration: 'FunctionDeclaration',\n    FunctionExpression: 'FunctionExpression',\n    Identifier: 'Identifier',\n    IfStatement: 'IfStatement',\n    ImportDeclaration: 'ImportDeclaration',\n    ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n    ImportSpecifier: 'ImportSpecifier',\n    Literal: 'Literal',\n    LabeledStatement: 'LabeledStatement',\n    LogicalExpression: 'LogicalExpression',\n    MemberExpression: 'MemberExpression',\n    MethodDefinition: 'MethodDefinition',\n    NewExpression: 'NewExpression',\n    ObjectExpression: 'ObjectExpression',\n    ObjectPattern: 'ObjectPattern',\n    Program: 'Program',\n    Property: 'Property',\n    RestElement: 'RestElement',\n    ReturnStatement: 'ReturnStatement',\n    SequenceExpression: 'SequenceExpression',\n    SpreadElement: 'SpreadElement',\n    Super: 'Super',\n    SwitchCase: 'SwitchCase',\n    SwitchStatement: 'SwitchStatement',\n    TaggedTemplateExpression: 'TaggedTemplateExpression',\n    TemplateElement: 'TemplateElement',\n    TemplateLiteral: 'TemplateLiteral',\n    ThisExpression: 'ThisExpression',\n    ThrowStatement: 'ThrowStatement',\n    TryStatement: 'TryStatement',\n    UnaryExpression: 'UnaryExpression',\n    UpdateExpression: 'UpdateExpression',\n    VariableDeclaration: 'VariableDeclaration',\n    VariableDeclarator: 'VariableDeclarator',\n    WhileStatement: 'WhileStatement',\n    WithStatement: 'WithStatement'\n  };\n  PlaceHolders = {\n    ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'\n  };\n\n  // Error messages should be identical to V8.\n  Messages = {\n    UnexpectedToken: 'Unexpected token %0',\n    UnexpectedNumber: 'Unexpected number',\n    UnexpectedString: 'Unexpected string',\n    UnexpectedIdentifier: 'Unexpected identifier',\n    UnexpectedReserved: 'Unexpected reserved word',\n    UnexpectedTemplate: 'Unexpected quasi %0',\n    UnexpectedEOS: 'Unexpected end of input',\n    NewlineAfterThrow: 'Illegal newline after throw',\n    InvalidRegExp: 'Invalid regular expression',\n    UnterminatedRegExp: 'Invalid regular expression: missing /',\n    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n    InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n    NoCatchOrFinally: 'Missing catch or finally after try',\n    UnknownLabel: 'Undefined label \\'%0\\'',\n    Redeclaration: '%0 \\'%1\\' has already been declared',\n    IllegalContinue: 'Illegal continue statement',\n    IllegalBreak: 'Illegal break statement',\n    IllegalReturn: 'Illegal return statement',\n    StrictModeWith: 'Strict mode code may not include a with statement',\n    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n    StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n    StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n    StrictReservedWord: 'Use of future reserved word in strict mode',\n    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n    DefaultRestParameter: 'Unexpected token =',\n    ObjectPatternAsRestParameter: 'Unexpected token {',\n    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n    ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n    DuplicateConstructor: 'A class may only have one constructor',\n    StaticPrototype: 'Classes may not have static property named prototype',\n    MissingFromClause: 'Unexpected token',\n    NoAsAfterImportNamespace: 'Unexpected token',\n    InvalidModuleSpecifier: 'Unexpected token',\n    IllegalImportDeclaration: 'Unexpected token',\n    IllegalExportDeclaration: 'Unexpected token'\n  };\n\n  // See also tools/generate-unicode-regex.py.\n  Regex = {\n    NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n    NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n  };\n\n  // Ensure the condition is true, otherwise throw an error.\n  // This is only to have a better contract semantic, i.e. another safety net\n  // to catch a logic error. The condition shall be fulfilled in normal case.\n  // Do NOT use this to enforce a certain condition on any user input.\n\n  function assert(condition, message) {\n    /* istanbul ignore if */\n    if (!condition) {\n      throw new Error('ASSERT: ' + message);\n    }\n  }\n  function isDecimalDigit(ch) {\n    return ch >= 0x30 && ch <= 0x39; // 0..9\n  }\n\n  function isHexDigit(ch) {\n    return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n  }\n  function isOctalDigit(ch) {\n    return '01234567'.indexOf(ch) >= 0;\n  }\n  function octalToDecimal(ch) {\n    // \\0 is not octal escape sequence\n    var octal = ch !== '0',\n      code = '01234567'.indexOf(ch);\n    if (index < length && isOctalDigit(source[index])) {\n      octal = true;\n      code = code * 8 + '01234567'.indexOf(source[index++]);\n\n      // 3 digits are only allowed when string starts\n      // with 0, 1, 2, 3\n      if ('0123'.indexOf(ch) >= 0 && index < length && isOctalDigit(source[index])) {\n        code = code * 8 + '01234567'.indexOf(source[index++]);\n      }\n    }\n    return {\n      code: code,\n      octal: octal\n    };\n  }\n\n  // 7.2 White Space\n\n  function isWhiteSpace(ch) {\n    return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0;\n  }\n\n  // 7.3 Line Terminators\n\n  function isLineTerminator(ch) {\n    return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;\n  }\n\n  // 7.6 Identifier Names and Identifiers\n\n  function isIdentifierStart(ch) {\n    return ch === 0x24 || ch === 0x5F ||\n    // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A ||\n    // A..Z\n    ch >= 0x61 && ch <= 0x7A ||\n    // a..z\n    ch === 0x5C ||\n    // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch));\n  }\n  function isIdentifierPart(ch) {\n    return ch === 0x24 || ch === 0x5F ||\n    // $ (dollar) and _ (underscore)\n    ch >= 0x41 && ch <= 0x5A ||\n    // A..Z\n    ch >= 0x61 && ch <= 0x7A ||\n    // a..z\n    ch >= 0x30 && ch <= 0x39 ||\n    // 0..9\n    ch === 0x5C ||\n    // \\ (backslash)\n    ch >= 0x80 && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch));\n  }\n\n  // 7.6.1.2 Future Reserved Words\n\n  function isFutureReservedWord(id) {\n    switch (id) {\n      case 'enum':\n      case 'export':\n      case 'import':\n      case 'super':\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  // 11.6.2.2 Future Reserved Words\n\n  function isStrictModeReservedWord(id) {\n    switch (id) {\n      case 'implements':\n      case 'interface':\n      case 'package':\n      case 'private':\n      case 'protected':\n      case 'public':\n      case 'static':\n      case 'yield':\n      case 'let':\n        return true;\n      default:\n        return false;\n    }\n  }\n  function isRestrictedWord(id) {\n    return id === 'eval' || id === 'arguments';\n  }\n\n  // 7.6.1.1 Keywords\n\n  function isKeyword(id) {\n    // 'const' is specialized as Keyword in V8.\n    // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.\n    // Some others are from future reserved words.\n\n    switch (id.length) {\n      case 2:\n        return id === 'if' || id === 'in' || id === 'do';\n      case 3:\n        return id === 'var' || id === 'for' || id === 'new' || id === 'try' || id === 'let';\n      case 4:\n        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';\n      case 5:\n        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';\n      case 6:\n        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';\n      case 7:\n        return id === 'default' || id === 'finally' || id === 'extends';\n      case 8:\n        return id === 'function' || id === 'continue' || id === 'debugger';\n      case 10:\n        return id === 'instanceof';\n      default:\n        return false;\n    }\n  }\n\n  // 7.4 Comments\n\n  function addComment(type, value, start, end, loc) {\n    var comment;\n    assert(typeof start === 'number', 'Comment must have valid position');\n    state.lastCommentStart = start;\n    comment = {\n      type: type,\n      value: value\n    };\n    if (extra.range) {\n      comment.range = [start, end];\n    }\n    if (extra.loc) {\n      comment.loc = loc;\n    }\n    extra.comments.push(comment);\n    if (extra.attachComment) {\n      extra.leadingComments.push(comment);\n      extra.trailingComments.push(comment);\n    }\n  }\n  function skipSingleLineComment(offset) {\n    var start, loc, ch, comment;\n    start = index - offset;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart - offset\n      }\n    };\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      ++index;\n      if (isLineTerminator(ch)) {\n        hasLineTerminator = true;\n        if (extra.comments) {\n          comment = source.slice(start + offset, index - 1);\n          loc.end = {\n            line: lineNumber,\n            column: index - lineStart - 1\n          };\n          addComment('Line', comment, start, index - 1, loc);\n        }\n        if (ch === 13 && source.charCodeAt(index) === 10) {\n          ++index;\n        }\n        ++lineNumber;\n        lineStart = index;\n        return;\n      }\n    }\n    if (extra.comments) {\n      comment = source.slice(start + offset, index);\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      addComment('Line', comment, start, index, loc);\n    }\n  }\n  function skipMultiLineComment() {\n    var start, loc, ch, comment;\n    if (extra.comments) {\n      start = index - 2;\n      loc = {\n        start: {\n          line: lineNumber,\n          column: index - lineStart - 2\n        }\n      };\n    }\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (isLineTerminator(ch)) {\n        if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n          ++index;\n        }\n        hasLineTerminator = true;\n        ++lineNumber;\n        ++index;\n        lineStart = index;\n      } else if (ch === 0x2A) {\n        // Block comment ends with '*/'.\n        if (source.charCodeAt(index + 1) === 0x2F) {\n          ++index;\n          ++index;\n          if (extra.comments) {\n            comment = source.slice(start + 2, index - 2);\n            loc.end = {\n              line: lineNumber,\n              column: index - lineStart\n            };\n            addComment('Block', comment, start, index, loc);\n          }\n          return;\n        }\n        ++index;\n      } else {\n        ++index;\n      }\n    }\n\n    // Ran off the end of the file - the whole thing is a comment\n    if (extra.comments) {\n      loc.end = {\n        line: lineNumber,\n        column: index - lineStart\n      };\n      comment = source.slice(start + 2, index);\n      addComment('Block', comment, start, index, loc);\n    }\n    tolerateUnexpectedToken();\n  }\n  function skipComment() {\n    var ch, start;\n    hasLineTerminator = false;\n    start = index === 0;\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (isWhiteSpace(ch)) {\n        ++index;\n      } else if (isLineTerminator(ch)) {\n        hasLineTerminator = true;\n        ++index;\n        if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n          ++index;\n        }\n        ++lineNumber;\n        lineStart = index;\n        start = true;\n      } else if (ch === 0x2F) {\n        // U+002F is '/'\n        ch = source.charCodeAt(index + 1);\n        if (ch === 0x2F) {\n          ++index;\n          ++index;\n          skipSingleLineComment(2);\n          start = true;\n        } else if (ch === 0x2A) {\n          // U+002A is '*'\n          ++index;\n          ++index;\n          skipMultiLineComment();\n        } else {\n          break;\n        }\n      } else if (start && ch === 0x2D) {\n        // U+002D is '-'\n        // U+003E is '>'\n        if (source.charCodeAt(index + 1) === 0x2D && source.charCodeAt(index + 2) === 0x3E) {\n          // '-->' is a single-line comment\n          index += 3;\n          skipSingleLineComment(3);\n        } else {\n          break;\n        }\n      } else if (ch === 0x3C) {\n        // U+003C is '<'\n        if (source.slice(index + 1, index + 4) === '!--') {\n          ++index; // `<`\n          ++index; // `!`\n          ++index; // `-`\n          ++index; // `-`\n          skipSingleLineComment(4);\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  function scanHexEscape(prefix) {\n    var i,\n      len,\n      ch,\n      code = 0;\n    len = prefix === 'u' ? 4 : 2;\n    for (i = 0; i < len; ++i) {\n      if (index < length && isHexDigit(source[index])) {\n        ch = source[index++];\n        code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n      } else {\n        return '';\n      }\n    }\n    return String.fromCharCode(code);\n  }\n  function scanUnicodeCodePointEscape() {\n    var ch, code, cu1, cu2;\n    ch = source[index];\n    code = 0;\n\n    // At least, one hex digit is required.\n    if (ch === '}') {\n      throwUnexpectedToken();\n    }\n    while (index < length) {\n      ch = source[index++];\n      if (!isHexDigit(ch)) {\n        break;\n      }\n      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n    }\n    if (code > 0x10FFFF || ch !== '}') {\n      throwUnexpectedToken();\n    }\n\n    // UTF-16 Encoding\n    if (code <= 0xFFFF) {\n      return String.fromCharCode(code);\n    }\n    cu1 = (code - 0x10000 >> 10) + 0xD800;\n    cu2 = (code - 0x10000 & 1023) + 0xDC00;\n    return String.fromCharCode(cu1, cu2);\n  }\n  function getEscapedIdentifier() {\n    var ch, id;\n    ch = source.charCodeAt(index++);\n    id = String.fromCharCode(ch);\n\n    // '\\u' (U+005C, U+0075) denotes an escaped character.\n    if (ch === 0x5C) {\n      if (source.charCodeAt(index) !== 0x75) {\n        throwUnexpectedToken();\n      }\n      ++index;\n      ch = scanHexEscape('u');\n      if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n        throwUnexpectedToken();\n      }\n      id = ch;\n    }\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (!isIdentifierPart(ch)) {\n        break;\n      }\n      ++index;\n      id += String.fromCharCode(ch);\n\n      // '\\u' (U+005C, U+0075) denotes an escaped character.\n      if (ch === 0x5C) {\n        id = id.substr(0, id.length - 1);\n        if (source.charCodeAt(index) !== 0x75) {\n          throwUnexpectedToken();\n        }\n        ++index;\n        ch = scanHexEscape('u');\n        if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n          throwUnexpectedToken();\n        }\n        id += ch;\n      }\n    }\n    return id;\n  }\n  function getIdentifier() {\n    var start, ch;\n    start = index++;\n    while (index < length) {\n      ch = source.charCodeAt(index);\n      if (ch === 0x5C) {\n        // Blackslash (U+005C) marks Unicode escape sequence.\n        index = start;\n        return getEscapedIdentifier();\n      }\n      if (isIdentifierPart(ch)) {\n        ++index;\n      } else {\n        break;\n      }\n    }\n    return source.slice(start, index);\n  }\n  function scanIdentifier() {\n    var start, id, type;\n    start = index;\n\n    // Backslash (U+005C) starts an escaped character.\n    id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier();\n\n    // There is no keyword or literal with only one character.\n    // Thus, it must be an identifier.\n    if (id.length === 1) {\n      type = Token.Identifier;\n    } else if (isKeyword(id)) {\n      type = Token.Keyword;\n    } else if (id === 'null') {\n      type = Token.NullLiteral;\n    } else if (id === 'true' || id === 'false') {\n      type = Token.BooleanLiteral;\n    } else {\n      type = Token.Identifier;\n    }\n    return {\n      type: type,\n      value: id,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  // 7.7 Punctuators\n\n  function scanPunctuator() {\n    var token, str;\n    token = {\n      type: Token.Punctuator,\n      value: '',\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: index,\n      end: index\n    };\n\n    // Check for most common single-character punctuators.\n    str = source[index];\n    switch (str) {\n      case '(':\n        if (extra.tokenize) {\n          extra.openParenToken = extra.tokens.length;\n        }\n        ++index;\n        break;\n      case '{':\n        if (extra.tokenize) {\n          extra.openCurlyToken = extra.tokens.length;\n        }\n        state.curlyStack.push('{');\n        ++index;\n        break;\n      case '.':\n        ++index;\n        if (source[index] === '.' && source[index + 1] === '.') {\n          // Spread operator: ...\n          index += 2;\n          str = '...';\n        }\n        break;\n      case '}':\n        ++index;\n        state.curlyStack.pop();\n        break;\n      case ')':\n      case ';':\n      case ',':\n      case '[':\n      case ']':\n      case ':':\n      case '?':\n      case '~':\n        ++index;\n        break;\n      default:\n        // 4-character punctuator.\n        str = source.substr(index, 4);\n        if (str === '>>>=') {\n          index += 4;\n        } else {\n          // 3-character punctuators.\n          str = str.substr(0, 3);\n          if (str === '===' || str === '!==' || str === '>>>' || str === '<<=' || str === '>>=') {\n            index += 3;\n          } else {\n            // 2-character punctuators.\n            str = str.substr(0, 2);\n            if (str === '&&' || str === '||' || str === '==' || str === '!=' || str === '+=' || str === '-=' || str === '*=' || str === '/=' || str === '++' || str === '--' || str === '<<' || str === '>>' || str === '&=' || str === '|=' || str === '^=' || str === '%=' || str === '<=' || str === '>=' || str === '=>') {\n              index += 2;\n            } else {\n              // 1-character punctuators.\n              str = source[index];\n              if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n                ++index;\n              }\n            }\n          }\n        }\n    }\n    if (index === token.start) {\n      throwUnexpectedToken();\n    }\n    token.end = index;\n    token.value = str;\n    return token;\n  }\n\n  // 7.8.3 Numeric Literals\n\n  function scanHexLiteral(start) {\n    var number = '';\n    while (index < length) {\n      if (!isHexDigit(source[index])) {\n        break;\n      }\n      number += source[index++];\n    }\n    if (number.length === 0) {\n      throwUnexpectedToken();\n    }\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt('0x' + number, 16),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n  function scanBinaryLiteral(start) {\n    var ch, number;\n    number = '';\n    while (index < length) {\n      ch = source[index];\n      if (ch !== '0' && ch !== '1') {\n        break;\n      }\n      number += source[index++];\n    }\n    if (number.length === 0) {\n      // only 0b or 0B\n      throwUnexpectedToken();\n    }\n    if (index < length) {\n      ch = source.charCodeAt(index);\n      /* istanbul ignore else */\n      if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n        throwUnexpectedToken();\n      }\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 2),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n  function scanOctalLiteral(prefix, start) {\n    var number, octal;\n    if (isOctalDigit(prefix)) {\n      octal = true;\n      number = '0' + source[index++];\n    } else {\n      octal = false;\n      ++index;\n      number = '';\n    }\n    while (index < length) {\n      if (!isOctalDigit(source[index])) {\n        break;\n      }\n      number += source[index++];\n    }\n    if (!octal && number.length === 0) {\n      // only 0o or 0O\n      throwUnexpectedToken();\n    }\n    if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseInt(number, 8),\n      octal: octal,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n  function isImplicitOctalLiteral() {\n    var i, ch;\n\n    // Implicit octal, unless there is a non-octal digit.\n    // (Annex B.1.1 on Numeric Literals)\n    for (i = index + 1; i < length; ++i) {\n      ch = source[i];\n      if (ch === '8' || ch === '9') {\n        return false;\n      }\n      if (!isOctalDigit(ch)) {\n        return true;\n      }\n    }\n    return true;\n  }\n  function scanNumericLiteral() {\n    var number, start, ch;\n    ch = source[index];\n    assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');\n    start = index;\n    number = '';\n    if (ch !== '.') {\n      number = source[index++];\n      ch = source[index];\n\n      // Hex number starts with '0x'.\n      // Octal number starts with '0'.\n      // Octal number in ES6 starts with '0o'.\n      // Binary number in ES6 starts with '0b'.\n      if (number === '0') {\n        if (ch === 'x' || ch === 'X') {\n          ++index;\n          return scanHexLiteral(start);\n        }\n        if (ch === 'b' || ch === 'B') {\n          ++index;\n          return scanBinaryLiteral(start);\n        }\n        if (ch === 'o' || ch === 'O') {\n          return scanOctalLiteral(ch, start);\n        }\n        if (isOctalDigit(ch)) {\n          if (isImplicitOctalLiteral()) {\n            return scanOctalLiteral(ch, start);\n          }\n        }\n      }\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n      ch = source[index];\n    }\n    if (ch === '.') {\n      number += source[index++];\n      while (isDecimalDigit(source.charCodeAt(index))) {\n        number += source[index++];\n      }\n      ch = source[index];\n    }\n    if (ch === 'e' || ch === 'E') {\n      number += source[index++];\n      ch = source[index];\n      if (ch === '+' || ch === '-') {\n        number += source[index++];\n      }\n      if (isDecimalDigit(source.charCodeAt(index))) {\n        while (isDecimalDigit(source.charCodeAt(index))) {\n          number += source[index++];\n        }\n      } else {\n        throwUnexpectedToken();\n      }\n    }\n    if (isIdentifierStart(source.charCodeAt(index))) {\n      throwUnexpectedToken();\n    }\n    return {\n      type: Token.NumericLiteral,\n      value: parseFloat(number),\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n\n  // 7.8.4 String Literals\n\n  function scanStringLiteral() {\n    var str = '',\n      quote,\n      start,\n      ch,\n      unescaped,\n      octToDec,\n      octal = false;\n    quote = source[index];\n    assert(quote === '\\'' || quote === '\"', 'String literal must starts with a quote');\n    start = index;\n    ++index;\n    while (index < length) {\n      ch = source[index++];\n      if (ch === quote) {\n        quote = '';\n        break;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n        if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'u':\n            case 'x':\n              if (source[index] === '{') {\n                ++index;\n                str += scanUnicodeCodePointEscape();\n              } else {\n                unescaped = scanHexEscape(ch);\n                if (!unescaped) {\n                  throw throwUnexpectedToken();\n                }\n                str += unescaped;\n              }\n              break;\n            case 'n':\n              str += '\\n';\n              break;\n            case 'r':\n              str += '\\r';\n              break;\n            case 't':\n              str += '\\t';\n              break;\n            case 'b':\n              str += '\\b';\n              break;\n            case 'f':\n              str += '\\f';\n              break;\n            case 'v':\n              str += '\\x0B';\n              break;\n            case '8':\n            case '9':\n              throw throwUnexpectedToken();\n            default:\n              if (isOctalDigit(ch)) {\n                octToDec = octalToDecimal(ch);\n                octal = octToDec.octal || octal;\n                str += String.fromCharCode(octToDec.code);\n              } else {\n                str += ch;\n              }\n              break;\n          }\n        } else {\n          ++lineNumber;\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        break;\n      } else {\n        str += ch;\n      }\n    }\n    if (quote !== '') {\n      throwUnexpectedToken();\n    }\n    return {\n      type: Token.StringLiteral,\n      value: str,\n      octal: octal,\n      lineNumber: startLineNumber,\n      lineStart: startLineStart,\n      start: start,\n      end: index\n    };\n  }\n  function scanTemplate() {\n    var cooked = '',\n      ch,\n      start,\n      rawOffset,\n      terminated,\n      head,\n      tail,\n      restore,\n      unescaped;\n    terminated = false;\n    tail = false;\n    start = index;\n    head = source[index] === '`';\n    rawOffset = 2;\n    ++index;\n    while (index < length) {\n      ch = source[index++];\n      if (ch === '`') {\n        rawOffset = 1;\n        tail = true;\n        terminated = true;\n        break;\n      } else if (ch === '$') {\n        if (source[index] === '{') {\n          state.curlyStack.push('${');\n          ++index;\n          terminated = true;\n          break;\n        }\n        cooked += ch;\n      } else if (ch === '\\\\') {\n        ch = source[index++];\n        if (!isLineTerminator(ch.charCodeAt(0))) {\n          switch (ch) {\n            case 'n':\n              cooked += '\\n';\n              break;\n            case 'r':\n              cooked += '\\r';\n              break;\n            case 't':\n              cooked += '\\t';\n              break;\n            case 'u':\n            case 'x':\n              if (source[index] === '{') {\n                ++index;\n                cooked += scanUnicodeCodePointEscape();\n              } else {\n                restore = index;\n                unescaped = scanHexEscape(ch);\n                if (unescaped) {\n                  cooked += unescaped;\n                } else {\n                  index = restore;\n                  cooked += ch;\n                }\n              }\n              break;\n            case 'b':\n              cooked += '\\b';\n              break;\n            case 'f':\n              cooked += '\\f';\n              break;\n            case 'v':\n              cooked += '\\v';\n              break;\n            default:\n              if (ch === '0') {\n                if (isDecimalDigit(source.charCodeAt(index))) {\n                  // Illegal: \\01 \\02 and so on\n                  throwError(Messages.TemplateOctalLiteral);\n                }\n                cooked += '\\0';\n              } else if (isOctalDigit(ch)) {\n                // Illegal: \\1 \\2\n                throwError(Messages.TemplateOctalLiteral);\n              } else {\n                cooked += ch;\n              }\n              break;\n          }\n        } else {\n          ++lineNumber;\n          if (ch === '\\r' && source[index] === '\\n') {\n            ++index;\n          }\n          lineStart = index;\n        }\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        ++lineNumber;\n        if (ch === '\\r' && source[index] === '\\n') {\n          ++index;\n        }\n        lineStart = index;\n        cooked += '\\n';\n      } else {\n        cooked += ch;\n      }\n    }\n    if (!terminated) {\n      throwUnexpectedToken();\n    }\n    if (!head) {\n      state.curlyStack.pop();\n    }\n    return {\n      type: Token.Template,\n      value: {\n        cooked: cooked,\n        raw: source.slice(start + 1, index - rawOffset)\n      },\n      head: head,\n      tail: tail,\n      lineNumber: lineNumber,\n      lineStart: lineStart,\n      start: start,\n      end: index\n    };\n  }\n  function testRegExp(pattern, flags) {\n    var tmp = pattern;\n    if (flags.indexOf('u') >= 0) {\n      // Replace each astral symbol and every Unicode escape sequence\n      // that possibly represents an astral symbol or a paired surrogate\n      // with a single ASCII symbol to avoid throwing on regular\n      // expressions that are only valid in combination with the `/u`\n      // flag.\n      // Note: replacing with the ASCII symbol `x` might cause false\n      // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n      // perfectly valid pattern that is equivalent to `[a-b]`, but it\n      // would be replaced by `[x-b]` which throws an error.\n      tmp = tmp.replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n        if (parseInt($1, 16) <= 0x10FFFF) {\n          return 'x';\n        }\n        throwUnexpectedToken(null, Messages.InvalidRegExp);\n      }).replace(/\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g, 'x');\n    }\n\n    // First, detect invalid regular expressions.\n    try {\n      RegExp(tmp);\n    } catch (e) {\n      throwUnexpectedToken(null, Messages.InvalidRegExp);\n    }\n\n    // Return a regular expression object for this pattern-flag pair, or\n    // `null` in case the current environment doesn't support the flags it\n    // uses.\n    try {\n      return new RegExp(pattern, flags);\n    } catch (exception) {\n      return null;\n    }\n  }\n  function scanRegExpBody() {\n    var ch, str, classMarker, terminated, body;\n    ch = source[index];\n    assert(ch === '/', 'Regular expression literal must start with a slash');\n    str = source[index++];\n    classMarker = false;\n    terminated = false;\n    while (index < length) {\n      ch = source[index++];\n      str += ch;\n      if (ch === '\\\\') {\n        ch = source[index++];\n        // ECMA-262 7.8.5\n        if (isLineTerminator(ch.charCodeAt(0))) {\n          throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n        }\n        str += ch;\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n      } else if (classMarker) {\n        if (ch === ']') {\n          classMarker = false;\n        }\n      } else {\n        if (ch === '/') {\n          terminated = true;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        }\n      }\n    }\n    if (!terminated) {\n      throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n    }\n\n    // Exclude leading and trailing slash.\n    body = str.substr(1, str.length - 2);\n    return {\n      value: body,\n      literal: str\n    };\n  }\n  function scanRegExpFlags() {\n    var ch, str, flags, restore;\n    str = '';\n    flags = '';\n    while (index < length) {\n      ch = source[index];\n      if (!isIdentifierPart(ch.charCodeAt(0))) {\n        break;\n      }\n      ++index;\n      if (ch === '\\\\' && index < length) {\n        ch = source[index];\n        if (ch === 'u') {\n          ++index;\n          restore = index;\n          ch = scanHexEscape('u');\n          if (ch) {\n            flags += ch;\n            for (str += '\\\\u'; restore < index; ++restore) {\n              str += source[restore];\n            }\n          } else {\n            index = restore;\n            flags += 'u';\n            str += '\\\\u';\n          }\n          tolerateUnexpectedToken();\n        } else {\n          str += '\\\\';\n          tolerateUnexpectedToken();\n        }\n      } else {\n        flags += ch;\n        str += ch;\n      }\n    }\n    return {\n      value: flags,\n      literal: str\n    };\n  }\n  function scanRegExp() {\n    scanning = true;\n    var start, body, flags, value;\n    lookahead = null;\n    skipComment();\n    start = index;\n    body = scanRegExpBody();\n    flags = scanRegExpFlags();\n    value = testRegExp(body.value, flags.value);\n    scanning = false;\n    if (extra.tokenize) {\n      return {\n        type: Token.RegularExpression,\n        value: value,\n        regex: {\n          pattern: body.value,\n          flags: flags.value\n        },\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: start,\n        end: index\n      };\n    }\n    return {\n      literal: body.literal + flags.literal,\n      value: value,\n      regex: {\n        pattern: body.value,\n        flags: flags.value\n      },\n      start: start,\n      end: index\n    };\n  }\n  function collectRegex() {\n    var pos, loc, regex, token;\n    skipComment();\n    pos = index;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    regex = scanRegExp();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n\n    /* istanbul ignore next */\n    if (!extra.tokenize) {\n      // Pop the previous token, which is likely '/' or '/='\n      if (extra.tokens.length > 0) {\n        token = extra.tokens[extra.tokens.length - 1];\n        if (token.range[0] === pos && token.type === 'Punctuator') {\n          if (token.value === '/' || token.value === '/=') {\n            extra.tokens.pop();\n          }\n        }\n      }\n      extra.tokens.push({\n        type: 'RegularExpression',\n        value: regex.literal,\n        regex: regex.regex,\n        range: [pos, index],\n        loc: loc\n      });\n    }\n    return regex;\n  }\n  function isIdentifierName(token) {\n    return token.type === Token.Identifier || token.type === Token.Keyword || token.type === Token.BooleanLiteral || token.type === Token.NullLiteral;\n  }\n  function advanceSlash() {\n    var prevToken, checkToken;\n    // Using the following algorithm:\n    // https://github.com/mozilla/sweet.js/wiki/design\n    prevToken = extra.tokens[extra.tokens.length - 1];\n    if (!prevToken) {\n      // Nothing before that: it cannot be a division.\n      return collectRegex();\n    }\n    if (prevToken.type === 'Punctuator') {\n      if (prevToken.value === ']') {\n        return scanPunctuator();\n      }\n      if (prevToken.value === ')') {\n        checkToken = extra.tokens[extra.openParenToken - 1];\n        if (checkToken && checkToken.type === 'Keyword' && (checkToken.value === 'if' || checkToken.value === 'while' || checkToken.value === 'for' || checkToken.value === 'with')) {\n          return collectRegex();\n        }\n        return scanPunctuator();\n      }\n      if (prevToken.value === '}') {\n        // Dividing a function by anything makes little sense,\n        // but we have to check for that.\n        if (extra.tokens[extra.openCurlyToken - 3] && extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n          // Anonymous function.\n          checkToken = extra.tokens[extra.openCurlyToken - 4];\n          if (!checkToken) {\n            return scanPunctuator();\n          }\n        } else if (extra.tokens[extra.openCurlyToken - 4] && extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n          // Named function.\n          checkToken = extra.tokens[extra.openCurlyToken - 5];\n          if (!checkToken) {\n            return collectRegex();\n          }\n        } else {\n          return scanPunctuator();\n        }\n        // checkToken determines whether the function is\n        // a declaration or an expression.\n        if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n          // It is an expression.\n          return scanPunctuator();\n        }\n        // It is a declaration.\n        return collectRegex();\n      }\n      return collectRegex();\n    }\n    if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n      return collectRegex();\n    }\n    return scanPunctuator();\n  }\n  function advance() {\n    var ch, token;\n    if (index >= length) {\n      return {\n        type: Token.EOF,\n        lineNumber: lineNumber,\n        lineStart: lineStart,\n        start: index,\n        end: index\n      };\n    }\n    ch = source.charCodeAt(index);\n    if (isIdentifierStart(ch)) {\n      token = scanIdentifier();\n      if (strict && isStrictModeReservedWord(token.value)) {\n        token.type = Token.Keyword;\n      }\n      return token;\n    }\n\n    // Very common: ( and ) and ;\n    if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n      return scanPunctuator();\n    }\n\n    // String literal starts with single quote (U+0027) or double quote (U+0022).\n    if (ch === 0x27 || ch === 0x22) {\n      return scanStringLiteral();\n    }\n\n    // Dot (.) U+002E can also start a floating-point number, hence the need\n    // to check the next character.\n    if (ch === 0x2E) {\n      if (isDecimalDigit(source.charCodeAt(index + 1))) {\n        return scanNumericLiteral();\n      }\n      return scanPunctuator();\n    }\n    if (isDecimalDigit(ch)) {\n      return scanNumericLiteral();\n    }\n\n    // Slash (/) U+002F can also start a regex.\n    if (extra.tokenize && ch === 0x2F) {\n      return advanceSlash();\n    }\n\n    // Template literals start with ` (U+0060) for template head\n    // or } (U+007D) for template middle or template tail.\n    if (ch === 0x60 || ch === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${') {\n      return scanTemplate();\n    }\n    return scanPunctuator();\n  }\n  function collectToken() {\n    var loc, token, value, entry;\n    loc = {\n      start: {\n        line: lineNumber,\n        column: index - lineStart\n      }\n    };\n    token = advance();\n    loc.end = {\n      line: lineNumber,\n      column: index - lineStart\n    };\n    if (token.type !== Token.EOF) {\n      value = source.slice(token.start, token.end);\n      entry = {\n        type: TokenName[token.type],\n        value: value,\n        range: [token.start, token.end],\n        loc: loc\n      };\n      if (token.regex) {\n        entry.regex = {\n          pattern: token.regex.pattern,\n          flags: token.regex.flags\n        };\n      }\n      extra.tokens.push(entry);\n    }\n    return token;\n  }\n  function lex() {\n    var token;\n    scanning = true;\n    lastIndex = index;\n    lastLineNumber = lineNumber;\n    lastLineStart = lineStart;\n    skipComment();\n    token = lookahead;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    scanning = false;\n    return token;\n  }\n  function peek() {\n    scanning = true;\n    skipComment();\n    lastIndex = index;\n    lastLineNumber = lineNumber;\n    lastLineStart = lineStart;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    lookahead = typeof extra.tokens !== 'undefined' ? collectToken() : advance();\n    scanning = false;\n  }\n  function Position() {\n    this.line = startLineNumber;\n    this.column = startIndex - startLineStart;\n  }\n  function SourceLocation() {\n    this.start = new Position();\n    this.end = null;\n  }\n  function WrappingSourceLocation(startToken) {\n    this.start = {\n      line: startToken.lineNumber,\n      column: startToken.start - startToken.lineStart\n    };\n    this.end = null;\n  }\n  function Node() {\n    if (extra.range) {\n      this.range = [startIndex, 0];\n    }\n    if (extra.loc) {\n      this.loc = new SourceLocation();\n    }\n  }\n  function WrappingNode(startToken) {\n    if (extra.range) {\n      this.range = [startToken.start, 0];\n    }\n    if (extra.loc) {\n      this.loc = new WrappingSourceLocation(startToken);\n    }\n  }\n  WrappingNode.prototype = Node.prototype = {\n    processComment: function () {\n      var lastChild,\n        leadingComments,\n        trailingComments,\n        bottomRight = extra.bottomRightStack,\n        i,\n        comment,\n        last = bottomRight[bottomRight.length - 1];\n      if (this.type === Syntax.Program) {\n        if (this.body.length > 0) {\n          return;\n        }\n      }\n      if (extra.trailingComments.length > 0) {\n        trailingComments = [];\n        for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n          comment = extra.trailingComments[i];\n          if (comment.range[0] >= this.range[1]) {\n            trailingComments.unshift(comment);\n            extra.trailingComments.splice(i, 1);\n          }\n        }\n        extra.trailingComments = [];\n      } else {\n        if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n          trailingComments = last.trailingComments;\n          delete last.trailingComments;\n        }\n      }\n\n      // Eating the stack.\n      if (last) {\n        while (last && last.range[0] >= this.range[0]) {\n          lastChild = last;\n          last = bottomRight.pop();\n        }\n      }\n      if (lastChild) {\n        if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {\n          this.leadingComments = lastChild.leadingComments;\n          lastChild.leadingComments = undefined;\n        }\n      } else if (extra.leadingComments.length > 0) {\n        leadingComments = [];\n        for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n          comment = extra.leadingComments[i];\n          if (comment.range[1] <= this.range[0]) {\n            leadingComments.unshift(comment);\n            extra.leadingComments.splice(i, 1);\n          }\n        }\n      }\n      if (leadingComments && leadingComments.length > 0) {\n        this.leadingComments = leadingComments;\n      }\n      if (trailingComments && trailingComments.length > 0) {\n        this.trailingComments = trailingComments;\n      }\n      bottomRight.push(this);\n    },\n    finish: function () {\n      if (extra.range) {\n        this.range[1] = lastIndex;\n      }\n      if (extra.loc) {\n        this.loc.end = {\n          line: lastLineNumber,\n          column: lastIndex - lastLineStart\n        };\n        if (extra.source) {\n          this.loc.source = extra.source;\n        }\n      }\n      if (extra.attachComment) {\n        this.processComment();\n      }\n    },\n    finishArrayExpression: function (elements) {\n      this.type = Syntax.ArrayExpression;\n      this.elements = elements;\n      this.finish();\n      return this;\n    },\n    finishArrayPattern: function (elements) {\n      this.type = Syntax.ArrayPattern;\n      this.elements = elements;\n      this.finish();\n      return this;\n    },\n    finishArrowFunctionExpression: function (params, defaults, body, expression) {\n      this.type = Syntax.ArrowFunctionExpression;\n      this.id = null;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = false;\n      this.expression = expression;\n      this.finish();\n      return this;\n    },\n    finishAssignmentExpression: function (operator, left, right) {\n      this.type = Syntax.AssignmentExpression;\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishAssignmentPattern: function (left, right) {\n      this.type = Syntax.AssignmentPattern;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishBinaryExpression: function (operator, left, right) {\n      this.type = operator === '||' || operator === '&&' ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n      this.operator = operator;\n      this.left = left;\n      this.right = right;\n      this.finish();\n      return this;\n    },\n    finishBlockStatement: function (body) {\n      this.type = Syntax.BlockStatement;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishBreakStatement: function (label) {\n      this.type = Syntax.BreakStatement;\n      this.label = label;\n      this.finish();\n      return this;\n    },\n    finishCallExpression: function (callee, args) {\n      this.type = Syntax.CallExpression;\n      this.callee = callee;\n      this.arguments = args;\n      this.finish();\n      return this;\n    },\n    finishCatchClause: function (param, body) {\n      this.type = Syntax.CatchClause;\n      this.param = param;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassBody: function (body) {\n      this.type = Syntax.ClassBody;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassDeclaration: function (id, superClass, body) {\n      this.type = Syntax.ClassDeclaration;\n      this.id = id;\n      this.superClass = superClass;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishClassExpression: function (id, superClass, body) {\n      this.type = Syntax.ClassExpression;\n      this.id = id;\n      this.superClass = superClass;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishConditionalExpression: function (test, consequent, alternate) {\n      this.type = Syntax.ConditionalExpression;\n      this.test = test;\n      this.consequent = consequent;\n      this.alternate = alternate;\n      this.finish();\n      return this;\n    },\n    finishContinueStatement: function (label) {\n      this.type = Syntax.ContinueStatement;\n      this.label = label;\n      this.finish();\n      return this;\n    },\n    finishDebuggerStatement: function () {\n      this.type = Syntax.DebuggerStatement;\n      this.finish();\n      return this;\n    },\n    finishDoWhileStatement: function (body, test) {\n      this.type = Syntax.DoWhileStatement;\n      this.body = body;\n      this.test = test;\n      this.finish();\n      return this;\n    },\n    finishEmptyStatement: function () {\n      this.type = Syntax.EmptyStatement;\n      this.finish();\n      return this;\n    },\n    finishExpressionStatement: function (expression) {\n      this.type = Syntax.ExpressionStatement;\n      this.expression = expression;\n      this.finish();\n      return this;\n    },\n    finishForStatement: function (init, test, update, body) {\n      this.type = Syntax.ForStatement;\n      this.init = init;\n      this.test = test;\n      this.update = update;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishForInStatement: function (left, right, body) {\n      this.type = Syntax.ForInStatement;\n      this.left = left;\n      this.right = right;\n      this.body = body;\n      this.each = false;\n      this.finish();\n      return this;\n    },\n    finishFunctionDeclaration: function (id, params, defaults, body) {\n      this.type = Syntax.FunctionDeclaration;\n      this.id = id;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = false;\n      this.expression = false;\n      this.finish();\n      return this;\n    },\n    finishFunctionExpression: function (id, params, defaults, body) {\n      this.type = Syntax.FunctionExpression;\n      this.id = id;\n      this.params = params;\n      this.defaults = defaults;\n      this.body = body;\n      this.generator = false;\n      this.expression = false;\n      this.finish();\n      return this;\n    },\n    finishIdentifier: function (name) {\n      this.type = Syntax.Identifier;\n      this.name = name;\n      this.finish();\n      return this;\n    },\n    finishIfStatement: function (test, consequent, alternate) {\n      this.type = Syntax.IfStatement;\n      this.test = test;\n      this.consequent = consequent;\n      this.alternate = alternate;\n      this.finish();\n      return this;\n    },\n    finishLabeledStatement: function (label, body) {\n      this.type = Syntax.LabeledStatement;\n      this.label = label;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishLiteral: function (token) {\n      this.type = Syntax.Literal;\n      this.value = token.value;\n      this.raw = source.slice(token.start, token.end);\n      if (token.regex) {\n        this.regex = token.regex;\n      }\n      this.finish();\n      return this;\n    },\n    finishMemberExpression: function (accessor, object, property) {\n      this.type = Syntax.MemberExpression;\n      this.computed = accessor === '[';\n      this.object = object;\n      this.property = property;\n      this.finish();\n      return this;\n    },\n    finishNewExpression: function (callee, args) {\n      this.type = Syntax.NewExpression;\n      this.callee = callee;\n      this.arguments = args;\n      this.finish();\n      return this;\n    },\n    finishObjectExpression: function (properties) {\n      this.type = Syntax.ObjectExpression;\n      this.properties = properties;\n      this.finish();\n      return this;\n    },\n    finishObjectPattern: function (properties) {\n      this.type = Syntax.ObjectPattern;\n      this.properties = properties;\n      this.finish();\n      return this;\n    },\n    finishPostfixExpression: function (operator, argument) {\n      this.type = Syntax.UpdateExpression;\n      this.operator = operator;\n      this.argument = argument;\n      this.prefix = false;\n      this.finish();\n      return this;\n    },\n    finishProgram: function (body) {\n      this.type = Syntax.Program;\n      this.body = body;\n      if (sourceType === 'module') {\n        // very restrictive for now\n        this.sourceType = sourceType;\n      }\n      this.finish();\n      return this;\n    },\n    finishProperty: function (kind, key, computed, value, method, shorthand) {\n      this.type = Syntax.Property;\n      this.key = key;\n      this.computed = computed;\n      this.value = value;\n      this.kind = kind;\n      this.method = method;\n      this.shorthand = shorthand;\n      this.finish();\n      return this;\n    },\n    finishRestElement: function (argument) {\n      this.type = Syntax.RestElement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishReturnStatement: function (argument) {\n      this.type = Syntax.ReturnStatement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishSequenceExpression: function (expressions) {\n      this.type = Syntax.SequenceExpression;\n      this.expressions = expressions;\n      this.finish();\n      return this;\n    },\n    finishSpreadElement: function (argument) {\n      this.type = Syntax.SpreadElement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishSwitchCase: function (test, consequent) {\n      this.type = Syntax.SwitchCase;\n      this.test = test;\n      this.consequent = consequent;\n      this.finish();\n      return this;\n    },\n    finishSuper: function () {\n      this.type = Syntax.Super;\n      this.finish();\n      return this;\n    },\n    finishSwitchStatement: function (discriminant, cases) {\n      this.type = Syntax.SwitchStatement;\n      this.discriminant = discriminant;\n      this.cases = cases;\n      this.finish();\n      return this;\n    },\n    finishTaggedTemplateExpression: function (tag, quasi) {\n      this.type = Syntax.TaggedTemplateExpression;\n      this.tag = tag;\n      this.quasi = quasi;\n      this.finish();\n      return this;\n    },\n    finishTemplateElement: function (value, tail) {\n      this.type = Syntax.TemplateElement;\n      this.value = value;\n      this.tail = tail;\n      this.finish();\n      return this;\n    },\n    finishTemplateLiteral: function (quasis, expressions) {\n      this.type = Syntax.TemplateLiteral;\n      this.quasis = quasis;\n      this.expressions = expressions;\n      this.finish();\n      return this;\n    },\n    finishThisExpression: function () {\n      this.type = Syntax.ThisExpression;\n      this.finish();\n      return this;\n    },\n    finishThrowStatement: function (argument) {\n      this.type = Syntax.ThrowStatement;\n      this.argument = argument;\n      this.finish();\n      return this;\n    },\n    finishTryStatement: function (block, handler, finalizer) {\n      this.type = Syntax.TryStatement;\n      this.block = block;\n      this.guardedHandlers = [];\n      this.handlers = handler ? [handler] : [];\n      this.handler = handler;\n      this.finalizer = finalizer;\n      this.finish();\n      return this;\n    },\n    finishUnaryExpression: function (operator, argument) {\n      this.type = operator === '++' || operator === '--' ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n      this.operator = operator;\n      this.argument = argument;\n      this.prefix = true;\n      this.finish();\n      return this;\n    },\n    finishVariableDeclaration: function (declarations) {\n      this.type = Syntax.VariableDeclaration;\n      this.declarations = declarations;\n      this.kind = 'var';\n      this.finish();\n      return this;\n    },\n    finishLexicalDeclaration: function (declarations, kind) {\n      this.type = Syntax.VariableDeclaration;\n      this.declarations = declarations;\n      this.kind = kind;\n      this.finish();\n      return this;\n    },\n    finishVariableDeclarator: function (id, init) {\n      this.type = Syntax.VariableDeclarator;\n      this.id = id;\n      this.init = init;\n      this.finish();\n      return this;\n    },\n    finishWhileStatement: function (test, body) {\n      this.type = Syntax.WhileStatement;\n      this.test = test;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishWithStatement: function (object, body) {\n      this.type = Syntax.WithStatement;\n      this.object = object;\n      this.body = body;\n      this.finish();\n      return this;\n    },\n    finishExportSpecifier: function (local, exported) {\n      this.type = Syntax.ExportSpecifier;\n      this.exported = exported || local;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishImportDefaultSpecifier: function (local) {\n      this.type = Syntax.ImportDefaultSpecifier;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishImportNamespaceSpecifier: function (local) {\n      this.type = Syntax.ImportNamespaceSpecifier;\n      this.local = local;\n      this.finish();\n      return this;\n    },\n    finishExportNamedDeclaration: function (declaration, specifiers, src) {\n      this.type = Syntax.ExportNamedDeclaration;\n      this.declaration = declaration;\n      this.specifiers = specifiers;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishExportDefaultDeclaration: function (declaration) {\n      this.type = Syntax.ExportDefaultDeclaration;\n      this.declaration = declaration;\n      this.finish();\n      return this;\n    },\n    finishExportAllDeclaration: function (src) {\n      this.type = Syntax.ExportAllDeclaration;\n      this.source = src;\n      this.finish();\n      return this;\n    },\n    finishImportSpecifier: function (local, imported) {\n      this.type = Syntax.ImportSpecifier;\n      this.local = local || imported;\n      this.imported = imported;\n      this.finish();\n      return this;\n    },\n    finishImportDeclaration: function (specifiers, src) {\n      this.type = Syntax.ImportDeclaration;\n      this.specifiers = specifiers;\n      this.source = src;\n      this.finish();\n      return this;\n    }\n  };\n  function recordError(error) {\n    var e, existing;\n    for (e = 0; e < extra.errors.length; e++) {\n      existing = extra.errors[e];\n      // Prevent duplicated error.\n      /* istanbul ignore next */\n      if (existing.index === error.index && existing.message === error.message) {\n        return;\n      }\n    }\n    extra.errors.push(error);\n  }\n  function createError(line, pos, description) {\n    var error = new Error('Line ' + line + ': ' + description);\n    error.index = pos;\n    error.lineNumber = line;\n    error.column = pos - (scanning ? lineStart : lastLineStart) + 1;\n    error.description = description;\n    return error;\n  }\n\n  // Throw an exception\n\n  function throwError(messageFormat) {\n    var args, msg;\n    args = Array.prototype.slice.call(arguments, 1);\n    msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n      assert(idx < args.length, 'Message reference must be in range');\n      return args[idx];\n    });\n    throw createError(lastLineNumber, lastIndex, msg);\n  }\n  function tolerateError(messageFormat) {\n    var args, msg, error;\n    args = Array.prototype.slice.call(arguments, 1);\n    /* istanbul ignore next */\n    msg = messageFormat.replace(/%(\\d)/g, function (whole, idx) {\n      assert(idx < args.length, 'Message reference must be in range');\n      return args[idx];\n    });\n    error = createError(lineNumber, lastIndex, msg);\n    if (extra.errors) {\n      recordError(error);\n    } else {\n      throw error;\n    }\n  }\n\n  // Throw an exception because of the token.\n\n  function unexpectedTokenError(token, message) {\n    var value,\n      msg = message || Messages.UnexpectedToken;\n    if (token) {\n      if (!message) {\n        msg = token.type === Token.EOF ? Messages.UnexpectedEOS : token.type === Token.Identifier ? Messages.UnexpectedIdentifier : token.type === Token.NumericLiteral ? Messages.UnexpectedNumber : token.type === Token.StringLiteral ? Messages.UnexpectedString : token.type === Token.Template ? Messages.UnexpectedTemplate : Messages.UnexpectedToken;\n        if (token.type === Token.Keyword) {\n          if (isFutureReservedWord(token.value)) {\n            msg = Messages.UnexpectedReserved;\n          } else if (strict && isStrictModeReservedWord(token.value)) {\n            msg = Messages.StrictReservedWord;\n          }\n        }\n      }\n      value = token.type === Token.Template ? token.value.raw : token.value;\n    } else {\n      value = 'ILLEGAL';\n    }\n    msg = msg.replace('%0', value);\n    return token && typeof token.lineNumber === 'number' ? createError(token.lineNumber, token.start, msg) : createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);\n  }\n  function throwUnexpectedToken(token, message) {\n    throw unexpectedTokenError(token, message);\n  }\n  function tolerateUnexpectedToken(token, message) {\n    var error = unexpectedTokenError(token, message);\n    if (extra.errors) {\n      recordError(error);\n    } else {\n      throw error;\n    }\n  }\n\n  // Expect the next token to match the specified punctuator.\n  // If not, an exception will be thrown.\n\n  function expect(value) {\n    var token = lex();\n    if (token.type !== Token.Punctuator || token.value !== value) {\n      throwUnexpectedToken(token);\n    }\n  }\n\n  /**\n   * @name expectCommaSeparator\n   * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n   * to <code>expect(value)</code>\n   * @since 2.0\n   */\n  function expectCommaSeparator() {\n    var token;\n    if (extra.errors) {\n      token = lookahead;\n      if (token.type === Token.Punctuator && token.value === ',') {\n        lex();\n      } else if (token.type === Token.Punctuator && token.value === ';') {\n        lex();\n        tolerateUnexpectedToken(token);\n      } else {\n        tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n      }\n    } else {\n      expect(',');\n    }\n  }\n\n  // Expect the next token to match the specified keyword.\n  // If not, an exception will be thrown.\n\n  function expectKeyword(keyword) {\n    var token = lex();\n    if (token.type !== Token.Keyword || token.value !== keyword) {\n      throwUnexpectedToken(token);\n    }\n  }\n\n  // Return true if the next token matches the specified punctuator.\n\n  function match(value) {\n    return lookahead.type === Token.Punctuator && lookahead.value === value;\n  }\n\n  // Return true if the next token matches the specified keyword\n\n  function matchKeyword(keyword) {\n    return lookahead.type === Token.Keyword && lookahead.value === keyword;\n  }\n\n  // Return true if the next token matches the specified contextual keyword\n  // (where an identifier is sometimes a keyword depending on the context)\n\n  function matchContextualKeyword(keyword) {\n    return lookahead.type === Token.Identifier && lookahead.value === keyword;\n  }\n\n  // Return true if the next token is an assignment operator\n\n  function matchAssign() {\n    var op;\n    if (lookahead.type !== Token.Punctuator) {\n      return false;\n    }\n    op = lookahead.value;\n    return op === '=' || op === '*=' || op === '/=' || op === '%=' || op === '+=' || op === '-=' || op === '<<=' || op === '>>=' || op === '>>>=' || op === '&=' || op === '^=' || op === '|=';\n  }\n  function consumeSemicolon() {\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (source.charCodeAt(startIndex) === 0x3B || match(';')) {\n      lex();\n      return;\n    }\n    if (hasLineTerminator) {\n      return;\n    }\n\n    // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.\n    lastIndex = startIndex;\n    lastLineNumber = startLineNumber;\n    lastLineStart = startLineStart;\n    if (lookahead.type !== Token.EOF && !match('}')) {\n      throwUnexpectedToken(lookahead);\n    }\n  }\n\n  // Cover grammar support.\n  //\n  // When an assignment expression position starts with an left parenthesis, the determination of the type\n  // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n  // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n  //\n  // There are three productions that can be parsed in a parentheses pair that needs to be determined\n  // after the outermost pair is closed. They are:\n  //\n  //   1. AssignmentExpression\n  //   2. BindingElements\n  //   3. AssignmentTargets\n  //\n  // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n  // binding element or assignment target.\n  //\n  // The three productions have the relationship:\n  //\n  //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression\n  //\n  // with a single exception that CoverInitializedName when used directly in an Expression, generates\n  // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n  // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n  //\n  // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n  // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n  // the CoverInitializedName check is conducted.\n  //\n  // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n  // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n  // pattern. The CoverInitializedName check is deferred.\n  function isolateCoverGrammar(parser) {\n    var oldIsBindingElement = isBindingElement,\n      oldIsAssignmentTarget = isAssignmentTarget,\n      oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n      result;\n    isBindingElement = true;\n    isAssignmentTarget = true;\n    firstCoverInitializedNameError = null;\n    result = parser();\n    if (firstCoverInitializedNameError !== null) {\n      throwUnexpectedToken(firstCoverInitializedNameError);\n    }\n    isBindingElement = oldIsBindingElement;\n    isAssignmentTarget = oldIsAssignmentTarget;\n    firstCoverInitializedNameError = oldFirstCoverInitializedNameError;\n    return result;\n  }\n  function inheritCoverGrammar(parser) {\n    var oldIsBindingElement = isBindingElement,\n      oldIsAssignmentTarget = isAssignmentTarget,\n      oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n      result;\n    isBindingElement = true;\n    isAssignmentTarget = true;\n    firstCoverInitializedNameError = null;\n    result = parser();\n    isBindingElement = isBindingElement && oldIsBindingElement;\n    isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;\n    firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;\n    return result;\n  }\n  function parseArrayPattern() {\n    var node = new Node(),\n      elements = [],\n      rest,\n      restNode;\n    expect('[');\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else {\n        if (match('...')) {\n          restNode = new Node();\n          lex();\n          rest = parseVariableIdentifier();\n          elements.push(restNode.finishRestElement(rest));\n          break;\n        } else {\n          elements.push(parsePatternWithDefault());\n        }\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n    expect(']');\n    return node.finishArrayPattern(elements);\n  }\n  function parsePropertyPattern() {\n    var node = new Node(),\n      key,\n      computed = match('['),\n      init;\n    if (lookahead.type === Token.Identifier) {\n      key = parseVariableIdentifier();\n      if (match('=')) {\n        lex();\n        init = parseAssignmentExpression();\n        return node.finishProperty('init', key, false, new WrappingNode(key).finishAssignmentPattern(key, init), false, false);\n      } else if (!match(':')) {\n        return node.finishProperty('init', key, false, key, false, true);\n      }\n    } else {\n      key = parseObjectPropertyKey();\n    }\n    expect(':');\n    init = parsePatternWithDefault();\n    return node.finishProperty('init', key, computed, init, false, false);\n  }\n  function parseObjectPattern() {\n    var node = new Node(),\n      properties = [];\n    expect('{');\n    while (!match('}')) {\n      properties.push(parsePropertyPattern());\n      if (!match('}')) {\n        expect(',');\n      }\n    }\n    lex();\n    return node.finishObjectPattern(properties);\n  }\n  function parsePattern() {\n    if (lookahead.type === Token.Identifier) {\n      return parseVariableIdentifier();\n    } else if (match('[')) {\n      return parseArrayPattern();\n    } else if (match('{')) {\n      return parseObjectPattern();\n    }\n    throwUnexpectedToken(lookahead);\n  }\n  function parsePatternWithDefault() {\n    var startToken = lookahead,\n      pattern,\n      right;\n    pattern = parsePattern();\n    if (match('=')) {\n      lex();\n      right = isolateCoverGrammar(parseAssignmentExpression);\n      pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);\n    }\n    return pattern;\n  }\n\n  // 11.1.4 Array Initialiser\n\n  function parseArrayInitialiser() {\n    var elements = [],\n      node = new Node(),\n      restSpread;\n    expect('[');\n    while (!match(']')) {\n      if (match(',')) {\n        lex();\n        elements.push(null);\n      } else if (match('...')) {\n        restSpread = new Node();\n        lex();\n        restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));\n        if (!match(']')) {\n          isAssignmentTarget = isBindingElement = false;\n          expect(',');\n        }\n        elements.push(restSpread);\n      } else {\n        elements.push(inheritCoverGrammar(parseAssignmentExpression));\n        if (!match(']')) {\n          expect(',');\n        }\n      }\n    }\n    lex();\n    return node.finishArrayExpression(elements);\n  }\n\n  // 11.1.5 Object Initialiser\n\n  function parsePropertyFunction(node, paramInfo) {\n    var previousStrict, body;\n    isAssignmentTarget = isBindingElement = false;\n    previousStrict = strict;\n    body = isolateCoverGrammar(parseFunctionSourceElements);\n    if (strict && paramInfo.firstRestricted) {\n      tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);\n    }\n    if (strict && paramInfo.stricted) {\n      tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);\n    }\n    strict = previousStrict;\n    return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body);\n  }\n  function parsePropertyMethodFunction() {\n    var params,\n      method,\n      node = new Node();\n    params = parseParams();\n    method = parsePropertyFunction(node, params);\n    return method;\n  }\n  function parseObjectPropertyKey() {\n    var token,\n      node = new Node(),\n      expr;\n    token = lex();\n\n    // Note: This function is called only from parseObjectProperty(), where\n    // EOF and Punctuator tokens are already filtered out.\n\n    switch (token.type) {\n      case Token.StringLiteral:\n      case Token.NumericLiteral:\n        if (strict && token.octal) {\n          tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n        }\n        return node.finishLiteral(token);\n      case Token.Identifier:\n      case Token.BooleanLiteral:\n      case Token.NullLiteral:\n      case Token.Keyword:\n        return node.finishIdentifier(token.value);\n      case Token.Punctuator:\n        if (token.value === '[') {\n          expr = isolateCoverGrammar(parseAssignmentExpression);\n          expect(']');\n          return expr;\n        }\n        break;\n    }\n    throwUnexpectedToken(token);\n  }\n  function lookaheadPropertyName() {\n    switch (lookahead.type) {\n      case Token.Identifier:\n      case Token.StringLiteral:\n      case Token.BooleanLiteral:\n      case Token.NullLiteral:\n      case Token.NumericLiteral:\n      case Token.Keyword:\n        return true;\n      case Token.Punctuator:\n        return lookahead.value === '[';\n    }\n    return false;\n  }\n\n  // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,\n  // it might be called at a position where there is in fact a short hand identifier pattern or a data property.\n  // This can only be determined after we consumed up to the left parentheses.\n  //\n  // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller\n  // is responsible to visit other options.\n  function tryParseMethodDefinition(token, key, computed, node) {\n    var value, options, methodNode;\n    if (token.type === Token.Identifier) {\n      // check for `get` and `set`;\n\n      if (token.value === 'get' && lookaheadPropertyName()) {\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        methodNode = new Node();\n        expect('(');\n        expect(')');\n        value = parsePropertyFunction(methodNode, {\n          params: [],\n          defaults: [],\n          stricted: null,\n          firstRestricted: null,\n          message: null\n        });\n        return node.finishProperty('get', key, computed, value, false, false);\n      } else if (token.value === 'set' && lookaheadPropertyName()) {\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        methodNode = new Node();\n        expect('(');\n        options = {\n          params: [],\n          defaultCount: 0,\n          defaults: [],\n          firstRestricted: null,\n          paramSet: {}\n        };\n        if (match(')')) {\n          tolerateUnexpectedToken(lookahead);\n        } else {\n          parseParam(options);\n          if (options.defaultCount === 0) {\n            options.defaults = [];\n          }\n        }\n        expect(')');\n        value = parsePropertyFunction(methodNode, options);\n        return node.finishProperty('set', key, computed, value, false, false);\n      }\n    }\n    if (match('(')) {\n      value = parsePropertyMethodFunction();\n      return node.finishProperty('init', key, computed, value, true, false);\n    }\n\n    // Not a MethodDefinition.\n    return null;\n  }\n  function checkProto(key, computed, hasProto) {\n    if (computed === false && (key.type === Syntax.Identifier && key.name === '__proto__' || key.type === Syntax.Literal && key.value === '__proto__')) {\n      if (hasProto.value) {\n        tolerateError(Messages.DuplicateProtoProperty);\n      } else {\n        hasProto.value = true;\n      }\n    }\n  }\n  function parseObjectProperty(hasProto) {\n    var token = lookahead,\n      node = new Node(),\n      computed,\n      key,\n      maybeMethod,\n      value;\n    computed = match('[');\n    key = parseObjectPropertyKey();\n    maybeMethod = tryParseMethodDefinition(token, key, computed, node);\n    if (maybeMethod) {\n      checkProto(maybeMethod.key, maybeMethod.computed, hasProto);\n      // finished\n      return maybeMethod;\n    }\n\n    // init property or short hand property.\n    checkProto(key, computed, hasProto);\n    if (match(':')) {\n      lex();\n      value = inheritCoverGrammar(parseAssignmentExpression);\n      return node.finishProperty('init', key, computed, value, false, false);\n    }\n    if (token.type === Token.Identifier) {\n      if (match('=')) {\n        firstCoverInitializedNameError = lookahead;\n        lex();\n        value = isolateCoverGrammar(parseAssignmentExpression);\n        return node.finishProperty('init', key, computed, new WrappingNode(token).finishAssignmentPattern(key, value), false, true);\n      }\n      return node.finishProperty('init', key, computed, key, false, true);\n    }\n    throwUnexpectedToken(lookahead);\n  }\n  function parseObjectInitialiser() {\n    var properties = [],\n      hasProto = {\n        value: false\n      },\n      node = new Node();\n    expect('{');\n    while (!match('}')) {\n      properties.push(parseObjectProperty(hasProto));\n      if (!match('}')) {\n        expectCommaSeparator();\n      }\n    }\n    expect('}');\n    return node.finishObjectExpression(properties);\n  }\n  function reinterpretExpressionAsPattern(expr) {\n    var i;\n    switch (expr.type) {\n      case Syntax.Identifier:\n      case Syntax.MemberExpression:\n      case Syntax.RestElement:\n      case Syntax.AssignmentPattern:\n        break;\n      case Syntax.SpreadElement:\n        expr.type = Syntax.RestElement;\n        reinterpretExpressionAsPattern(expr.argument);\n        break;\n      case Syntax.ArrayExpression:\n        expr.type = Syntax.ArrayPattern;\n        for (i = 0; i < expr.elements.length; i++) {\n          if (expr.elements[i] !== null) {\n            reinterpretExpressionAsPattern(expr.elements[i]);\n          }\n        }\n        break;\n      case Syntax.ObjectExpression:\n        expr.type = Syntax.ObjectPattern;\n        for (i = 0; i < expr.properties.length; i++) {\n          reinterpretExpressionAsPattern(expr.properties[i].value);\n        }\n        break;\n      case Syntax.AssignmentExpression:\n        expr.type = Syntax.AssignmentPattern;\n        reinterpretExpressionAsPattern(expr.left);\n        break;\n      default:\n        // Allow other node type for tolerant parsing.\n        break;\n    }\n  }\n  function parseTemplateElement(option) {\n    var node, token;\n    if (lookahead.type !== Token.Template || option.head && !lookahead.head) {\n      throwUnexpectedToken();\n    }\n    node = new Node();\n    token = lex();\n    return node.finishTemplateElement({\n      raw: token.value.raw,\n      cooked: token.value.cooked\n    }, token.tail);\n  }\n  function parseTemplateLiteral() {\n    var quasi,\n      quasis,\n      expressions,\n      node = new Node();\n    quasi = parseTemplateElement({\n      head: true\n    });\n    quasis = [quasi];\n    expressions = [];\n    while (!quasi.tail) {\n      expressions.push(parseExpression());\n      quasi = parseTemplateElement({\n        head: false\n      });\n      quasis.push(quasi);\n    }\n    return node.finishTemplateLiteral(quasis, expressions);\n  }\n\n  // 11.1.6 The Grouping Operator\n\n  function parseGroupExpression() {\n    var expr, expressions, startToken, i;\n    expect('(');\n    if (match(')')) {\n      lex();\n      if (!match('=>')) {\n        expect('=>');\n      }\n      return {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: []\n      };\n    }\n    startToken = lookahead;\n    if (match('...')) {\n      expr = parseRestElement();\n      expect(')');\n      if (!match('=>')) {\n        expect('=>');\n      }\n      return {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: [expr]\n      };\n    }\n    isBindingElement = true;\n    expr = inheritCoverGrammar(parseAssignmentExpression);\n    if (match(',')) {\n      isAssignmentTarget = false;\n      expressions = [expr];\n      while (startIndex < length) {\n        if (!match(',')) {\n          break;\n        }\n        lex();\n        if (match('...')) {\n          if (!isBindingElement) {\n            throwUnexpectedToken(lookahead);\n          }\n          expressions.push(parseRestElement());\n          expect(')');\n          if (!match('=>')) {\n            expect('=>');\n          }\n          isBindingElement = false;\n          for (i = 0; i < expressions.length; i++) {\n            reinterpretExpressionAsPattern(expressions[i]);\n          }\n          return {\n            type: PlaceHolders.ArrowParameterPlaceHolder,\n            params: expressions\n          };\n        }\n        expressions.push(inheritCoverGrammar(parseAssignmentExpression));\n      }\n      expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n    }\n    expect(')');\n    if (match('=>')) {\n      if (!isBindingElement) {\n        throwUnexpectedToken(lookahead);\n      }\n      if (expr.type === Syntax.SequenceExpression) {\n        for (i = 0; i < expr.expressions.length; i++) {\n          reinterpretExpressionAsPattern(expr.expressions[i]);\n        }\n      } else {\n        reinterpretExpressionAsPattern(expr);\n      }\n      expr = {\n        type: PlaceHolders.ArrowParameterPlaceHolder,\n        params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]\n      };\n    }\n    isBindingElement = false;\n    return expr;\n  }\n\n  // 11.1 Primary Expressions\n\n  function parsePrimaryExpression() {\n    var type, token, expr, node;\n    if (match('(')) {\n      isBindingElement = false;\n      return inheritCoverGrammar(parseGroupExpression);\n    }\n    if (match('[')) {\n      return inheritCoverGrammar(parseArrayInitialiser);\n    }\n    if (match('{')) {\n      return inheritCoverGrammar(parseObjectInitialiser);\n    }\n    type = lookahead.type;\n    node = new Node();\n    if (type === Token.Identifier) {\n      expr = node.finishIdentifier(lex().value);\n    } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n      if (strict && lookahead.octal) {\n        tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n      }\n      expr = node.finishLiteral(lex());\n    } else if (type === Token.Keyword) {\n      isAssignmentTarget = isBindingElement = false;\n      if (matchKeyword('function')) {\n        return parseFunctionExpression();\n      }\n      if (matchKeyword('this')) {\n        lex();\n        return node.finishThisExpression();\n      }\n      if (matchKeyword('class')) {\n        return parseClassExpression();\n      }\n      throwUnexpectedToken(lex());\n    } else if (type === Token.BooleanLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n      token = lex();\n      token.value = token.value === 'true';\n      expr = node.finishLiteral(token);\n    } else if (type === Token.NullLiteral) {\n      isAssignmentTarget = isBindingElement = false;\n      token = lex();\n      token.value = null;\n      expr = node.finishLiteral(token);\n    } else if (match('/') || match('/=')) {\n      isAssignmentTarget = isBindingElement = false;\n      index = startIndex;\n      if (typeof extra.tokens !== 'undefined') {\n        token = collectRegex();\n      } else {\n        token = scanRegExp();\n      }\n      lex();\n      expr = node.finishLiteral(token);\n    } else if (type === Token.Template) {\n      expr = parseTemplateLiteral();\n    } else {\n      throwUnexpectedToken(lex());\n    }\n    return expr;\n  }\n\n  // 11.2 Left-Hand-Side Expressions\n\n  function parseArguments() {\n    var args = [];\n    expect('(');\n    if (!match(')')) {\n      while (startIndex < length) {\n        args.push(isolateCoverGrammar(parseAssignmentExpression));\n        if (match(')')) {\n          break;\n        }\n        expectCommaSeparator();\n      }\n    }\n    expect(')');\n    return args;\n  }\n  function parseNonComputedProperty() {\n    var token,\n      node = new Node();\n    token = lex();\n    if (!isIdentifierName(token)) {\n      throwUnexpectedToken(token);\n    }\n    return node.finishIdentifier(token.value);\n  }\n  function parseNonComputedMember() {\n    expect('.');\n    return parseNonComputedProperty();\n  }\n  function parseComputedMember() {\n    var expr;\n    expect('[');\n    expr = isolateCoverGrammar(parseExpression);\n    expect(']');\n    return expr;\n  }\n  function parseNewExpression() {\n    var callee,\n      args,\n      node = new Node();\n    expectKeyword('new');\n    callee = isolateCoverGrammar(parseLeftHandSideExpression);\n    args = match('(') ? parseArguments() : [];\n    isAssignmentTarget = isBindingElement = false;\n    return node.finishNewExpression(callee, args);\n  }\n  function parseLeftHandSideExpressionAllowCall() {\n    var quasi,\n      expr,\n      args,\n      property,\n      startToken,\n      previousAllowIn = state.allowIn;\n    startToken = lookahead;\n    state.allowIn = true;\n    if (matchKeyword('super') && state.inFunctionBody) {\n      expr = new Node();\n      lex();\n      expr = expr.finishSuper();\n      if (!match('(') && !match('.') && !match('[')) {\n        throwUnexpectedToken(lookahead);\n      }\n    } else {\n      expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n    }\n    for (;;) {\n      if (match('.')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseNonComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n      } else if (match('(')) {\n        isBindingElement = false;\n        isAssignmentTarget = false;\n        args = parseArguments();\n        expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n      } else if (match('[')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n      } else if (lookahead.type === Token.Template && lookahead.head) {\n        quasi = parseTemplateLiteral();\n        expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n      } else {\n        break;\n      }\n    }\n    state.allowIn = previousAllowIn;\n    return expr;\n  }\n  function parseLeftHandSideExpression() {\n    var quasi, expr, property, startToken;\n    assert(state.allowIn, 'callee of new expression always allow in keyword.');\n    startToken = lookahead;\n    if (matchKeyword('super') && state.inFunctionBody) {\n      expr = new Node();\n      lex();\n      expr = expr.finishSuper();\n      if (!match('[') && !match('.')) {\n        throwUnexpectedToken(lookahead);\n      }\n    } else {\n      expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n    }\n    for (;;) {\n      if (match('[')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n      } else if (match('.')) {\n        isBindingElement = false;\n        isAssignmentTarget = true;\n        property = parseNonComputedMember();\n        expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n      } else if (lookahead.type === Token.Template && lookahead.head) {\n        quasi = parseTemplateLiteral();\n        expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n      } else {\n        break;\n      }\n    }\n    return expr;\n  }\n\n  // 11.3 Postfix Expressions\n\n  function parsePostfixExpression() {\n    var expr,\n      token,\n      startToken = lookahead;\n    expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);\n    if (!hasLineTerminator && lookahead.type === Token.Punctuator) {\n      if (match('++') || match('--')) {\n        // 11.3.1, 11.3.2\n        if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n          tolerateError(Messages.StrictLHSPostfix);\n        }\n        if (!isAssignmentTarget) {\n          tolerateError(Messages.InvalidLHSInAssignment);\n        }\n        isAssignmentTarget = isBindingElement = false;\n        token = lex();\n        expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n      }\n    }\n    return expr;\n  }\n\n  // 11.4 Unary Operators\n\n  function parseUnaryExpression() {\n    var token, expr, startToken;\n    if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n      expr = parsePostfixExpression();\n    } else if (match('++') || match('--')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression);\n      // 11.4.4, 11.4.5\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        tolerateError(Messages.StrictLHSPrefix);\n      }\n      if (!isAssignmentTarget) {\n        tolerateError(Messages.InvalidLHSInAssignment);\n      }\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      isAssignmentTarget = isBindingElement = false;\n    } else if (match('+') || match('-') || match('~') || match('!')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression);\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      isAssignmentTarget = isBindingElement = false;\n    } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n      startToken = lookahead;\n      token = lex();\n      expr = inheritCoverGrammar(parseUnaryExpression);\n      expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n      if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n        tolerateError(Messages.StrictDelete);\n      }\n      isAssignmentTarget = isBindingElement = false;\n    } else {\n      expr = parsePostfixExpression();\n    }\n    return expr;\n  }\n  function binaryPrecedence(token, allowIn) {\n    var prec = 0;\n    if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n      return 0;\n    }\n    switch (token.value) {\n      case '||':\n        prec = 1;\n        break;\n      case '&&':\n        prec = 2;\n        break;\n      case '|':\n        prec = 3;\n        break;\n      case '^':\n        prec = 4;\n        break;\n      case '&':\n        prec = 5;\n        break;\n      case '==':\n      case '!=':\n      case '===':\n      case '!==':\n        prec = 6;\n        break;\n      case '<':\n      case '>':\n      case '<=':\n      case '>=':\n      case 'instanceof':\n        prec = 7;\n        break;\n      case 'in':\n        prec = allowIn ? 7 : 0;\n        break;\n      case '<<':\n      case '>>':\n      case '>>>':\n        prec = 8;\n        break;\n      case '+':\n      case '-':\n        prec = 9;\n        break;\n      case '*':\n      case '/':\n      case '%':\n        prec = 11;\n        break;\n      default:\n        break;\n    }\n    return prec;\n  }\n\n  // 11.5 Multiplicative Operators\n  // 11.6 Additive Operators\n  // 11.7 Bitwise Shift Operators\n  // 11.8 Relational Operators\n  // 11.9 Equality Operators\n  // 11.10 Binary Bitwise Operators\n  // 11.11 Binary Logical Operators\n\n  function parseBinaryExpression() {\n    var marker, markers, expr, token, prec, stack, right, operator, left, i;\n    marker = lookahead;\n    left = inheritCoverGrammar(parseUnaryExpression);\n    token = lookahead;\n    prec = binaryPrecedence(token, state.allowIn);\n    if (prec === 0) {\n      return left;\n    }\n    isAssignmentTarget = isBindingElement = false;\n    token.prec = prec;\n    lex();\n    markers = [marker, lookahead];\n    right = isolateCoverGrammar(parseUnaryExpression);\n    stack = [left, token, right];\n    while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {\n        right = stack.pop();\n        operator = stack.pop().value;\n        left = stack.pop();\n        markers.pop();\n        expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n        stack.push(expr);\n      }\n\n      // Shift.\n      token = lex();\n      token.prec = prec;\n      stack.push(token);\n      markers.push(lookahead);\n      expr = isolateCoverGrammar(parseUnaryExpression);\n      stack.push(expr);\n    }\n\n    // Final reduce to clean-up the stack.\n    i = stack.length - 1;\n    expr = stack[i];\n    markers.pop();\n    while (i > 1) {\n      expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n      i -= 2;\n    }\n    return expr;\n  }\n\n  // 11.12 Conditional Operator\n\n  function parseConditionalExpression() {\n    var expr, previousAllowIn, consequent, alternate, startToken;\n    startToken = lookahead;\n    expr = inheritCoverGrammar(parseBinaryExpression);\n    if (match('?')) {\n      lex();\n      previousAllowIn = state.allowIn;\n      state.allowIn = true;\n      consequent = isolateCoverGrammar(parseAssignmentExpression);\n      state.allowIn = previousAllowIn;\n      expect(':');\n      alternate = isolateCoverGrammar(parseAssignmentExpression);\n      expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n      isAssignmentTarget = isBindingElement = false;\n    }\n    return expr;\n  }\n\n  // [ES6] 14.2 Arrow Function\n\n  function parseConciseBody() {\n    if (match('{')) {\n      return parseFunctionSourceElements();\n    }\n    return isolateCoverGrammar(parseAssignmentExpression);\n  }\n  function checkPatternParam(options, param) {\n    var i;\n    switch (param.type) {\n      case Syntax.Identifier:\n        validateParam(options, param, param.name);\n        break;\n      case Syntax.RestElement:\n        checkPatternParam(options, param.argument);\n        break;\n      case Syntax.AssignmentPattern:\n        checkPatternParam(options, param.left);\n        break;\n      case Syntax.ArrayPattern:\n        for (i = 0; i < param.elements.length; i++) {\n          if (param.elements[i] !== null) {\n            checkPatternParam(options, param.elements[i]);\n          }\n        }\n        break;\n      default:\n        assert(param.type === Syntax.ObjectPattern, 'Invalid type');\n        for (i = 0; i < param.properties.length; i++) {\n          checkPatternParam(options, param.properties[i].value);\n        }\n        break;\n    }\n  }\n  function reinterpretAsCoverFormalsList(expr) {\n    var i, len, param, params, defaults, defaultCount, options, token;\n    defaults = [];\n    defaultCount = 0;\n    params = [expr];\n    switch (expr.type) {\n      case Syntax.Identifier:\n        break;\n      case PlaceHolders.ArrowParameterPlaceHolder:\n        params = expr.params;\n        break;\n      default:\n        return null;\n    }\n    options = {\n      paramSet: {}\n    };\n    for (i = 0, len = params.length; i < len; i += 1) {\n      param = params[i];\n      switch (param.type) {\n        case Syntax.AssignmentPattern:\n          params[i] = param.left;\n          defaults.push(param.right);\n          ++defaultCount;\n          checkPatternParam(options, param.left);\n          break;\n        default:\n          checkPatternParam(options, param);\n          params[i] = param;\n          defaults.push(null);\n          break;\n      }\n    }\n    if (options.message === Messages.StrictParamDupe) {\n      token = strict ? options.stricted : options.firstRestricted;\n      throwUnexpectedToken(token, options.message);\n    }\n    if (defaultCount === 0) {\n      defaults = [];\n    }\n    return {\n      params: params,\n      defaults: defaults,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n  function parseArrowFunctionExpression(options, node) {\n    var previousStrict, body;\n    if (hasLineTerminator) {\n      tolerateUnexpectedToken(lookahead);\n    }\n    expect('=>');\n    previousStrict = strict;\n    body = parseConciseBody();\n    if (strict && options.firstRestricted) {\n      throwUnexpectedToken(options.firstRestricted, options.message);\n    }\n    if (strict && options.stricted) {\n      tolerateUnexpectedToken(options.stricted, options.message);\n    }\n    strict = previousStrict;\n    return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n  }\n\n  // 11.13 Assignment Operators\n\n  function parseAssignmentExpression() {\n    var token, expr, right, list, startToken;\n    startToken = lookahead;\n    token = lookahead;\n    expr = parseConditionalExpression();\n    if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n      isAssignmentTarget = isBindingElement = false;\n      list = reinterpretAsCoverFormalsList(expr);\n      if (list) {\n        firstCoverInitializedNameError = null;\n        return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n      }\n      return expr;\n    }\n    if (matchAssign()) {\n      if (!isAssignmentTarget) {\n        tolerateError(Messages.InvalidLHSInAssignment);\n      }\n\n      // 11.13.1\n      if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n        tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n      }\n      if (!match('=')) {\n        isAssignmentTarget = isBindingElement = false;\n      } else {\n        reinterpretExpressionAsPattern(expr);\n      }\n      token = lex();\n      right = isolateCoverGrammar(parseAssignmentExpression);\n      expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n      firstCoverInitializedNameError = null;\n    }\n    return expr;\n  }\n\n  // 11.14 Comma Operator\n\n  function parseExpression() {\n    var expr,\n      startToken = lookahead,\n      expressions;\n    expr = isolateCoverGrammar(parseAssignmentExpression);\n    if (match(',')) {\n      expressions = [expr];\n      while (startIndex < length) {\n        if (!match(',')) {\n          break;\n        }\n        lex();\n        expressions.push(isolateCoverGrammar(parseAssignmentExpression));\n      }\n      expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n    }\n    return expr;\n  }\n\n  // 12.1 Block\n\n  function parseStatementListItem() {\n    if (lookahead.type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'export':\n          if (sourceType !== 'module') {\n            tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);\n          }\n          return parseExportDeclaration();\n        case 'import':\n          if (sourceType !== 'module') {\n            tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);\n          }\n          return parseImportDeclaration();\n        case 'const':\n        case 'let':\n          return parseLexicalDeclaration({\n            inFor: false\n          });\n        case 'function':\n          return parseFunctionDeclaration(new Node());\n        case 'class':\n          return parseClassDeclaration();\n      }\n    }\n    return parseStatement();\n  }\n  function parseStatementList() {\n    var list = [];\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n      list.push(parseStatementListItem());\n    }\n    return list;\n  }\n  function parseBlock() {\n    var block,\n      node = new Node();\n    expect('{');\n    block = parseStatementList();\n    expect('}');\n    return node.finishBlockStatement(block);\n  }\n\n  // 12.2 Variable Statement\n\n  function parseVariableIdentifier() {\n    var token,\n      node = new Node();\n    token = lex();\n    if (token.type !== Token.Identifier) {\n      if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n        tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n      } else {\n        throwUnexpectedToken(token);\n      }\n    }\n    return node.finishIdentifier(token.value);\n  }\n  function parseVariableDeclaration() {\n    var init = null,\n      id,\n      node = new Node();\n    id = parsePattern();\n\n    // 12.2.1\n    if (strict && isRestrictedWord(id.name)) {\n      tolerateError(Messages.StrictVarName);\n    }\n    if (match('=')) {\n      lex();\n      init = isolateCoverGrammar(parseAssignmentExpression);\n    } else if (id.type !== Syntax.Identifier) {\n      expect('=');\n    }\n    return node.finishVariableDeclarator(id, init);\n  }\n  function parseVariableDeclarationList() {\n    var list = [];\n    do {\n      list.push(parseVariableDeclaration());\n      if (!match(',')) {\n        break;\n      }\n      lex();\n    } while (startIndex < length);\n    return list;\n  }\n  function parseVariableStatement(node) {\n    var declarations;\n    expectKeyword('var');\n    declarations = parseVariableDeclarationList();\n    consumeSemicolon();\n    return node.finishVariableDeclaration(declarations);\n  }\n  function parseLexicalBinding(kind, options) {\n    var init = null,\n      id,\n      node = new Node();\n    id = parsePattern();\n\n    // 12.2.1\n    if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {\n      tolerateError(Messages.StrictVarName);\n    }\n    if (kind === 'const') {\n      if (!matchKeyword('in')) {\n        expect('=');\n        init = isolateCoverGrammar(parseAssignmentExpression);\n      }\n    } else if (!options.inFor && id.type !== Syntax.Identifier || match('=')) {\n      expect('=');\n      init = isolateCoverGrammar(parseAssignmentExpression);\n    }\n    return node.finishVariableDeclarator(id, init);\n  }\n  function parseBindingList(kind, options) {\n    var list = [];\n    do {\n      list.push(parseLexicalBinding(kind, options));\n      if (!match(',')) {\n        break;\n      }\n      lex();\n    } while (startIndex < length);\n    return list;\n  }\n  function parseLexicalDeclaration(options) {\n    var kind,\n      declarations,\n      node = new Node();\n    kind = lex().value;\n    assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n    declarations = parseBindingList(kind, options);\n    consumeSemicolon();\n    return node.finishLexicalDeclaration(declarations, kind);\n  }\n  function parseRestElement() {\n    var param,\n      node = new Node();\n    lex();\n    if (match('{')) {\n      throwError(Messages.ObjectPatternAsRestParameter);\n    }\n    param = parseVariableIdentifier();\n    if (match('=')) {\n      throwError(Messages.DefaultRestParameter);\n    }\n    if (!match(')')) {\n      throwError(Messages.ParameterAfterRestParameter);\n    }\n    return node.finishRestElement(param);\n  }\n\n  // 12.3 Empty Statement\n\n  function parseEmptyStatement(node) {\n    expect(';');\n    return node.finishEmptyStatement();\n  }\n\n  // 12.4 Expression Statement\n\n  function parseExpressionStatement(node) {\n    var expr = parseExpression();\n    consumeSemicolon();\n    return node.finishExpressionStatement(expr);\n  }\n\n  // 12.5 If statement\n\n  function parseIfStatement(node) {\n    var test, consequent, alternate;\n    expectKeyword('if');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    consequent = parseStatement();\n    if (matchKeyword('else')) {\n      lex();\n      alternate = parseStatement();\n    } else {\n      alternate = null;\n    }\n    return node.finishIfStatement(test, consequent, alternate);\n  }\n\n  // 12.6 Iteration Statements\n\n  function parseDoWhileStatement(node) {\n    var body, test, oldInIteration;\n    expectKeyword('do');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    if (match(';')) {\n      lex();\n    }\n    return node.finishDoWhileStatement(body, test);\n  }\n  function parseWhileStatement(node) {\n    var test, body, oldInIteration;\n    expectKeyword('while');\n    expect('(');\n    test = parseExpression();\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = parseStatement();\n    state.inIteration = oldInIteration;\n    return node.finishWhileStatement(test, body);\n  }\n  function parseForStatement(node) {\n    var init,\n      initSeq,\n      initStartToken,\n      test,\n      update,\n      left,\n      right,\n      kind,\n      declarations,\n      body,\n      oldInIteration,\n      previousAllowIn = state.allowIn;\n    init = test = update = null;\n    expectKeyword('for');\n    expect('(');\n    if (match(';')) {\n      lex();\n    } else {\n      if (matchKeyword('var')) {\n        init = new Node();\n        lex();\n        state.allowIn = false;\n        init = init.finishVariableDeclaration(parseVariableDeclarationList());\n        state.allowIn = previousAllowIn;\n        if (init.declarations.length === 1 && matchKeyword('in')) {\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else {\n          expect(';');\n        }\n      } else if (matchKeyword('const') || matchKeyword('let')) {\n        init = new Node();\n        kind = lex().value;\n        state.allowIn = false;\n        declarations = parseBindingList(kind, {\n          inFor: true\n        });\n        state.allowIn = previousAllowIn;\n        if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {\n          init = init.finishLexicalDeclaration(declarations, kind);\n          lex();\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else {\n          consumeSemicolon();\n          init = init.finishLexicalDeclaration(declarations, kind);\n        }\n      } else {\n        initStartToken = lookahead;\n        state.allowIn = false;\n        init = inheritCoverGrammar(parseAssignmentExpression);\n        state.allowIn = previousAllowIn;\n        if (matchKeyword('in')) {\n          if (!isAssignmentTarget) {\n            tolerateError(Messages.InvalidLHSInForIn);\n          }\n          lex();\n          reinterpretExpressionAsPattern(init);\n          left = init;\n          right = parseExpression();\n          init = null;\n        } else {\n          if (match(',')) {\n            initSeq = [init];\n            while (match(',')) {\n              lex();\n              initSeq.push(isolateCoverGrammar(parseAssignmentExpression));\n            }\n            init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);\n          }\n          expect(';');\n        }\n      }\n    }\n    if (typeof left === 'undefined') {\n      if (!match(';')) {\n        test = parseExpression();\n      }\n      expect(';');\n      if (!match(')')) {\n        update = parseExpression();\n      }\n    }\n    expect(')');\n    oldInIteration = state.inIteration;\n    state.inIteration = true;\n    body = isolateCoverGrammar(parseStatement);\n    state.inIteration = oldInIteration;\n    return typeof left === 'undefined' ? node.finishForStatement(init, test, update, body) : node.finishForInStatement(left, right, body);\n  }\n\n  // 12.7 The continue statement\n\n  function parseContinueStatement(node) {\n    var label = null,\n      key;\n    expectKeyword('continue');\n\n    // Optimize the most common form: 'continue;'.\n    if (source.charCodeAt(startIndex) === 0x3B) {\n      lex();\n      if (!state.inIteration) {\n        throwError(Messages.IllegalContinue);\n      }\n      return node.finishContinueStatement(null);\n    }\n    if (hasLineTerminator) {\n      if (!state.inIteration) {\n        throwError(Messages.IllegalContinue);\n      }\n      return node.finishContinueStatement(null);\n    }\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.UnknownLabel, label.name);\n      }\n    }\n    consumeSemicolon();\n    if (label === null && !state.inIteration) {\n      throwError(Messages.IllegalContinue);\n    }\n    return node.finishContinueStatement(label);\n  }\n\n  // 12.8 The break statement\n\n  function parseBreakStatement(node) {\n    var label = null,\n      key;\n    expectKeyword('break');\n\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (source.charCodeAt(lastIndex) === 0x3B) {\n      lex();\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError(Messages.IllegalBreak);\n      }\n      return node.finishBreakStatement(null);\n    }\n    if (hasLineTerminator) {\n      if (!(state.inIteration || state.inSwitch)) {\n        throwError(Messages.IllegalBreak);\n      }\n      return node.finishBreakStatement(null);\n    }\n    if (lookahead.type === Token.Identifier) {\n      label = parseVariableIdentifier();\n      key = '$' + label.name;\n      if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.UnknownLabel, label.name);\n      }\n    }\n    consumeSemicolon();\n    if (label === null && !(state.inIteration || state.inSwitch)) {\n      throwError(Messages.IllegalBreak);\n    }\n    return node.finishBreakStatement(label);\n  }\n\n  // 12.9 The return statement\n\n  function parseReturnStatement(node) {\n    var argument = null;\n    expectKeyword('return');\n    if (!state.inFunctionBody) {\n      tolerateError(Messages.IllegalReturn);\n    }\n\n    // 'return' followed by a space and an identifier is very common.\n    if (source.charCodeAt(lastIndex) === 0x20) {\n      if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {\n        argument = parseExpression();\n        consumeSemicolon();\n        return node.finishReturnStatement(argument);\n      }\n    }\n    if (hasLineTerminator) {\n      // HACK\n      return node.finishReturnStatement(null);\n    }\n    if (!match(';')) {\n      if (!match('}') && lookahead.type !== Token.EOF) {\n        argument = parseExpression();\n      }\n    }\n    consumeSemicolon();\n    return node.finishReturnStatement(argument);\n  }\n\n  // 12.10 The with statement\n\n  function parseWithStatement(node) {\n    var object, body;\n    if (strict) {\n      tolerateError(Messages.StrictModeWith);\n    }\n    expectKeyword('with');\n    expect('(');\n    object = parseExpression();\n    expect(')');\n    body = parseStatement();\n    return node.finishWithStatement(object, body);\n  }\n\n  // 12.10 The swith statement\n\n  function parseSwitchCase() {\n    var test,\n      consequent = [],\n      statement,\n      node = new Node();\n    if (matchKeyword('default')) {\n      lex();\n      test = null;\n    } else {\n      expectKeyword('case');\n      test = parseExpression();\n    }\n    expect(':');\n    while (startIndex < length) {\n      if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n        break;\n      }\n      statement = parseStatementListItem();\n      consequent.push(statement);\n    }\n    return node.finishSwitchCase(test, consequent);\n  }\n  function parseSwitchStatement(node) {\n    var discriminant, cases, clause, oldInSwitch, defaultFound;\n    expectKeyword('switch');\n    expect('(');\n    discriminant = parseExpression();\n    expect(')');\n    expect('{');\n    cases = [];\n    if (match('}')) {\n      lex();\n      return node.finishSwitchStatement(discriminant, cases);\n    }\n    oldInSwitch = state.inSwitch;\n    state.inSwitch = true;\n    defaultFound = false;\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n      clause = parseSwitchCase();\n      if (clause.test === null) {\n        if (defaultFound) {\n          throwError(Messages.MultipleDefaultsInSwitch);\n        }\n        defaultFound = true;\n      }\n      cases.push(clause);\n    }\n    state.inSwitch = oldInSwitch;\n    expect('}');\n    return node.finishSwitchStatement(discriminant, cases);\n  }\n\n  // 12.13 The throw statement\n\n  function parseThrowStatement(node) {\n    var argument;\n    expectKeyword('throw');\n    if (hasLineTerminator) {\n      throwError(Messages.NewlineAfterThrow);\n    }\n    argument = parseExpression();\n    consumeSemicolon();\n    return node.finishThrowStatement(argument);\n  }\n\n  // 12.14 The try statement\n\n  function parseCatchClause() {\n    var param,\n      body,\n      node = new Node();\n    expectKeyword('catch');\n    expect('(');\n    if (match(')')) {\n      throwUnexpectedToken(lookahead);\n    }\n    param = parsePattern();\n\n    // 12.14.1\n    if (strict && isRestrictedWord(param.name)) {\n      tolerateError(Messages.StrictCatchVariable);\n    }\n    expect(')');\n    body = parseBlock();\n    return node.finishCatchClause(param, body);\n  }\n  function parseTryStatement(node) {\n    var block,\n      handler = null,\n      finalizer = null;\n    expectKeyword('try');\n    block = parseBlock();\n    if (matchKeyword('catch')) {\n      handler = parseCatchClause();\n    }\n    if (matchKeyword('finally')) {\n      lex();\n      finalizer = parseBlock();\n    }\n    if (!handler && !finalizer) {\n      throwError(Messages.NoCatchOrFinally);\n    }\n    return node.finishTryStatement(block, handler, finalizer);\n  }\n\n  // 12.15 The debugger statement\n\n  function parseDebuggerStatement(node) {\n    expectKeyword('debugger');\n    consumeSemicolon();\n    return node.finishDebuggerStatement();\n  }\n\n  // 12 Statements\n\n  function parseStatement() {\n    var type = lookahead.type,\n      expr,\n      labeledBody,\n      key,\n      node;\n    if (type === Token.EOF) {\n      throwUnexpectedToken(lookahead);\n    }\n    if (type === Token.Punctuator && lookahead.value === '{') {\n      return parseBlock();\n    }\n    isAssignmentTarget = isBindingElement = true;\n    node = new Node();\n    if (type === Token.Punctuator) {\n      switch (lookahead.value) {\n        case ';':\n          return parseEmptyStatement(node);\n        case '(':\n          return parseExpressionStatement(node);\n        default:\n          break;\n      }\n    } else if (type === Token.Keyword) {\n      switch (lookahead.value) {\n        case 'break':\n          return parseBreakStatement(node);\n        case 'continue':\n          return parseContinueStatement(node);\n        case 'debugger':\n          return parseDebuggerStatement(node);\n        case 'do':\n          return parseDoWhileStatement(node);\n        case 'for':\n          return parseForStatement(node);\n        case 'function':\n          return parseFunctionDeclaration(node);\n        case 'if':\n          return parseIfStatement(node);\n        case 'return':\n          return parseReturnStatement(node);\n        case 'switch':\n          return parseSwitchStatement(node);\n        case 'throw':\n          return parseThrowStatement(node);\n        case 'try':\n          return parseTryStatement(node);\n        case 'var':\n          return parseVariableStatement(node);\n        case 'while':\n          return parseWhileStatement(node);\n        case 'with':\n          return parseWithStatement(node);\n        default:\n          break;\n      }\n    }\n    expr = parseExpression();\n\n    // 12.12 Labelled Statements\n    if (expr.type === Syntax.Identifier && match(':')) {\n      lex();\n      key = '$' + expr.name;\n      if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n        throwError(Messages.Redeclaration, 'Label', expr.name);\n      }\n      state.labelSet[key] = true;\n      labeledBody = parseStatement();\n      delete state.labelSet[key];\n      return node.finishLabeledStatement(expr, labeledBody);\n    }\n    consumeSemicolon();\n    return node.finishExpressionStatement(expr);\n  }\n\n  // 13 Function Definition\n\n  function parseFunctionSourceElements() {\n    var statement,\n      body = [],\n      token,\n      directive,\n      firstRestricted,\n      oldLabelSet,\n      oldInIteration,\n      oldInSwitch,\n      oldInFunctionBody,\n      oldParenthesisCount,\n      node = new Node();\n    expect('{');\n    while (startIndex < length) {\n      if (lookahead.type !== Token.StringLiteral) {\n        break;\n      }\n      token = lookahead;\n      statement = parseStatementListItem();\n      body.push(statement);\n      if (statement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n      directive = source.slice(token.start + 1, token.end - 1);\n      if (directive === 'use strict') {\n        strict = true;\n        if (firstRestricted) {\n          tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n    oldLabelSet = state.labelSet;\n    oldInIteration = state.inIteration;\n    oldInSwitch = state.inSwitch;\n    oldInFunctionBody = state.inFunctionBody;\n    oldParenthesisCount = state.parenthesizedCount;\n    state.labelSet = {};\n    state.inIteration = false;\n    state.inSwitch = false;\n    state.inFunctionBody = true;\n    state.parenthesizedCount = 0;\n    while (startIndex < length) {\n      if (match('}')) {\n        break;\n      }\n      body.push(parseStatementListItem());\n    }\n    expect('}');\n    state.labelSet = oldLabelSet;\n    state.inIteration = oldInIteration;\n    state.inSwitch = oldInSwitch;\n    state.inFunctionBody = oldInFunctionBody;\n    state.parenthesizedCount = oldParenthesisCount;\n    return node.finishBlockStatement(body);\n  }\n  function validateParam(options, param, name) {\n    var key = '$' + name;\n    if (strict) {\n      if (isRestrictedWord(name)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamName;\n      }\n      if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n        options.stricted = param;\n        options.message = Messages.StrictParamDupe;\n      }\n    } else if (!options.firstRestricted) {\n      if (isRestrictedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictParamName;\n      } else if (isStrictModeReservedWord(name)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictReservedWord;\n      } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n        options.firstRestricted = param;\n        options.message = Messages.StrictParamDupe;\n      }\n    }\n    options.paramSet[key] = true;\n  }\n  function parseParam(options) {\n    var token, param, def;\n    token = lookahead;\n    if (token.value === '...') {\n      param = parseRestElement();\n      validateParam(options, param.argument, param.argument.name);\n      options.params.push(param);\n      options.defaults.push(null);\n      return false;\n    }\n    param = parsePatternWithDefault();\n    validateParam(options, token, token.value);\n    if (param.type === Syntax.AssignmentPattern) {\n      def = param.right;\n      param = param.left;\n      ++options.defaultCount;\n    }\n    options.params.push(param);\n    options.defaults.push(def);\n    return !match(')');\n  }\n  function parseParams(firstRestricted) {\n    var options;\n    options = {\n      params: [],\n      defaultCount: 0,\n      defaults: [],\n      firstRestricted: firstRestricted\n    };\n    expect('(');\n    if (!match(')')) {\n      options.paramSet = {};\n      while (startIndex < length) {\n        if (!parseParam(options)) {\n          break;\n        }\n        expect(',');\n      }\n    }\n    expect(')');\n    if (options.defaultCount === 0) {\n      options.defaults = [];\n    }\n    return {\n      params: options.params,\n      defaults: options.defaults,\n      stricted: options.stricted,\n      firstRestricted: options.firstRestricted,\n      message: options.message\n    };\n  }\n  function parseFunctionDeclaration(node, identifierIsOptional) {\n    var id = null,\n      params = [],\n      defaults = [],\n      body,\n      token,\n      stricted,\n      tmp,\n      firstRestricted,\n      message,\n      previousStrict;\n    expectKeyword('function');\n    if (!identifierIsOptional || !match('(')) {\n      token = lookahead;\n      id = parseVariableIdentifier();\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    defaults = tmp.defaults;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n    if (tmp.message) {\n      message = tmp.message;\n    }\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n    if (strict && firstRestricted) {\n      throwUnexpectedToken(firstRestricted, message);\n    }\n    if (strict && stricted) {\n      tolerateUnexpectedToken(stricted, message);\n    }\n    strict = previousStrict;\n    return node.finishFunctionDeclaration(id, params, defaults, body);\n  }\n  function parseFunctionExpression() {\n    var token,\n      id = null,\n      stricted,\n      firstRestricted,\n      message,\n      tmp,\n      params = [],\n      defaults = [],\n      body,\n      previousStrict,\n      node = new Node();\n    expectKeyword('function');\n    if (!match('(')) {\n      token = lookahead;\n      id = parseVariableIdentifier();\n      if (strict) {\n        if (isRestrictedWord(token.value)) {\n          tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n        }\n      } else {\n        if (isRestrictedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictFunctionName;\n        } else if (isStrictModeReservedWord(token.value)) {\n          firstRestricted = token;\n          message = Messages.StrictReservedWord;\n        }\n      }\n    }\n    tmp = parseParams(firstRestricted);\n    params = tmp.params;\n    defaults = tmp.defaults;\n    stricted = tmp.stricted;\n    firstRestricted = tmp.firstRestricted;\n    if (tmp.message) {\n      message = tmp.message;\n    }\n    previousStrict = strict;\n    body = parseFunctionSourceElements();\n    if (strict && firstRestricted) {\n      throwUnexpectedToken(firstRestricted, message);\n    }\n    if (strict && stricted) {\n      tolerateUnexpectedToken(stricted, message);\n    }\n    strict = previousStrict;\n    return node.finishFunctionExpression(id, params, defaults, body);\n  }\n  function parseClassBody() {\n    var classBody,\n      token,\n      isStatic,\n      hasConstructor = false,\n      body,\n      method,\n      computed,\n      key;\n    classBody = new Node();\n    expect('{');\n    body = [];\n    while (!match('}')) {\n      if (match(';')) {\n        lex();\n      } else {\n        method = new Node();\n        token = lookahead;\n        isStatic = false;\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        if (key.name === 'static' && lookaheadPropertyName()) {\n          token = lookahead;\n          isStatic = true;\n          computed = match('[');\n          key = parseObjectPropertyKey();\n        }\n        method = tryParseMethodDefinition(token, key, computed, method);\n        if (method) {\n          method['static'] = isStatic;\n          if (method.kind === 'init') {\n            method.kind = 'method';\n          }\n          if (!isStatic) {\n            if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {\n              if (method.kind !== 'method' || !method.method || method.value.generator) {\n                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);\n              }\n              if (hasConstructor) {\n                throwUnexpectedToken(token, Messages.DuplicateConstructor);\n              } else {\n                hasConstructor = true;\n              }\n              method.kind = 'constructor';\n            }\n          } else {\n            if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {\n              throwUnexpectedToken(token, Messages.StaticPrototype);\n            }\n          }\n          method.type = Syntax.MethodDefinition;\n          delete method.method;\n          delete method.shorthand;\n          body.push(method);\n        } else {\n          throwUnexpectedToken(lookahead);\n        }\n      }\n    }\n    lex();\n    return classBody.finishClassBody(body);\n  }\n  function parseClassDeclaration(identifierIsOptional) {\n    var id = null,\n      superClass = null,\n      classNode = new Node(),\n      classBody,\n      previousStrict = strict;\n    strict = true;\n    expectKeyword('class');\n    if (!identifierIsOptional || lookahead.type === Token.Identifier) {\n      id = parseVariableIdentifier();\n    }\n    if (matchKeyword('extends')) {\n      lex();\n      superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n    }\n    classBody = parseClassBody();\n    strict = previousStrict;\n    return classNode.finishClassDeclaration(id, superClass, classBody);\n  }\n  function parseClassExpression() {\n    var id = null,\n      superClass = null,\n      classNode = new Node(),\n      classBody,\n      previousStrict = strict;\n    strict = true;\n    expectKeyword('class');\n    if (lookahead.type === Token.Identifier) {\n      id = parseVariableIdentifier();\n    }\n    if (matchKeyword('extends')) {\n      lex();\n      superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n    }\n    classBody = parseClassBody();\n    strict = previousStrict;\n    return classNode.finishClassExpression(id, superClass, classBody);\n  }\n\n  // Modules grammar from:\n  // people.mozilla.org/~jorendorff/es6-draft.html\n\n  function parseModuleSpecifier() {\n    var node = new Node();\n    if (lookahead.type !== Token.StringLiteral) {\n      throwError(Messages.InvalidModuleSpecifier);\n    }\n    return node.finishLiteral(lex());\n  }\n  function parseExportSpecifier() {\n    var exported,\n      local,\n      node = new Node(),\n      def;\n    if (matchKeyword('default')) {\n      // export {default} from 'something';\n      def = new Node();\n      lex();\n      local = def.finishIdentifier('default');\n    } else {\n      local = parseVariableIdentifier();\n    }\n    if (matchContextualKeyword('as')) {\n      lex();\n      exported = parseNonComputedProperty();\n    }\n    return node.finishExportSpecifier(local, exported);\n  }\n  function parseExportNamedDeclaration(node) {\n    var declaration = null,\n      isExportFromIdentifier,\n      src = null,\n      specifiers = [];\n\n    // non-default export\n    if (lookahead.type === Token.Keyword) {\n      // covers:\n      // export var f = 1;\n      switch (lookahead.value) {\n        case 'let':\n        case 'const':\n        case 'var':\n        case 'class':\n        case 'function':\n          declaration = parseStatementListItem();\n          return node.finishExportNamedDeclaration(declaration, specifiers, null);\n      }\n    }\n    expect('{');\n    if (!match('}')) {\n      do {\n        isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n        specifiers.push(parseExportSpecifier());\n      } while (match(',') && lex());\n    }\n    expect('}');\n    if (matchContextualKeyword('from')) {\n      // covering:\n      // export {default} from 'foo';\n      // export {foo} from 'foo';\n      lex();\n      src = parseModuleSpecifier();\n      consumeSemicolon();\n    } else if (isExportFromIdentifier) {\n      // covering:\n      // export {default}; // missing fromClause\n      throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    } else {\n      // cover\n      // export {foo};\n      consumeSemicolon();\n    }\n    return node.finishExportNamedDeclaration(declaration, specifiers, src);\n  }\n  function parseExportDefaultDeclaration(node) {\n    var declaration = null,\n      expression = null;\n\n    // covers:\n    // export default ...\n    expectKeyword('default');\n    if (matchKeyword('function')) {\n      // covers:\n      // export default function foo () {}\n      // export default function () {}\n      declaration = parseFunctionDeclaration(new Node(), true);\n      return node.finishExportDefaultDeclaration(declaration);\n    }\n    if (matchKeyword('class')) {\n      declaration = parseClassDeclaration(true);\n      return node.finishExportDefaultDeclaration(declaration);\n    }\n    if (matchContextualKeyword('from')) {\n      throwError(Messages.UnexpectedToken, lookahead.value);\n    }\n\n    // covers:\n    // export default {};\n    // export default [];\n    // export default (1 + 2);\n    if (match('{')) {\n      expression = parseObjectInitialiser();\n    } else if (match('[')) {\n      expression = parseArrayInitialiser();\n    } else {\n      expression = parseAssignmentExpression();\n    }\n    consumeSemicolon();\n    return node.finishExportDefaultDeclaration(expression);\n  }\n  function parseExportAllDeclaration(node) {\n    var src;\n\n    // covers:\n    // export * from 'foo';\n    expect('*');\n    if (!matchContextualKeyword('from')) {\n      throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    }\n    lex();\n    src = parseModuleSpecifier();\n    consumeSemicolon();\n    return node.finishExportAllDeclaration(src);\n  }\n  function parseExportDeclaration() {\n    var node = new Node();\n    if (state.inFunctionBody) {\n      throwError(Messages.IllegalExportDeclaration);\n    }\n    expectKeyword('export');\n    if (matchKeyword('default')) {\n      return parseExportDefaultDeclaration(node);\n    }\n    if (match('*')) {\n      return parseExportAllDeclaration(node);\n    }\n    return parseExportNamedDeclaration(node);\n  }\n  function parseImportSpecifier() {\n    // import {<foo as bar>} ...;\n    var local,\n      imported,\n      node = new Node();\n    imported = parseNonComputedProperty();\n    if (matchContextualKeyword('as')) {\n      lex();\n      local = parseVariableIdentifier();\n    }\n    return node.finishImportSpecifier(local, imported);\n  }\n  function parseNamedImports() {\n    var specifiers = [];\n    // {foo, bar as bas}\n    expect('{');\n    if (!match('}')) {\n      do {\n        specifiers.push(parseImportSpecifier());\n      } while (match(',') && lex());\n    }\n    expect('}');\n    return specifiers;\n  }\n  function parseImportDefaultSpecifier() {\n    // import <foo> ...;\n    var local,\n      node = new Node();\n    local = parseNonComputedProperty();\n    return node.finishImportDefaultSpecifier(local);\n  }\n  function parseImportNamespaceSpecifier() {\n    // import <* as foo> ...;\n    var local,\n      node = new Node();\n    expect('*');\n    if (!matchContextualKeyword('as')) {\n      throwError(Messages.NoAsAfterImportNamespace);\n    }\n    lex();\n    local = parseNonComputedProperty();\n    return node.finishImportNamespaceSpecifier(local);\n  }\n  function parseImportDeclaration() {\n    var specifiers,\n      src,\n      node = new Node();\n    if (state.inFunctionBody) {\n      throwError(Messages.IllegalImportDeclaration);\n    }\n    expectKeyword('import');\n    specifiers = [];\n    if (lookahead.type === Token.StringLiteral) {\n      // covers:\n      // import 'foo';\n      src = parseModuleSpecifier();\n      consumeSemicolon();\n      return node.finishImportDeclaration(specifiers, src);\n    }\n    if (!matchKeyword('default') && isIdentifierName(lookahead)) {\n      // covers:\n      // import foo\n      // import foo, ...\n      specifiers.push(parseImportDefaultSpecifier());\n      if (match(',')) {\n        lex();\n      }\n    }\n    if (match('*')) {\n      // covers:\n      // import foo, * as foo\n      // import * as foo\n      specifiers.push(parseImportNamespaceSpecifier());\n    } else if (match('{')) {\n      // covers:\n      // import foo, {bar}\n      // import {bar}\n      specifiers = specifiers.concat(parseNamedImports());\n    }\n    if (!matchContextualKeyword('from')) {\n      throwError(lookahead.value ? Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n    }\n    lex();\n    src = parseModuleSpecifier();\n    consumeSemicolon();\n    return node.finishImportDeclaration(specifiers, src);\n  }\n\n  // 14 Program\n\n  function parseScriptBody() {\n    var statement,\n      body = [],\n      token,\n      directive,\n      firstRestricted;\n    while (startIndex < length) {\n      token = lookahead;\n      if (token.type !== Token.StringLiteral) {\n        break;\n      }\n      statement = parseStatementListItem();\n      body.push(statement);\n      if (statement.expression.type !== Syntax.Literal) {\n        // this is not directive\n        break;\n      }\n      directive = source.slice(token.start + 1, token.end - 1);\n      if (directive === 'use strict') {\n        strict = true;\n        if (firstRestricted) {\n          tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n        }\n      } else {\n        if (!firstRestricted && token.octal) {\n          firstRestricted = token;\n        }\n      }\n    }\n    while (startIndex < length) {\n      statement = parseStatementListItem();\n      /* istanbul ignore if */\n      if (typeof statement === 'undefined') {\n        break;\n      }\n      body.push(statement);\n    }\n    return body;\n  }\n  function parseProgram() {\n    var body, node;\n    peek();\n    node = new Node();\n    body = parseScriptBody();\n    return node.finishProgram(body);\n  }\n  function filterTokenLocation() {\n    var i,\n      entry,\n      token,\n      tokens = [];\n    for (i = 0; i < extra.tokens.length; ++i) {\n      entry = extra.tokens[i];\n      token = {\n        type: entry.type,\n        value: entry.value\n      };\n      if (entry.regex) {\n        token.regex = {\n          pattern: entry.regex.pattern,\n          flags: entry.regex.flags\n        };\n      }\n      if (extra.range) {\n        token.range = entry.range;\n      }\n      if (extra.loc) {\n        token.loc = entry.loc;\n      }\n      tokens.push(token);\n    }\n    extra.tokens = tokens;\n  }\n  function tokenize(code, options) {\n    var toString, tokens;\n    toString = String;\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1,\n      curlyStack: []\n    };\n    extra = {};\n\n    // Options matching.\n    options = options || {};\n\n    // Of course we collect tokens here.\n    options.tokens = true;\n    extra.tokens = [];\n    extra.tokenize = true;\n    // The following two fields are necessary to compute the Regex tokens.\n    extra.openParenToken = -1;\n    extra.openCurlyToken = -1;\n    extra.range = typeof options.range === 'boolean' && options.range;\n    extra.loc = typeof options.loc === 'boolean' && options.loc;\n    if (typeof options.comment === 'boolean' && options.comment) {\n      extra.comments = [];\n    }\n    if (typeof options.tolerant === 'boolean' && options.tolerant) {\n      extra.errors = [];\n    }\n    try {\n      peek();\n      if (lookahead.type === Token.EOF) {\n        return extra.tokens;\n      }\n      lex();\n      while (lookahead.type !== Token.EOF) {\n        try {\n          lex();\n        } catch (lexError) {\n          if (extra.errors) {\n            recordError(lexError);\n            // We have to break on the first error\n            // to avoid infinite loops.\n            break;\n          } else {\n            throw lexError;\n          }\n        }\n      }\n      filterTokenLocation();\n      tokens = extra.tokens;\n      if (typeof extra.comments !== 'undefined') {\n        tokens.comments = extra.comments;\n      }\n      if (typeof extra.errors !== 'undefined') {\n        tokens.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n    return tokens;\n  }\n  function parse(code, options) {\n    var program, toString;\n    toString = String;\n    if (typeof code !== 'string' && !(code instanceof String)) {\n      code = toString(code);\n    }\n    source = code;\n    index = 0;\n    lineNumber = source.length > 0 ? 1 : 0;\n    lineStart = 0;\n    startIndex = index;\n    startLineNumber = lineNumber;\n    startLineStart = lineStart;\n    length = source.length;\n    lookahead = null;\n    state = {\n      allowIn: true,\n      labelSet: {},\n      inFunctionBody: false,\n      inIteration: false,\n      inSwitch: false,\n      lastCommentStart: -1,\n      curlyStack: []\n    };\n    sourceType = 'script';\n    strict = false;\n    extra = {};\n    if (typeof options !== 'undefined') {\n      extra.range = typeof options.range === 'boolean' && options.range;\n      extra.loc = typeof options.loc === 'boolean' && options.loc;\n      extra.attachComment = typeof options.attachComment === 'boolean' && options.attachComment;\n      if (extra.loc && options.source !== null && options.source !== undefined) {\n        extra.source = toString(options.source);\n      }\n      if (typeof options.tokens === 'boolean' && options.tokens) {\n        extra.tokens = [];\n      }\n      if (typeof options.comment === 'boolean' && options.comment) {\n        extra.comments = [];\n      }\n      if (typeof options.tolerant === 'boolean' && options.tolerant) {\n        extra.errors = [];\n      }\n      if (extra.attachComment) {\n        extra.range = true;\n        extra.comments = [];\n        extra.bottomRightStack = [];\n        extra.trailingComments = [];\n        extra.leadingComments = [];\n      }\n      if (options.sourceType === 'module') {\n        // very restrictive condition for now\n        sourceType = options.sourceType;\n        strict = true;\n      }\n    }\n    try {\n      program = parseProgram();\n      if (typeof extra.comments !== 'undefined') {\n        program.comments = extra.comments;\n      }\n      if (typeof extra.tokens !== 'undefined') {\n        filterTokenLocation();\n        program.tokens = extra.tokens;\n      }\n      if (typeof extra.errors !== 'undefined') {\n        program.errors = extra.errors;\n      }\n    } catch (e) {\n      throw e;\n    } finally {\n      extra = {};\n    }\n    return program;\n  }\n\n  // Sync with *.json manifests.\n  exports.version = '2.2.0';\n  exports.tokenize = tokenize;\n  exports.parse = parse;\n\n  // Deep copy.\n  /* istanbul ignore next */\n  exports.Syntax = function () {\n    var name,\n      types = {};\n    if (typeof Object.create === 'function') {\n      types = Object.create(null);\n    }\n    for (name in Syntax) {\n      if (Syntax.hasOwnProperty(name)) {\n        types[name] = Syntax[name];\n      }\n    }\n    if (typeof Object.freeze === 'function') {\n      Object.freeze(types);\n    }\n    return types;\n  }();\n});\n/* vim: set sw=4 ts=4 et tw=80 : */","map":{"version":3,"names":["root","factory","define","amd","exports","esprima","Token","TokenName","FnExprTokens","Syntax","PlaceHolders","Messages","Regex","source","strict","sourceType","index","lineNumber","lineStart","hasLineTerminator","lastIndex","lastLineNumber","lastLineStart","startIndex","startLineNumber","startLineStart","scanning","length","lookahead","state","extra","isBindingElement","isAssignmentTarget","firstCoverInitializedNameError","BooleanLiteral","EOF","Identifier","Keyword","NullLiteral","NumericLiteral","Punctuator","StringLiteral","RegularExpression","Template","AssignmentExpression","AssignmentPattern","ArrayExpression","ArrayPattern","ArrowFunctionExpression","BlockStatement","BinaryExpression","BreakStatement","CallExpression","CatchClause","ClassBody","ClassDeclaration","ClassExpression","ConditionalExpression","ContinueStatement","DoWhileStatement","DebuggerStatement","EmptyStatement","ExportAllDeclaration","ExportDefaultDeclaration","ExportNamedDeclaration","ExportSpecifier","ExpressionStatement","ForStatement","ForInStatement","FunctionDeclaration","FunctionExpression","IfStatement","ImportDeclaration","ImportDefaultSpecifier","ImportNamespaceSpecifier","ImportSpecifier","Literal","LabeledStatement","LogicalExpression","MemberExpression","MethodDefinition","NewExpression","ObjectExpression","ObjectPattern","Program","Property","RestElement","ReturnStatement","SequenceExpression","SpreadElement","Super","SwitchCase","SwitchStatement","TaggedTemplateExpression","TemplateElement","TemplateLiteral","ThisExpression","ThrowStatement","TryStatement","UnaryExpression","UpdateExpression","VariableDeclaration","VariableDeclarator","WhileStatement","WithStatement","ArrowParameterPlaceHolder","UnexpectedToken","UnexpectedNumber","UnexpectedString","UnexpectedIdentifier","UnexpectedReserved","UnexpectedTemplate","UnexpectedEOS","NewlineAfterThrow","InvalidRegExp","UnterminatedRegExp","InvalidLHSInAssignment","InvalidLHSInForIn","MultipleDefaultsInSwitch","NoCatchOrFinally","UnknownLabel","Redeclaration","IllegalContinue","IllegalBreak","IllegalReturn","StrictModeWith","StrictCatchVariable","StrictVarName","StrictParamName","StrictParamDupe","StrictFunctionName","StrictOctalLiteral","StrictDelete","StrictLHSAssignment","StrictLHSPostfix","StrictLHSPrefix","StrictReservedWord","TemplateOctalLiteral","ParameterAfterRestParameter","DefaultRestParameter","ObjectPatternAsRestParameter","DuplicateProtoProperty","ConstructorSpecialMethod","DuplicateConstructor","StaticPrototype","MissingFromClause","NoAsAfterImportNamespace","InvalidModuleSpecifier","IllegalImportDeclaration","IllegalExportDeclaration","NonAsciiIdentifierStart","RegExp","NonAsciiIdentifierPart","assert","condition","message","Error","isDecimalDigit","ch","isHexDigit","indexOf","isOctalDigit","octalToDecimal","octal","code","isWhiteSpace","isLineTerminator","isIdentifierStart","test","String","fromCharCode","isIdentifierPart","isFutureReservedWord","id","isStrictModeReservedWord","isRestrictedWord","isKeyword","addComment","type","value","start","end","loc","comment","lastCommentStart","range","comments","push","attachComment","leadingComments","trailingComments","skipSingleLineComment","offset","line","column","charCodeAt","slice","skipMultiLineComment","tolerateUnexpectedToken","skipComment","scanHexEscape","prefix","i","len","toLowerCase","scanUnicodeCodePointEscape","cu1","cu2","throwUnexpectedToken","getEscapedIdentifier","substr","getIdentifier","scanIdentifier","scanPunctuator","token","str","tokenize","openParenToken","tokens","openCurlyToken","curlyStack","pop","scanHexLiteral","number","parseInt","scanBinaryLiteral","scanOctalLiteral","isImplicitOctalLiteral","scanNumericLiteral","parseFloat","scanStringLiteral","quote","unescaped","octToDec","scanTemplate","cooked","rawOffset","terminated","head","tail","restore","throwError","raw","testRegExp","pattern","flags","tmp","replace","$0","$1","e","exception","scanRegExpBody","classMarker","body","literal","scanRegExpFlags","scanRegExp","regex","collectRegex","pos","isIdentifierName","advanceSlash","prevToken","checkToken","advance","collectToken","entry","lex","peek","Position","SourceLocation","WrappingSourceLocation","startToken","Node","WrappingNode","prototype","processComment","lastChild","bottomRight","bottomRightStack","last","unshift","splice","undefined","finish","finishArrayExpression","elements","finishArrayPattern","finishArrowFunctionExpression","params","defaults","expression","generator","finishAssignmentExpression","operator","left","right","finishAssignmentPattern","finishBinaryExpression","finishBlockStatement","finishBreakStatement","label","finishCallExpression","callee","args","arguments","finishCatchClause","param","finishClassBody","finishClassDeclaration","superClass","finishClassExpression","finishConditionalExpression","consequent","alternate","finishContinueStatement","finishDebuggerStatement","finishDoWhileStatement","finishEmptyStatement","finishExpressionStatement","finishForStatement","init","update","finishForInStatement","each","finishFunctionDeclaration","finishFunctionExpression","finishIdentifier","name","finishIfStatement","finishLabeledStatement","finishLiteral","finishMemberExpression","accessor","object","property","computed","finishNewExpression","finishObjectExpression","properties","finishObjectPattern","finishPostfixExpression","argument","finishProgram","finishProperty","kind","key","method","shorthand","finishRestElement","finishReturnStatement","finishSequenceExpression","expressions","finishSpreadElement","finishSwitchCase","finishSuper","finishSwitchStatement","discriminant","cases","finishTaggedTemplateExpression","tag","quasi","finishTemplateElement","finishTemplateLiteral","quasis","finishThisExpression","finishThrowStatement","finishTryStatement","block","handler","finalizer","guardedHandlers","handlers","finishUnaryExpression","finishVariableDeclaration","declarations","finishLexicalDeclaration","finishVariableDeclarator","finishWhileStatement","finishWithStatement","finishExportSpecifier","local","exported","finishImportDefaultSpecifier","finishImportNamespaceSpecifier","finishExportNamedDeclaration","declaration","specifiers","src","finishExportDefaultDeclaration","finishExportAllDeclaration","finishImportSpecifier","imported","finishImportDeclaration","recordError","error","existing","errors","createError","description","messageFormat","msg","Array","call","whole","idx","tolerateError","unexpectedTokenError","expect","expectCommaSeparator","expectKeyword","keyword","match","matchKeyword","matchContextualKeyword","matchAssign","op","consumeSemicolon","isolateCoverGrammar","parser","oldIsBindingElement","oldIsAssignmentTarget","oldFirstCoverInitializedNameError","result","inheritCoverGrammar","parseArrayPattern","node","rest","restNode","parseVariableIdentifier","parsePatternWithDefault","parsePropertyPattern","parseAssignmentExpression","parseObjectPropertyKey","parseObjectPattern","parsePattern","parseArrayInitialiser","restSpread","parsePropertyFunction","paramInfo","previousStrict","parseFunctionSourceElements","firstRestricted","stricted","parsePropertyMethodFunction","parseParams","expr","lookaheadPropertyName","tryParseMethodDefinition","options","methodNode","defaultCount","paramSet","parseParam","checkProto","hasProto","parseObjectProperty","maybeMethod","parseObjectInitialiser","reinterpretExpressionAsPattern","parseTemplateElement","option","parseTemplateLiteral","parseExpression","parseGroupExpression","parseRestElement","parsePrimaryExpression","parseFunctionExpression","parseClassExpression","parseArguments","parseNonComputedProperty","parseNonComputedMember","parseComputedMember","parseNewExpression","parseLeftHandSideExpression","parseLeftHandSideExpressionAllowCall","previousAllowIn","allowIn","inFunctionBody","parsePostfixExpression","parseUnaryExpression","binaryPrecedence","prec","parseBinaryExpression","marker","markers","stack","parseConditionalExpression","parseConciseBody","checkPatternParam","validateParam","reinterpretAsCoverFormalsList","parseArrowFunctionExpression","list","parseStatementListItem","parseExportDeclaration","parseImportDeclaration","parseLexicalDeclaration","inFor","parseFunctionDeclaration","parseClassDeclaration","parseStatement","parseStatementList","parseBlock","parseVariableDeclaration","parseVariableDeclarationList","parseVariableStatement","parseLexicalBinding","parseBindingList","parseEmptyStatement","parseExpressionStatement","parseIfStatement","parseDoWhileStatement","oldInIteration","inIteration","parseWhileStatement","parseForStatement","initSeq","initStartToken","parseContinueStatement","Object","hasOwnProperty","labelSet","parseBreakStatement","inSwitch","parseReturnStatement","parseWithStatement","parseSwitchCase","statement","parseSwitchStatement","clause","oldInSwitch","defaultFound","parseThrowStatement","parseCatchClause","parseTryStatement","parseDebuggerStatement","labeledBody","directive","oldLabelSet","oldInFunctionBody","oldParenthesisCount","parenthesizedCount","def","identifierIsOptional","parseClassBody","classBody","isStatic","hasConstructor","toString","classNode","parseModuleSpecifier","parseExportSpecifier","parseExportNamedDeclaration","isExportFromIdentifier","parseExportDefaultDeclaration","parseExportAllDeclaration","parseImportSpecifier","parseNamedImports","parseImportDefaultSpecifier","parseImportNamespaceSpecifier","concat","parseScriptBody","parseProgram","filterTokenLocation","tolerant","lexError","parse","program","version","types","create","freeze"],"sources":["C:/Users/SashinTulsiram/Documents/Software/react-frontend-bulma/node_modules/svgo/node_modules/esprima/esprima.js"],"sourcesContent":["/*\n  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>\n  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>\n  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>\n  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>\n  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>\n  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>\n  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>\n  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>\n\n  Redistribution and use in source and binary forms, with or without\n  modification, are permitted provided that the following conditions are met:\n\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n\n  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\n  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n(function (root, factory) {\n    'use strict';\n\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js,\n    // Rhino, and plain browser loading.\n\n    /* istanbul ignore next */\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports !== 'undefined') {\n        factory(exports);\n    } else {\n        factory((root.esprima = {}));\n    }\n}(this, function (exports) {\n    'use strict';\n\n    var Token,\n        TokenName,\n        FnExprTokens,\n        Syntax,\n        PlaceHolders,\n        Messages,\n        Regex,\n        source,\n        strict,\n        sourceType,\n        index,\n        lineNumber,\n        lineStart,\n        hasLineTerminator,\n        lastIndex,\n        lastLineNumber,\n        lastLineStart,\n        startIndex,\n        startLineNumber,\n        startLineStart,\n        scanning,\n        length,\n        lookahead,\n        state,\n        extra,\n        isBindingElement,\n        isAssignmentTarget,\n        firstCoverInitializedNameError;\n\n    Token = {\n        BooleanLiteral: 1,\n        EOF: 2,\n        Identifier: 3,\n        Keyword: 4,\n        NullLiteral: 5,\n        NumericLiteral: 6,\n        Punctuator: 7,\n        StringLiteral: 8,\n        RegularExpression: 9,\n        Template: 10\n    };\n\n    TokenName = {};\n    TokenName[Token.BooleanLiteral] = 'Boolean';\n    TokenName[Token.EOF] = '<end>';\n    TokenName[Token.Identifier] = 'Identifier';\n    TokenName[Token.Keyword] = 'Keyword';\n    TokenName[Token.NullLiteral] = 'Null';\n    TokenName[Token.NumericLiteral] = 'Numeric';\n    TokenName[Token.Punctuator] = 'Punctuator';\n    TokenName[Token.StringLiteral] = 'String';\n    TokenName[Token.RegularExpression] = 'RegularExpression';\n    TokenName[Token.Template] = 'Template';\n\n    // A function following one of those tokens is an expression.\n    FnExprTokens = ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',\n                    'return', 'case', 'delete', 'throw', 'void',\n                    // assignment operators\n                    '=', '+=', '-=', '*=', '/=', '%=', '<<=', '>>=', '>>>=',\n                    '&=', '|=', '^=', ',',\n                    // binary/unary operators\n                    '+', '-', '*', '/', '%', '++', '--', '<<', '>>', '>>>', '&',\n                    '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',\n                    '<=', '<', '>', '!=', '!=='];\n\n    Syntax = {\n        AssignmentExpression: 'AssignmentExpression',\n        AssignmentPattern: 'AssignmentPattern',\n        ArrayExpression: 'ArrayExpression',\n        ArrayPattern: 'ArrayPattern',\n        ArrowFunctionExpression: 'ArrowFunctionExpression',\n        BlockStatement: 'BlockStatement',\n        BinaryExpression: 'BinaryExpression',\n        BreakStatement: 'BreakStatement',\n        CallExpression: 'CallExpression',\n        CatchClause: 'CatchClause',\n        ClassBody: 'ClassBody',\n        ClassDeclaration: 'ClassDeclaration',\n        ClassExpression: 'ClassExpression',\n        ConditionalExpression: 'ConditionalExpression',\n        ContinueStatement: 'ContinueStatement',\n        DoWhileStatement: 'DoWhileStatement',\n        DebuggerStatement: 'DebuggerStatement',\n        EmptyStatement: 'EmptyStatement',\n        ExportAllDeclaration: 'ExportAllDeclaration',\n        ExportDefaultDeclaration: 'ExportDefaultDeclaration',\n        ExportNamedDeclaration: 'ExportNamedDeclaration',\n        ExportSpecifier: 'ExportSpecifier',\n        ExpressionStatement: 'ExpressionStatement',\n        ForStatement: 'ForStatement',\n        ForInStatement: 'ForInStatement',\n        FunctionDeclaration: 'FunctionDeclaration',\n        FunctionExpression: 'FunctionExpression',\n        Identifier: 'Identifier',\n        IfStatement: 'IfStatement',\n        ImportDeclaration: 'ImportDeclaration',\n        ImportDefaultSpecifier: 'ImportDefaultSpecifier',\n        ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',\n        ImportSpecifier: 'ImportSpecifier',\n        Literal: 'Literal',\n        LabeledStatement: 'LabeledStatement',\n        LogicalExpression: 'LogicalExpression',\n        MemberExpression: 'MemberExpression',\n        MethodDefinition: 'MethodDefinition',\n        NewExpression: 'NewExpression',\n        ObjectExpression: 'ObjectExpression',\n        ObjectPattern: 'ObjectPattern',\n        Program: 'Program',\n        Property: 'Property',\n        RestElement: 'RestElement',\n        ReturnStatement: 'ReturnStatement',\n        SequenceExpression: 'SequenceExpression',\n        SpreadElement: 'SpreadElement',\n        Super: 'Super',\n        SwitchCase: 'SwitchCase',\n        SwitchStatement: 'SwitchStatement',\n        TaggedTemplateExpression: 'TaggedTemplateExpression',\n        TemplateElement: 'TemplateElement',\n        TemplateLiteral: 'TemplateLiteral',\n        ThisExpression: 'ThisExpression',\n        ThrowStatement: 'ThrowStatement',\n        TryStatement: 'TryStatement',\n        UnaryExpression: 'UnaryExpression',\n        UpdateExpression: 'UpdateExpression',\n        VariableDeclaration: 'VariableDeclaration',\n        VariableDeclarator: 'VariableDeclarator',\n        WhileStatement: 'WhileStatement',\n        WithStatement: 'WithStatement'\n    };\n\n    PlaceHolders = {\n        ArrowParameterPlaceHolder: 'ArrowParameterPlaceHolder'\n    };\n\n    // Error messages should be identical to V8.\n    Messages = {\n        UnexpectedToken: 'Unexpected token %0',\n        UnexpectedNumber: 'Unexpected number',\n        UnexpectedString: 'Unexpected string',\n        UnexpectedIdentifier: 'Unexpected identifier',\n        UnexpectedReserved: 'Unexpected reserved word',\n        UnexpectedTemplate: 'Unexpected quasi %0',\n        UnexpectedEOS: 'Unexpected end of input',\n        NewlineAfterThrow: 'Illegal newline after throw',\n        InvalidRegExp: 'Invalid regular expression',\n        UnterminatedRegExp: 'Invalid regular expression: missing /',\n        InvalidLHSInAssignment: 'Invalid left-hand side in assignment',\n        InvalidLHSInForIn: 'Invalid left-hand side in for-in',\n        MultipleDefaultsInSwitch: 'More than one default clause in switch statement',\n        NoCatchOrFinally: 'Missing catch or finally after try',\n        UnknownLabel: 'Undefined label \\'%0\\'',\n        Redeclaration: '%0 \\'%1\\' has already been declared',\n        IllegalContinue: 'Illegal continue statement',\n        IllegalBreak: 'Illegal break statement',\n        IllegalReturn: 'Illegal return statement',\n        StrictModeWith: 'Strict mode code may not include a with statement',\n        StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',\n        StrictVarName: 'Variable name may not be eval or arguments in strict mode',\n        StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',\n        StrictParamDupe: 'Strict mode function may not have duplicate parameter names',\n        StrictFunctionName: 'Function name may not be eval or arguments in strict mode',\n        StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',\n        StrictDelete: 'Delete of an unqualified identifier in strict mode.',\n        StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',\n        StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',\n        StrictReservedWord: 'Use of future reserved word in strict mode',\n        TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',\n        ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',\n        DefaultRestParameter: 'Unexpected token =',\n        ObjectPatternAsRestParameter: 'Unexpected token {',\n        DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',\n        ConstructorSpecialMethod: 'Class constructor may not be an accessor',\n        DuplicateConstructor: 'A class may only have one constructor',\n        StaticPrototype: 'Classes may not have static property named prototype',\n        MissingFromClause: 'Unexpected token',\n        NoAsAfterImportNamespace: 'Unexpected token',\n        InvalidModuleSpecifier: 'Unexpected token',\n        IllegalImportDeclaration: 'Unexpected token',\n        IllegalExportDeclaration: 'Unexpected token'\n    };\n\n    // See also tools/generate-unicode-regex.py.\n    Regex = {\n        NonAsciiIdentifierStart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),\n        NonAsciiIdentifierPart: new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]')\n    };\n\n    // Ensure the condition is true, otherwise throw an error.\n    // This is only to have a better contract semantic, i.e. another safety net\n    // to catch a logic error. The condition shall be fulfilled in normal case.\n    // Do NOT use this to enforce a certain condition on any user input.\n\n    function assert(condition, message) {\n        /* istanbul ignore if */\n        if (!condition) {\n            throw new Error('ASSERT: ' + message);\n        }\n    }\n\n    function isDecimalDigit(ch) {\n        return (ch >= 0x30 && ch <= 0x39);   // 0..9\n    }\n\n    function isHexDigit(ch) {\n        return '0123456789abcdefABCDEF'.indexOf(ch) >= 0;\n    }\n\n    function isOctalDigit(ch) {\n        return '01234567'.indexOf(ch) >= 0;\n    }\n\n    function octalToDecimal(ch) {\n        // \\0 is not octal escape sequence\n        var octal = (ch !== '0'), code = '01234567'.indexOf(ch);\n\n        if (index < length && isOctalDigit(source[index])) {\n            octal = true;\n            code = code * 8 + '01234567'.indexOf(source[index++]);\n\n            // 3 digits are only allowed when string starts\n            // with 0, 1, 2, 3\n            if ('0123'.indexOf(ch) >= 0 &&\n                    index < length &&\n                    isOctalDigit(source[index])) {\n                code = code * 8 + '01234567'.indexOf(source[index++]);\n            }\n        }\n\n        return {\n            code: code,\n            octal: octal\n        };\n    }\n\n    // 7.2 White Space\n\n    function isWhiteSpace(ch) {\n        return (ch === 0x20) || (ch === 0x09) || (ch === 0x0B) || (ch === 0x0C) || (ch === 0xA0) ||\n            (ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(ch) >= 0);\n    }\n\n    // 7.3 Line Terminators\n\n    function isLineTerminator(ch) {\n        return (ch === 0x0A) || (ch === 0x0D) || (ch === 0x2028) || (ch === 0x2029);\n    }\n\n    // 7.6 Identifier Names and Identifiers\n\n    function isIdentifierStart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierStart.test(String.fromCharCode(ch)));\n    }\n\n    function isIdentifierPart(ch) {\n        return (ch === 0x24) || (ch === 0x5F) ||  // $ (dollar) and _ (underscore)\n            (ch >= 0x41 && ch <= 0x5A) ||         // A..Z\n            (ch >= 0x61 && ch <= 0x7A) ||         // a..z\n            (ch >= 0x30 && ch <= 0x39) ||         // 0..9\n            (ch === 0x5C) ||                      // \\ (backslash)\n            ((ch >= 0x80) && Regex.NonAsciiIdentifierPart.test(String.fromCharCode(ch)));\n    }\n\n    // 7.6.1.2 Future Reserved Words\n\n    function isFutureReservedWord(id) {\n        switch (id) {\n        case 'enum':\n        case 'export':\n        case 'import':\n        case 'super':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    // 11.6.2.2 Future Reserved Words\n\n    function isStrictModeReservedWord(id) {\n        switch (id) {\n        case 'implements':\n        case 'interface':\n        case 'package':\n        case 'private':\n        case 'protected':\n        case 'public':\n        case 'static':\n        case 'yield':\n        case 'let':\n            return true;\n        default:\n            return false;\n        }\n    }\n\n    function isRestrictedWord(id) {\n        return id === 'eval' || id === 'arguments';\n    }\n\n    // 7.6.1.1 Keywords\n\n    function isKeyword(id) {\n\n        // 'const' is specialized as Keyword in V8.\n        // 'yield' and 'let' are for compatibility with SpiderMonkey and ES.next.\n        // Some others are from future reserved words.\n\n        switch (id.length) {\n        case 2:\n            return (id === 'if') || (id === 'in') || (id === 'do');\n        case 3:\n            return (id === 'var') || (id === 'for') || (id === 'new') ||\n                (id === 'try') || (id === 'let');\n        case 4:\n            return (id === 'this') || (id === 'else') || (id === 'case') ||\n                (id === 'void') || (id === 'with') || (id === 'enum');\n        case 5:\n            return (id === 'while') || (id === 'break') || (id === 'catch') ||\n                (id === 'throw') || (id === 'const') || (id === 'yield') ||\n                (id === 'class') || (id === 'super');\n        case 6:\n            return (id === 'return') || (id === 'typeof') || (id === 'delete') ||\n                (id === 'switch') || (id === 'export') || (id === 'import');\n        case 7:\n            return (id === 'default') || (id === 'finally') || (id === 'extends');\n        case 8:\n            return (id === 'function') || (id === 'continue') || (id === 'debugger');\n        case 10:\n            return (id === 'instanceof');\n        default:\n            return false;\n        }\n    }\n\n    // 7.4 Comments\n\n    function addComment(type, value, start, end, loc) {\n        var comment;\n\n        assert(typeof start === 'number', 'Comment must have valid position');\n\n        state.lastCommentStart = start;\n\n        comment = {\n            type: type,\n            value: value\n        };\n        if (extra.range) {\n            comment.range = [start, end];\n        }\n        if (extra.loc) {\n            comment.loc = loc;\n        }\n        extra.comments.push(comment);\n        if (extra.attachComment) {\n            extra.leadingComments.push(comment);\n            extra.trailingComments.push(comment);\n        }\n    }\n\n    function skipSingleLineComment(offset) {\n        var start, loc, ch, comment;\n\n        start = index - offset;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart - offset\n            }\n        };\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            ++index;\n            if (isLineTerminator(ch)) {\n                hasLineTerminator = true;\n                if (extra.comments) {\n                    comment = source.slice(start + offset, index - 1);\n                    loc.end = {\n                        line: lineNumber,\n                        column: index - lineStart - 1\n                    };\n                    addComment('Line', comment, start, index - 1, loc);\n                }\n                if (ch === 13 && source.charCodeAt(index) === 10) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                return;\n            }\n        }\n\n        if (extra.comments) {\n            comment = source.slice(start + offset, index);\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            addComment('Line', comment, start, index, loc);\n        }\n    }\n\n    function skipMultiLineComment() {\n        var start, loc, ch, comment;\n\n        if (extra.comments) {\n            start = index - 2;\n            loc = {\n                start: {\n                    line: lineNumber,\n                    column: index - lineStart - 2\n                }\n            };\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (isLineTerminator(ch)) {\n                if (ch === 0x0D && source.charCodeAt(index + 1) === 0x0A) {\n                    ++index;\n                }\n                hasLineTerminator = true;\n                ++lineNumber;\n                ++index;\n                lineStart = index;\n            } else if (ch === 0x2A) {\n                // Block comment ends with '*/'.\n                if (source.charCodeAt(index + 1) === 0x2F) {\n                    ++index;\n                    ++index;\n                    if (extra.comments) {\n                        comment = source.slice(start + 2, index - 2);\n                        loc.end = {\n                            line: lineNumber,\n                            column: index - lineStart\n                        };\n                        addComment('Block', comment, start, index, loc);\n                    }\n                    return;\n                }\n                ++index;\n            } else {\n                ++index;\n            }\n        }\n\n        // Ran off the end of the file - the whole thing is a comment\n        if (extra.comments) {\n            loc.end = {\n                line: lineNumber,\n                column: index - lineStart\n            };\n            comment = source.slice(start + 2, index);\n            addComment('Block', comment, start, index, loc);\n        }\n        tolerateUnexpectedToken();\n    }\n\n    function skipComment() {\n        var ch, start;\n        hasLineTerminator = false;\n\n        start = (index === 0);\n        while (index < length) {\n            ch = source.charCodeAt(index);\n\n            if (isWhiteSpace(ch)) {\n                ++index;\n            } else if (isLineTerminator(ch)) {\n                hasLineTerminator = true;\n                ++index;\n                if (ch === 0x0D && source.charCodeAt(index) === 0x0A) {\n                    ++index;\n                }\n                ++lineNumber;\n                lineStart = index;\n                start = true;\n            } else if (ch === 0x2F) { // U+002F is '/'\n                ch = source.charCodeAt(index + 1);\n                if (ch === 0x2F) {\n                    ++index;\n                    ++index;\n                    skipSingleLineComment(2);\n                    start = true;\n                } else if (ch === 0x2A) {  // U+002A is '*'\n                    ++index;\n                    ++index;\n                    skipMultiLineComment();\n                } else {\n                    break;\n                }\n            } else if (start && ch === 0x2D) { // U+002D is '-'\n                // U+003E is '>'\n                if ((source.charCodeAt(index + 1) === 0x2D) && (source.charCodeAt(index + 2) === 0x3E)) {\n                    // '-->' is a single-line comment\n                    index += 3;\n                    skipSingleLineComment(3);\n                } else {\n                    break;\n                }\n            } else if (ch === 0x3C) { // U+003C is '<'\n                if (source.slice(index + 1, index + 4) === '!--') {\n                    ++index; // `<`\n                    ++index; // `!`\n                    ++index; // `-`\n                    ++index; // `-`\n                    skipSingleLineComment(4);\n                } else {\n                    break;\n                }\n            } else {\n                break;\n            }\n        }\n    }\n\n    function scanHexEscape(prefix) {\n        var i, len, ch, code = 0;\n\n        len = (prefix === 'u') ? 4 : 2;\n        for (i = 0; i < len; ++i) {\n            if (index < length && isHexDigit(source[index])) {\n                ch = source[index++];\n                code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n            } else {\n                return '';\n            }\n        }\n        return String.fromCharCode(code);\n    }\n\n    function scanUnicodeCodePointEscape() {\n        var ch, code, cu1, cu2;\n\n        ch = source[index];\n        code = 0;\n\n        // At least, one hex digit is required.\n        if (ch === '}') {\n            throwUnexpectedToken();\n        }\n\n        while (index < length) {\n            ch = source[index++];\n            if (!isHexDigit(ch)) {\n                break;\n            }\n            code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());\n        }\n\n        if (code > 0x10FFFF || ch !== '}') {\n            throwUnexpectedToken();\n        }\n\n        // UTF-16 Encoding\n        if (code <= 0xFFFF) {\n            return String.fromCharCode(code);\n        }\n        cu1 = ((code - 0x10000) >> 10) + 0xD800;\n        cu2 = ((code - 0x10000) & 1023) + 0xDC00;\n        return String.fromCharCode(cu1, cu2);\n    }\n\n    function getEscapedIdentifier() {\n        var ch, id;\n\n        ch = source.charCodeAt(index++);\n        id = String.fromCharCode(ch);\n\n        // '\\u' (U+005C, U+0075) denotes an escaped character.\n        if (ch === 0x5C) {\n            if (source.charCodeAt(index) !== 0x75) {\n                throwUnexpectedToken();\n            }\n            ++index;\n            ch = scanHexEscape('u');\n            if (!ch || ch === '\\\\' || !isIdentifierStart(ch.charCodeAt(0))) {\n                throwUnexpectedToken();\n            }\n            id = ch;\n        }\n\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (!isIdentifierPart(ch)) {\n                break;\n            }\n            ++index;\n            id += String.fromCharCode(ch);\n\n            // '\\u' (U+005C, U+0075) denotes an escaped character.\n            if (ch === 0x5C) {\n                id = id.substr(0, id.length - 1);\n                if (source.charCodeAt(index) !== 0x75) {\n                    throwUnexpectedToken();\n                }\n                ++index;\n                ch = scanHexEscape('u');\n                if (!ch || ch === '\\\\' || !isIdentifierPart(ch.charCodeAt(0))) {\n                    throwUnexpectedToken();\n                }\n                id += ch;\n            }\n        }\n\n        return id;\n    }\n\n    function getIdentifier() {\n        var start, ch;\n\n        start = index++;\n        while (index < length) {\n            ch = source.charCodeAt(index);\n            if (ch === 0x5C) {\n                // Blackslash (U+005C) marks Unicode escape sequence.\n                index = start;\n                return getEscapedIdentifier();\n            }\n            if (isIdentifierPart(ch)) {\n                ++index;\n            } else {\n                break;\n            }\n        }\n\n        return source.slice(start, index);\n    }\n\n    function scanIdentifier() {\n        var start, id, type;\n\n        start = index;\n\n        // Backslash (U+005C) starts an escaped character.\n        id = (source.charCodeAt(index) === 0x5C) ? getEscapedIdentifier() : getIdentifier();\n\n        // There is no keyword or literal with only one character.\n        // Thus, it must be an identifier.\n        if (id.length === 1) {\n            type = Token.Identifier;\n        } else if (isKeyword(id)) {\n            type = Token.Keyword;\n        } else if (id === 'null') {\n            type = Token.NullLiteral;\n        } else if (id === 'true' || id === 'false') {\n            type = Token.BooleanLiteral;\n        } else {\n            type = Token.Identifier;\n        }\n\n        return {\n            type: type,\n            value: id,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n\n    // 7.7 Punctuators\n\n    function scanPunctuator() {\n        var token, str;\n\n        token = {\n            type: Token.Punctuator,\n            value: '',\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: index,\n            end: index\n        };\n\n        // Check for most common single-character punctuators.\n        str = source[index];\n        switch (str) {\n\n        case '(':\n            if (extra.tokenize) {\n                extra.openParenToken = extra.tokens.length;\n            }\n            ++index;\n            break;\n\n        case '{':\n            if (extra.tokenize) {\n                extra.openCurlyToken = extra.tokens.length;\n            }\n            state.curlyStack.push('{');\n            ++index;\n            break;\n\n        case '.':\n            ++index;\n            if (source[index] === '.' && source[index + 1] === '.') {\n                // Spread operator: ...\n                index += 2;\n                str = '...';\n            }\n            break;\n\n        case '}':\n            ++index;\n            state.curlyStack.pop();\n            break;\n        case ')':\n        case ';':\n        case ',':\n        case '[':\n        case ']':\n        case ':':\n        case '?':\n        case '~':\n            ++index;\n            break;\n\n        default:\n            // 4-character punctuator.\n            str = source.substr(index, 4);\n            if (str === '>>>=') {\n                index += 4;\n            } else {\n\n                // 3-character punctuators.\n                str = str.substr(0, 3);\n                if (str === '===' || str === '!==' || str === '>>>' ||\n                    str === '<<=' || str === '>>=') {\n                    index += 3;\n                } else {\n\n                    // 2-character punctuators.\n                    str = str.substr(0, 2);\n                    if (str === '&&' || str === '||' || str === '==' || str === '!=' ||\n                        str === '+=' || str === '-=' || str === '*=' || str === '/=' ||\n                        str === '++' || str === '--' || str === '<<' || str === '>>' ||\n                        str === '&=' || str === '|=' || str === '^=' || str === '%=' ||\n                        str === '<=' || str === '>=' || str === '=>') {\n                        index += 2;\n                    } else {\n\n                        // 1-character punctuators.\n                        str = source[index];\n                        if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {\n                            ++index;\n                        }\n                    }\n                }\n            }\n        }\n\n        if (index === token.start) {\n            throwUnexpectedToken();\n        }\n\n        token.end = index;\n        token.value = str;\n        return token;\n    }\n\n    // 7.8.3 Numeric Literals\n\n    function scanHexLiteral(start) {\n        var number = '';\n\n        while (index < length) {\n            if (!isHexDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt('0x' + number, 16),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanBinaryLiteral(start) {\n        var ch, number;\n\n        number = '';\n\n        while (index < length) {\n            ch = source[index];\n            if (ch !== '0' && ch !== '1') {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (number.length === 0) {\n            // only 0b or 0B\n            throwUnexpectedToken();\n        }\n\n        if (index < length) {\n            ch = source.charCodeAt(index);\n            /* istanbul ignore else */\n            if (isIdentifierStart(ch) || isDecimalDigit(ch)) {\n                throwUnexpectedToken();\n            }\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 2),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanOctalLiteral(prefix, start) {\n        var number, octal;\n\n        if (isOctalDigit(prefix)) {\n            octal = true;\n            number = '0' + source[index++];\n        } else {\n            octal = false;\n            ++index;\n            number = '';\n        }\n\n        while (index < length) {\n            if (!isOctalDigit(source[index])) {\n                break;\n            }\n            number += source[index++];\n        }\n\n        if (!octal && number.length === 0) {\n            // only 0o or 0O\n            throwUnexpectedToken();\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseInt(number, 8),\n            octal: octal,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function isImplicitOctalLiteral() {\n        var i, ch;\n\n        // Implicit octal, unless there is a non-octal digit.\n        // (Annex B.1.1 on Numeric Literals)\n        for (i = index + 1; i < length; ++i) {\n            ch = source[i];\n            if (ch === '8' || ch === '9') {\n                return false;\n            }\n            if (!isOctalDigit(ch)) {\n                return true;\n            }\n        }\n\n        return true;\n    }\n\n    function scanNumericLiteral() {\n        var number, start, ch;\n\n        ch = source[index];\n        assert(isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'),\n            'Numeric literal must start with a decimal digit or a decimal point');\n\n        start = index;\n        number = '';\n        if (ch !== '.') {\n            number = source[index++];\n            ch = source[index];\n\n            // Hex number starts with '0x'.\n            // Octal number starts with '0'.\n            // Octal number in ES6 starts with '0o'.\n            // Binary number in ES6 starts with '0b'.\n            if (number === '0') {\n                if (ch === 'x' || ch === 'X') {\n                    ++index;\n                    return scanHexLiteral(start);\n                }\n                if (ch === 'b' || ch === 'B') {\n                    ++index;\n                    return scanBinaryLiteral(start);\n                }\n                if (ch === 'o' || ch === 'O') {\n                    return scanOctalLiteral(ch, start);\n                }\n\n                if (isOctalDigit(ch)) {\n                    if (isImplicitOctalLiteral()) {\n                        return scanOctalLiteral(ch, start);\n                    }\n                }\n            }\n\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === '.') {\n            number += source[index++];\n            while (isDecimalDigit(source.charCodeAt(index))) {\n                number += source[index++];\n            }\n            ch = source[index];\n        }\n\n        if (ch === 'e' || ch === 'E') {\n            number += source[index++];\n\n            ch = source[index];\n            if (ch === '+' || ch === '-') {\n                number += source[index++];\n            }\n            if (isDecimalDigit(source.charCodeAt(index))) {\n                while (isDecimalDigit(source.charCodeAt(index))) {\n                    number += source[index++];\n                }\n            } else {\n                throwUnexpectedToken();\n            }\n        }\n\n        if (isIdentifierStart(source.charCodeAt(index))) {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.NumericLiteral,\n            value: parseFloat(number),\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    // 7.8.4 String Literals\n\n    function scanStringLiteral() {\n        var str = '', quote, start, ch, unescaped, octToDec, octal = false;\n\n        quote = source[index];\n        assert((quote === '\\'' || quote === '\"'),\n            'String literal must starts with a quote');\n\n        start = index;\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n\n            if (ch === quote) {\n                quote = '';\n                break;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!ch || !isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            str += scanUnicodeCodePointEscape();\n                        } else {\n                            unescaped = scanHexEscape(ch);\n                            if (!unescaped) {\n                                throw throwUnexpectedToken();\n                            }\n                            str += unescaped;\n                        }\n                        break;\n                    case 'n':\n                        str += '\\n';\n                        break;\n                    case 'r':\n                        str += '\\r';\n                        break;\n                    case 't':\n                        str += '\\t';\n                        break;\n                    case 'b':\n                        str += '\\b';\n                        break;\n                    case 'f':\n                        str += '\\f';\n                        break;\n                    case 'v':\n                        str += '\\x0B';\n                        break;\n                    case '8':\n                    case '9':\n                        throw throwUnexpectedToken();\n\n                    default:\n                        if (isOctalDigit(ch)) {\n                            octToDec = octalToDecimal(ch);\n\n                            octal = octToDec.octal || octal;\n                            str += String.fromCharCode(octToDec.code);\n                        } else {\n                            str += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                break;\n            } else {\n                str += ch;\n            }\n        }\n\n        if (quote !== '') {\n            throwUnexpectedToken();\n        }\n\n        return {\n            type: Token.StringLiteral,\n            value: str,\n            octal: octal,\n            lineNumber: startLineNumber,\n            lineStart: startLineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function scanTemplate() {\n        var cooked = '', ch, start, rawOffset, terminated, head, tail, restore, unescaped;\n\n        terminated = false;\n        tail = false;\n        start = index;\n        head = (source[index] === '`');\n        rawOffset = 2;\n\n        ++index;\n\n        while (index < length) {\n            ch = source[index++];\n            if (ch === '`') {\n                rawOffset = 1;\n                tail = true;\n                terminated = true;\n                break;\n            } else if (ch === '$') {\n                if (source[index] === '{') {\n                    state.curlyStack.push('${');\n                    ++index;\n                    terminated = true;\n                    break;\n                }\n                cooked += ch;\n            } else if (ch === '\\\\') {\n                ch = source[index++];\n                if (!isLineTerminator(ch.charCodeAt(0))) {\n                    switch (ch) {\n                    case 'n':\n                        cooked += '\\n';\n                        break;\n                    case 'r':\n                        cooked += '\\r';\n                        break;\n                    case 't':\n                        cooked += '\\t';\n                        break;\n                    case 'u':\n                    case 'x':\n                        if (source[index] === '{') {\n                            ++index;\n                            cooked += scanUnicodeCodePointEscape();\n                        } else {\n                            restore = index;\n                            unescaped = scanHexEscape(ch);\n                            if (unescaped) {\n                                cooked += unescaped;\n                            } else {\n                                index = restore;\n                                cooked += ch;\n                            }\n                        }\n                        break;\n                    case 'b':\n                        cooked += '\\b';\n                        break;\n                    case 'f':\n                        cooked += '\\f';\n                        break;\n                    case 'v':\n                        cooked += '\\v';\n                        break;\n\n                    default:\n                        if (ch === '0') {\n                            if (isDecimalDigit(source.charCodeAt(index))) {\n                                // Illegal: \\01 \\02 and so on\n                                throwError(Messages.TemplateOctalLiteral);\n                            }\n                            cooked += '\\0';\n                        } else if (isOctalDigit(ch)) {\n                            // Illegal: \\1 \\2\n                            throwError(Messages.TemplateOctalLiteral);\n                        } else {\n                            cooked += ch;\n                        }\n                        break;\n                    }\n                } else {\n                    ++lineNumber;\n                    if (ch === '\\r' && source[index] === '\\n') {\n                        ++index;\n                    }\n                    lineStart = index;\n                }\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                ++lineNumber;\n                if (ch === '\\r' && source[index] === '\\n') {\n                    ++index;\n                }\n                lineStart = index;\n                cooked += '\\n';\n            } else {\n                cooked += ch;\n            }\n        }\n\n        if (!terminated) {\n            throwUnexpectedToken();\n        }\n\n        if (!head) {\n            state.curlyStack.pop();\n        }\n\n        return {\n            type: Token.Template,\n            value: {\n                cooked: cooked,\n                raw: source.slice(start + 1, index - rawOffset)\n            },\n            head: head,\n            tail: tail,\n            lineNumber: lineNumber,\n            lineStart: lineStart,\n            start: start,\n            end: index\n        };\n    }\n\n    function testRegExp(pattern, flags) {\n        var tmp = pattern;\n\n        if (flags.indexOf('u') >= 0) {\n            // Replace each astral symbol and every Unicode escape sequence\n            // that possibly represents an astral symbol or a paired surrogate\n            // with a single ASCII symbol to avoid throwing on regular\n            // expressions that are only valid in combination with the `/u`\n            // flag.\n            // Note: replacing with the ASCII symbol `x` might cause false\n            // negatives in unlikely scenarios. For example, `[\\u{61}-b]` is a\n            // perfectly valid pattern that is equivalent to `[a-b]`, but it\n            // would be replaced by `[x-b]` which throws an error.\n            tmp = tmp\n                .replace(/\\\\u\\{([0-9a-fA-F]+)\\}/g, function ($0, $1) {\n                    if (parseInt($1, 16) <= 0x10FFFF) {\n                        return 'x';\n                    }\n                    throwUnexpectedToken(null, Messages.InvalidRegExp);\n                })\n                .replace(\n                    /\\\\u([a-fA-F0-9]{4})|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g,\n                    'x'\n                );\n        }\n\n        // First, detect invalid regular expressions.\n        try {\n            RegExp(tmp);\n        } catch (e) {\n            throwUnexpectedToken(null, Messages.InvalidRegExp);\n        }\n\n        // Return a regular expression object for this pattern-flag pair, or\n        // `null` in case the current environment doesn't support the flags it\n        // uses.\n        try {\n            return new RegExp(pattern, flags);\n        } catch (exception) {\n            return null;\n        }\n    }\n\n    function scanRegExpBody() {\n        var ch, str, classMarker, terminated, body;\n\n        ch = source[index];\n        assert(ch === '/', 'Regular expression literal must start with a slash');\n        str = source[index++];\n\n        classMarker = false;\n        terminated = false;\n        while (index < length) {\n            ch = source[index++];\n            str += ch;\n            if (ch === '\\\\') {\n                ch = source[index++];\n                // ECMA-262 7.8.5\n                if (isLineTerminator(ch.charCodeAt(0))) {\n                    throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n                }\n                str += ch;\n            } else if (isLineTerminator(ch.charCodeAt(0))) {\n                throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n            } else if (classMarker) {\n                if (ch === ']') {\n                    classMarker = false;\n                }\n            } else {\n                if (ch === '/') {\n                    terminated = true;\n                    break;\n                } else if (ch === '[') {\n                    classMarker = true;\n                }\n            }\n        }\n\n        if (!terminated) {\n            throwUnexpectedToken(null, Messages.UnterminatedRegExp);\n        }\n\n        // Exclude leading and trailing slash.\n        body = str.substr(1, str.length - 2);\n        return {\n            value: body,\n            literal: str\n        };\n    }\n\n    function scanRegExpFlags() {\n        var ch, str, flags, restore;\n\n        str = '';\n        flags = '';\n        while (index < length) {\n            ch = source[index];\n            if (!isIdentifierPart(ch.charCodeAt(0))) {\n                break;\n            }\n\n            ++index;\n            if (ch === '\\\\' && index < length) {\n                ch = source[index];\n                if (ch === 'u') {\n                    ++index;\n                    restore = index;\n                    ch = scanHexEscape('u');\n                    if (ch) {\n                        flags += ch;\n                        for (str += '\\\\u'; restore < index; ++restore) {\n                            str += source[restore];\n                        }\n                    } else {\n                        index = restore;\n                        flags += 'u';\n                        str += '\\\\u';\n                    }\n                    tolerateUnexpectedToken();\n                } else {\n                    str += '\\\\';\n                    tolerateUnexpectedToken();\n                }\n            } else {\n                flags += ch;\n                str += ch;\n            }\n        }\n\n        return {\n            value: flags,\n            literal: str\n        };\n    }\n\n    function scanRegExp() {\n        scanning = true;\n        var start, body, flags, value;\n\n        lookahead = null;\n        skipComment();\n        start = index;\n\n        body = scanRegExpBody();\n        flags = scanRegExpFlags();\n        value = testRegExp(body.value, flags.value);\n        scanning = false;\n        if (extra.tokenize) {\n            return {\n                type: Token.RegularExpression,\n                value: value,\n                regex: {\n                    pattern: body.value,\n                    flags: flags.value\n                },\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: start,\n                end: index\n            };\n        }\n\n        return {\n            literal: body.literal + flags.literal,\n            value: value,\n            regex: {\n                pattern: body.value,\n                flags: flags.value\n            },\n            start: start,\n            end: index\n        };\n    }\n\n    function collectRegex() {\n        var pos, loc, regex, token;\n\n        skipComment();\n\n        pos = index;\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        regex = scanRegExp();\n\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        /* istanbul ignore next */\n        if (!extra.tokenize) {\n            // Pop the previous token, which is likely '/' or '/='\n            if (extra.tokens.length > 0) {\n                token = extra.tokens[extra.tokens.length - 1];\n                if (token.range[0] === pos && token.type === 'Punctuator') {\n                    if (token.value === '/' || token.value === '/=') {\n                        extra.tokens.pop();\n                    }\n                }\n            }\n\n            extra.tokens.push({\n                type: 'RegularExpression',\n                value: regex.literal,\n                regex: regex.regex,\n                range: [pos, index],\n                loc: loc\n            });\n        }\n\n        return regex;\n    }\n\n    function isIdentifierName(token) {\n        return token.type === Token.Identifier ||\n            token.type === Token.Keyword ||\n            token.type === Token.BooleanLiteral ||\n            token.type === Token.NullLiteral;\n    }\n\n    function advanceSlash() {\n        var prevToken,\n            checkToken;\n        // Using the following algorithm:\n        // https://github.com/mozilla/sweet.js/wiki/design\n        prevToken = extra.tokens[extra.tokens.length - 1];\n        if (!prevToken) {\n            // Nothing before that: it cannot be a division.\n            return collectRegex();\n        }\n        if (prevToken.type === 'Punctuator') {\n            if (prevToken.value === ']') {\n                return scanPunctuator();\n            }\n            if (prevToken.value === ')') {\n                checkToken = extra.tokens[extra.openParenToken - 1];\n                if (checkToken &&\n                        checkToken.type === 'Keyword' &&\n                        (checkToken.value === 'if' ||\n                         checkToken.value === 'while' ||\n                         checkToken.value === 'for' ||\n                         checkToken.value === 'with')) {\n                    return collectRegex();\n                }\n                return scanPunctuator();\n            }\n            if (prevToken.value === '}') {\n                // Dividing a function by anything makes little sense,\n                // but we have to check for that.\n                if (extra.tokens[extra.openCurlyToken - 3] &&\n                        extra.tokens[extra.openCurlyToken - 3].type === 'Keyword') {\n                    // Anonymous function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 4];\n                    if (!checkToken) {\n                        return scanPunctuator();\n                    }\n                } else if (extra.tokens[extra.openCurlyToken - 4] &&\n                        extra.tokens[extra.openCurlyToken - 4].type === 'Keyword') {\n                    // Named function.\n                    checkToken = extra.tokens[extra.openCurlyToken - 5];\n                    if (!checkToken) {\n                        return collectRegex();\n                    }\n                } else {\n                    return scanPunctuator();\n                }\n                // checkToken determines whether the function is\n                // a declaration or an expression.\n                if (FnExprTokens.indexOf(checkToken.value) >= 0) {\n                    // It is an expression.\n                    return scanPunctuator();\n                }\n                // It is a declaration.\n                return collectRegex();\n            }\n            return collectRegex();\n        }\n        if (prevToken.type === 'Keyword' && prevToken.value !== 'this') {\n            return collectRegex();\n        }\n        return scanPunctuator();\n    }\n\n    function advance() {\n        var ch, token;\n\n        if (index >= length) {\n            return {\n                type: Token.EOF,\n                lineNumber: lineNumber,\n                lineStart: lineStart,\n                start: index,\n                end: index\n            };\n        }\n\n        ch = source.charCodeAt(index);\n\n        if (isIdentifierStart(ch)) {\n            token = scanIdentifier();\n            if (strict && isStrictModeReservedWord(token.value)) {\n                token.type = Token.Keyword;\n            }\n            return token;\n        }\n\n        // Very common: ( and ) and ;\n        if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {\n            return scanPunctuator();\n        }\n\n        // String literal starts with single quote (U+0027) or double quote (U+0022).\n        if (ch === 0x27 || ch === 0x22) {\n            return scanStringLiteral();\n        }\n\n        // Dot (.) U+002E can also start a floating-point number, hence the need\n        // to check the next character.\n        if (ch === 0x2E) {\n            if (isDecimalDigit(source.charCodeAt(index + 1))) {\n                return scanNumericLiteral();\n            }\n            return scanPunctuator();\n        }\n\n        if (isDecimalDigit(ch)) {\n            return scanNumericLiteral();\n        }\n\n        // Slash (/) U+002F can also start a regex.\n        if (extra.tokenize && ch === 0x2F) {\n            return advanceSlash();\n        }\n\n        // Template literals start with ` (U+0060) for template head\n        // or } (U+007D) for template middle or template tail.\n        if (ch === 0x60 || (ch === 0x7D && state.curlyStack[state.curlyStack.length - 1] === '${')) {\n            return scanTemplate();\n        }\n\n        return scanPunctuator();\n    }\n\n    function collectToken() {\n        var loc, token, value, entry;\n\n        loc = {\n            start: {\n                line: lineNumber,\n                column: index - lineStart\n            }\n        };\n\n        token = advance();\n        loc.end = {\n            line: lineNumber,\n            column: index - lineStart\n        };\n\n        if (token.type !== Token.EOF) {\n            value = source.slice(token.start, token.end);\n            entry = {\n                type: TokenName[token.type],\n                value: value,\n                range: [token.start, token.end],\n                loc: loc\n            };\n            if (token.regex) {\n                entry.regex = {\n                    pattern: token.regex.pattern,\n                    flags: token.regex.flags\n                };\n            }\n            extra.tokens.push(entry);\n        }\n\n        return token;\n    }\n\n    function lex() {\n        var token;\n        scanning = true;\n\n        lastIndex = index;\n        lastLineNumber = lineNumber;\n        lastLineStart = lineStart;\n\n        skipComment();\n\n        token = lookahead;\n\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        scanning = false;\n        return token;\n    }\n\n    function peek() {\n        scanning = true;\n\n        skipComment();\n\n        lastIndex = index;\n        lastLineNumber = lineNumber;\n        lastLineStart = lineStart;\n\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n\n        lookahead = (typeof extra.tokens !== 'undefined') ? collectToken() : advance();\n        scanning = false;\n    }\n\n    function Position() {\n        this.line = startLineNumber;\n        this.column = startIndex - startLineStart;\n    }\n\n    function SourceLocation() {\n        this.start = new Position();\n        this.end = null;\n    }\n\n    function WrappingSourceLocation(startToken) {\n        this.start = {\n            line: startToken.lineNumber,\n            column: startToken.start - startToken.lineStart\n        };\n        this.end = null;\n    }\n\n    function Node() {\n        if (extra.range) {\n            this.range = [startIndex, 0];\n        }\n        if (extra.loc) {\n            this.loc = new SourceLocation();\n        }\n    }\n\n    function WrappingNode(startToken) {\n        if (extra.range) {\n            this.range = [startToken.start, 0];\n        }\n        if (extra.loc) {\n            this.loc = new WrappingSourceLocation(startToken);\n        }\n    }\n\n    WrappingNode.prototype = Node.prototype = {\n\n        processComment: function () {\n            var lastChild,\n                leadingComments,\n                trailingComments,\n                bottomRight = extra.bottomRightStack,\n                i,\n                comment,\n                last = bottomRight[bottomRight.length - 1];\n\n            if (this.type === Syntax.Program) {\n                if (this.body.length > 0) {\n                    return;\n                }\n            }\n\n            if (extra.trailingComments.length > 0) {\n                trailingComments = [];\n                for (i = extra.trailingComments.length - 1; i >= 0; --i) {\n                    comment = extra.trailingComments[i];\n                    if (comment.range[0] >= this.range[1]) {\n                        trailingComments.unshift(comment);\n                        extra.trailingComments.splice(i, 1);\n                    }\n                }\n                extra.trailingComments = [];\n            } else {\n                if (last && last.trailingComments && last.trailingComments[0].range[0] >= this.range[1]) {\n                    trailingComments = last.trailingComments;\n                    delete last.trailingComments;\n                }\n            }\n\n            // Eating the stack.\n            if (last) {\n                while (last && last.range[0] >= this.range[0]) {\n                    lastChild = last;\n                    last = bottomRight.pop();\n                }\n            }\n\n            if (lastChild) {\n                if (lastChild.leadingComments && lastChild.leadingComments[lastChild.leadingComments.length - 1].range[1] <= this.range[0]) {\n                    this.leadingComments = lastChild.leadingComments;\n                    lastChild.leadingComments = undefined;\n                }\n            } else if (extra.leadingComments.length > 0) {\n                leadingComments = [];\n                for (i = extra.leadingComments.length - 1; i >= 0; --i) {\n                    comment = extra.leadingComments[i];\n                    if (comment.range[1] <= this.range[0]) {\n                        leadingComments.unshift(comment);\n                        extra.leadingComments.splice(i, 1);\n                    }\n                }\n            }\n\n\n            if (leadingComments && leadingComments.length > 0) {\n                this.leadingComments = leadingComments;\n            }\n            if (trailingComments && trailingComments.length > 0) {\n                this.trailingComments = trailingComments;\n            }\n\n            bottomRight.push(this);\n        },\n\n        finish: function () {\n            if (extra.range) {\n                this.range[1] = lastIndex;\n            }\n            if (extra.loc) {\n                this.loc.end = {\n                    line: lastLineNumber,\n                    column: lastIndex - lastLineStart\n                };\n                if (extra.source) {\n                    this.loc.source = extra.source;\n                }\n            }\n\n            if (extra.attachComment) {\n                this.processComment();\n            }\n        },\n\n        finishArrayExpression: function (elements) {\n            this.type = Syntax.ArrayExpression;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrayPattern: function (elements) {\n            this.type = Syntax.ArrayPattern;\n            this.elements = elements;\n            this.finish();\n            return this;\n        },\n\n        finishArrowFunctionExpression: function (params, defaults, body, expression) {\n            this.type = Syntax.ArrowFunctionExpression;\n            this.id = null;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = false;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentExpression: function (operator, left, right) {\n            this.type = Syntax.AssignmentExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishAssignmentPattern: function (left, right) {\n            this.type = Syntax.AssignmentPattern;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBinaryExpression: function (operator, left, right) {\n            this.type = (operator === '||' || operator === '&&') ? Syntax.LogicalExpression : Syntax.BinaryExpression;\n            this.operator = operator;\n            this.left = left;\n            this.right = right;\n            this.finish();\n            return this;\n        },\n\n        finishBlockStatement: function (body) {\n            this.type = Syntax.BlockStatement;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishBreakStatement: function (label) {\n            this.type = Syntax.BreakStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishCallExpression: function (callee, args) {\n            this.type = Syntax.CallExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishCatchClause: function (param, body) {\n            this.type = Syntax.CatchClause;\n            this.param = param;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassBody: function (body) {\n            this.type = Syntax.ClassBody;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassDeclaration: function (id, superClass, body) {\n            this.type = Syntax.ClassDeclaration;\n            this.id = id;\n            this.superClass = superClass;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishClassExpression: function (id, superClass, body) {\n            this.type = Syntax.ClassExpression;\n            this.id = id;\n            this.superClass = superClass;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishConditionalExpression: function (test, consequent, alternate) {\n            this.type = Syntax.ConditionalExpression;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishContinueStatement: function (label) {\n            this.type = Syntax.ContinueStatement;\n            this.label = label;\n            this.finish();\n            return this;\n        },\n\n        finishDebuggerStatement: function () {\n            this.type = Syntax.DebuggerStatement;\n            this.finish();\n            return this;\n        },\n\n        finishDoWhileStatement: function (body, test) {\n            this.type = Syntax.DoWhileStatement;\n            this.body = body;\n            this.test = test;\n            this.finish();\n            return this;\n        },\n\n        finishEmptyStatement: function () {\n            this.type = Syntax.EmptyStatement;\n            this.finish();\n            return this;\n        },\n\n        finishExpressionStatement: function (expression) {\n            this.type = Syntax.ExpressionStatement;\n            this.expression = expression;\n            this.finish();\n            return this;\n        },\n\n        finishForStatement: function (init, test, update, body) {\n            this.type = Syntax.ForStatement;\n            this.init = init;\n            this.test = test;\n            this.update = update;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishForInStatement: function (left, right, body) {\n            this.type = Syntax.ForInStatement;\n            this.left = left;\n            this.right = right;\n            this.body = body;\n            this.each = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionDeclaration: function (id, params, defaults, body) {\n            this.type = Syntax.FunctionDeclaration;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = false;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishFunctionExpression: function (id, params, defaults, body) {\n            this.type = Syntax.FunctionExpression;\n            this.id = id;\n            this.params = params;\n            this.defaults = defaults;\n            this.body = body;\n            this.generator = false;\n            this.expression = false;\n            this.finish();\n            return this;\n        },\n\n        finishIdentifier: function (name) {\n            this.type = Syntax.Identifier;\n            this.name = name;\n            this.finish();\n            return this;\n        },\n\n        finishIfStatement: function (test, consequent, alternate) {\n            this.type = Syntax.IfStatement;\n            this.test = test;\n            this.consequent = consequent;\n            this.alternate = alternate;\n            this.finish();\n            return this;\n        },\n\n        finishLabeledStatement: function (label, body) {\n            this.type = Syntax.LabeledStatement;\n            this.label = label;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishLiteral: function (token) {\n            this.type = Syntax.Literal;\n            this.value = token.value;\n            this.raw = source.slice(token.start, token.end);\n            if (token.regex) {\n                this.regex = token.regex;\n            }\n            this.finish();\n            return this;\n        },\n\n        finishMemberExpression: function (accessor, object, property) {\n            this.type = Syntax.MemberExpression;\n            this.computed = accessor === '[';\n            this.object = object;\n            this.property = property;\n            this.finish();\n            return this;\n        },\n\n        finishNewExpression: function (callee, args) {\n            this.type = Syntax.NewExpression;\n            this.callee = callee;\n            this.arguments = args;\n            this.finish();\n            return this;\n        },\n\n        finishObjectExpression: function (properties) {\n            this.type = Syntax.ObjectExpression;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishObjectPattern: function (properties) {\n            this.type = Syntax.ObjectPattern;\n            this.properties = properties;\n            this.finish();\n            return this;\n        },\n\n        finishPostfixExpression: function (operator, argument) {\n            this.type = Syntax.UpdateExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = false;\n            this.finish();\n            return this;\n        },\n\n        finishProgram: function (body) {\n            this.type = Syntax.Program;\n            this.body = body;\n            if (sourceType === 'module') {\n                // very restrictive for now\n                this.sourceType = sourceType;\n            }\n            this.finish();\n            return this;\n        },\n\n        finishProperty: function (kind, key, computed, value, method, shorthand) {\n            this.type = Syntax.Property;\n            this.key = key;\n            this.computed = computed;\n            this.value = value;\n            this.kind = kind;\n            this.method = method;\n            this.shorthand = shorthand;\n            this.finish();\n            return this;\n        },\n\n        finishRestElement: function (argument) {\n            this.type = Syntax.RestElement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishReturnStatement: function (argument) {\n            this.type = Syntax.ReturnStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSequenceExpression: function (expressions) {\n            this.type = Syntax.SequenceExpression;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishSpreadElement: function (argument) {\n            this.type = Syntax.SpreadElement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchCase: function (test, consequent) {\n            this.type = Syntax.SwitchCase;\n            this.test = test;\n            this.consequent = consequent;\n            this.finish();\n            return this;\n        },\n\n        finishSuper: function () {\n            this.type = Syntax.Super;\n            this.finish();\n            return this;\n        },\n\n        finishSwitchStatement: function (discriminant, cases) {\n            this.type = Syntax.SwitchStatement;\n            this.discriminant = discriminant;\n            this.cases = cases;\n            this.finish();\n            return this;\n        },\n\n        finishTaggedTemplateExpression: function (tag, quasi) {\n            this.type = Syntax.TaggedTemplateExpression;\n            this.tag = tag;\n            this.quasi = quasi;\n            this.finish();\n            return this;\n        },\n\n        finishTemplateElement: function (value, tail) {\n            this.type = Syntax.TemplateElement;\n            this.value = value;\n            this.tail = tail;\n            this.finish();\n            return this;\n        },\n\n        finishTemplateLiteral: function (quasis, expressions) {\n            this.type = Syntax.TemplateLiteral;\n            this.quasis = quasis;\n            this.expressions = expressions;\n            this.finish();\n            return this;\n        },\n\n        finishThisExpression: function () {\n            this.type = Syntax.ThisExpression;\n            this.finish();\n            return this;\n        },\n\n        finishThrowStatement: function (argument) {\n            this.type = Syntax.ThrowStatement;\n            this.argument = argument;\n            this.finish();\n            return this;\n        },\n\n        finishTryStatement: function (block, handler, finalizer) {\n            this.type = Syntax.TryStatement;\n            this.block = block;\n            this.guardedHandlers = [];\n            this.handlers = handler ? [ handler ] : [];\n            this.handler = handler;\n            this.finalizer = finalizer;\n            this.finish();\n            return this;\n        },\n\n        finishUnaryExpression: function (operator, argument) {\n            this.type = (operator === '++' || operator === '--') ? Syntax.UpdateExpression : Syntax.UnaryExpression;\n            this.operator = operator;\n            this.argument = argument;\n            this.prefix = true;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclaration: function (declarations) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = 'var';\n            this.finish();\n            return this;\n        },\n\n        finishLexicalDeclaration: function (declarations, kind) {\n            this.type = Syntax.VariableDeclaration;\n            this.declarations = declarations;\n            this.kind = kind;\n            this.finish();\n            return this;\n        },\n\n        finishVariableDeclarator: function (id, init) {\n            this.type = Syntax.VariableDeclarator;\n            this.id = id;\n            this.init = init;\n            this.finish();\n            return this;\n        },\n\n        finishWhileStatement: function (test, body) {\n            this.type = Syntax.WhileStatement;\n            this.test = test;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishWithStatement: function (object, body) {\n            this.type = Syntax.WithStatement;\n            this.object = object;\n            this.body = body;\n            this.finish();\n            return this;\n        },\n\n        finishExportSpecifier: function (local, exported) {\n            this.type = Syntax.ExportSpecifier;\n            this.exported = exported || local;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishImportDefaultSpecifier: function (local) {\n            this.type = Syntax.ImportDefaultSpecifier;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishImportNamespaceSpecifier: function (local) {\n            this.type = Syntax.ImportNamespaceSpecifier;\n            this.local = local;\n            this.finish();\n            return this;\n        },\n\n        finishExportNamedDeclaration: function (declaration, specifiers, src) {\n            this.type = Syntax.ExportNamedDeclaration;\n            this.declaration = declaration;\n            this.specifiers = specifiers;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishExportDefaultDeclaration: function (declaration) {\n            this.type = Syntax.ExportDefaultDeclaration;\n            this.declaration = declaration;\n            this.finish();\n            return this;\n        },\n\n        finishExportAllDeclaration: function (src) {\n            this.type = Syntax.ExportAllDeclaration;\n            this.source = src;\n            this.finish();\n            return this;\n        },\n\n        finishImportSpecifier: function (local, imported) {\n            this.type = Syntax.ImportSpecifier;\n            this.local = local || imported;\n            this.imported = imported;\n            this.finish();\n            return this;\n        },\n\n        finishImportDeclaration: function (specifiers, src) {\n            this.type = Syntax.ImportDeclaration;\n            this.specifiers = specifiers;\n            this.source = src;\n            this.finish();\n            return this;\n        }\n    };\n\n\n    function recordError(error) {\n        var e, existing;\n\n        for (e = 0; e < extra.errors.length; e++) {\n            existing = extra.errors[e];\n            // Prevent duplicated error.\n            /* istanbul ignore next */\n            if (existing.index === error.index && existing.message === error.message) {\n                return;\n            }\n        }\n\n        extra.errors.push(error);\n    }\n\n    function createError(line, pos, description) {\n        var error = new Error('Line ' + line + ': ' + description);\n        error.index = pos;\n        error.lineNumber = line;\n        error.column = pos - (scanning ? lineStart : lastLineStart) + 1;\n        error.description = description;\n        return error;\n    }\n\n    // Throw an exception\n\n    function throwError(messageFormat) {\n        var args, msg;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        throw createError(lastLineNumber, lastIndex, msg);\n    }\n\n    function tolerateError(messageFormat) {\n        var args, msg, error;\n\n        args = Array.prototype.slice.call(arguments, 1);\n        /* istanbul ignore next */\n        msg = messageFormat.replace(/%(\\d)/g,\n            function (whole, idx) {\n                assert(idx < args.length, 'Message reference must be in range');\n                return args[idx];\n            }\n        );\n\n        error = createError(lineNumber, lastIndex, msg);\n        if (extra.errors) {\n            recordError(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Throw an exception because of the token.\n\n    function unexpectedTokenError(token, message) {\n        var value, msg = message || Messages.UnexpectedToken;\n\n        if (token) {\n            if (!message) {\n                msg = (token.type === Token.EOF) ? Messages.UnexpectedEOS :\n                    (token.type === Token.Identifier) ? Messages.UnexpectedIdentifier :\n                    (token.type === Token.NumericLiteral) ? Messages.UnexpectedNumber :\n                    (token.type === Token.StringLiteral) ? Messages.UnexpectedString :\n                    (token.type === Token.Template) ? Messages.UnexpectedTemplate :\n                    Messages.UnexpectedToken;\n\n                if (token.type === Token.Keyword) {\n                    if (isFutureReservedWord(token.value)) {\n                        msg = Messages.UnexpectedReserved;\n                    } else if (strict && isStrictModeReservedWord(token.value)) {\n                        msg = Messages.StrictReservedWord;\n                    }\n                }\n            }\n\n            value = (token.type === Token.Template) ? token.value.raw : token.value;\n        } else {\n            value = 'ILLEGAL';\n        }\n\n        msg = msg.replace('%0', value);\n\n        return (token && typeof token.lineNumber === 'number') ?\n            createError(token.lineNumber, token.start, msg) :\n            createError(scanning ? lineNumber : lastLineNumber, scanning ? index : lastIndex, msg);\n    }\n\n    function throwUnexpectedToken(token, message) {\n        throw unexpectedTokenError(token, message);\n    }\n\n    function tolerateUnexpectedToken(token, message) {\n        var error = unexpectedTokenError(token, message);\n        if (extra.errors) {\n            recordError(error);\n        } else {\n            throw error;\n        }\n    }\n\n    // Expect the next token to match the specified punctuator.\n    // If not, an exception will be thrown.\n\n    function expect(value) {\n        var token = lex();\n        if (token.type !== Token.Punctuator || token.value !== value) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    /**\n     * @name expectCommaSeparator\n     * @description Quietly expect a comma when in tolerant mode, otherwise delegates\n     * to <code>expect(value)</code>\n     * @since 2.0\n     */\n    function expectCommaSeparator() {\n        var token;\n\n        if (extra.errors) {\n            token = lookahead;\n            if (token.type === Token.Punctuator && token.value === ',') {\n                lex();\n            } else if (token.type === Token.Punctuator && token.value === ';') {\n                lex();\n                tolerateUnexpectedToken(token);\n            } else {\n                tolerateUnexpectedToken(token, Messages.UnexpectedToken);\n            }\n        } else {\n            expect(',');\n        }\n    }\n\n    // Expect the next token to match the specified keyword.\n    // If not, an exception will be thrown.\n\n    function expectKeyword(keyword) {\n        var token = lex();\n        if (token.type !== Token.Keyword || token.value !== keyword) {\n            throwUnexpectedToken(token);\n        }\n    }\n\n    // Return true if the next token matches the specified punctuator.\n\n    function match(value) {\n        return lookahead.type === Token.Punctuator && lookahead.value === value;\n    }\n\n    // Return true if the next token matches the specified keyword\n\n    function matchKeyword(keyword) {\n        return lookahead.type === Token.Keyword && lookahead.value === keyword;\n    }\n\n    // Return true if the next token matches the specified contextual keyword\n    // (where an identifier is sometimes a keyword depending on the context)\n\n    function matchContextualKeyword(keyword) {\n        return lookahead.type === Token.Identifier && lookahead.value === keyword;\n    }\n\n    // Return true if the next token is an assignment operator\n\n    function matchAssign() {\n        var op;\n\n        if (lookahead.type !== Token.Punctuator) {\n            return false;\n        }\n        op = lookahead.value;\n        return op === '=' ||\n            op === '*=' ||\n            op === '/=' ||\n            op === '%=' ||\n            op === '+=' ||\n            op === '-=' ||\n            op === '<<=' ||\n            op === '>>=' ||\n            op === '>>>=' ||\n            op === '&=' ||\n            op === '^=' ||\n            op === '|=';\n    }\n\n    function consumeSemicolon() {\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(startIndex) === 0x3B || match(';')) {\n            lex();\n            return;\n        }\n\n        if (hasLineTerminator) {\n            return;\n        }\n\n        // FIXME(ikarienator): this is seemingly an issue in the previous location info convention.\n        lastIndex = startIndex;\n        lastLineNumber = startLineNumber;\n        lastLineStart = startLineStart;\n\n        if (lookahead.type !== Token.EOF && !match('}')) {\n            throwUnexpectedToken(lookahead);\n        }\n    }\n\n    // Cover grammar support.\n    //\n    // When an assignment expression position starts with an left parenthesis, the determination of the type\n    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)\n    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.\n    //\n    // There are three productions that can be parsed in a parentheses pair that needs to be determined\n    // after the outermost pair is closed. They are:\n    //\n    //   1. AssignmentExpression\n    //   2. BindingElements\n    //   3. AssignmentTargets\n    //\n    // In order to avoid exponential backtracking, we use two flags to denote if the production can be\n    // binding element or assignment target.\n    //\n    // The three productions have the relationship:\n    //\n    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression\n    //\n    // with a single exception that CoverInitializedName when used directly in an Expression, generates\n    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the\n    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.\n    //\n    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not\n    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore\n    // the CoverInitializedName check is conducted.\n    //\n    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates\n    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential\n    // pattern. The CoverInitializedName check is deferred.\n    function isolateCoverGrammar(parser) {\n        var oldIsBindingElement = isBindingElement,\n            oldIsAssignmentTarget = isAssignmentTarget,\n            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n            result;\n        isBindingElement = true;\n        isAssignmentTarget = true;\n        firstCoverInitializedNameError = null;\n        result = parser();\n        if (firstCoverInitializedNameError !== null) {\n            throwUnexpectedToken(firstCoverInitializedNameError);\n        }\n        isBindingElement = oldIsBindingElement;\n        isAssignmentTarget = oldIsAssignmentTarget;\n        firstCoverInitializedNameError = oldFirstCoverInitializedNameError;\n        return result;\n    }\n\n    function inheritCoverGrammar(parser) {\n        var oldIsBindingElement = isBindingElement,\n            oldIsAssignmentTarget = isAssignmentTarget,\n            oldFirstCoverInitializedNameError = firstCoverInitializedNameError,\n            result;\n        isBindingElement = true;\n        isAssignmentTarget = true;\n        firstCoverInitializedNameError = null;\n        result = parser();\n        isBindingElement = isBindingElement && oldIsBindingElement;\n        isAssignmentTarget = isAssignmentTarget && oldIsAssignmentTarget;\n        firstCoverInitializedNameError = oldFirstCoverInitializedNameError || firstCoverInitializedNameError;\n        return result;\n    }\n\n    function parseArrayPattern() {\n        var node = new Node(), elements = [], rest, restNode;\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else {\n                if (match('...')) {\n                    restNode = new Node();\n                    lex();\n                    rest = parseVariableIdentifier();\n                    elements.push(restNode.finishRestElement(rest));\n                    break;\n                } else {\n                    elements.push(parsePatternWithDefault());\n                }\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n\n        }\n\n        expect(']');\n\n        return node.finishArrayPattern(elements);\n    }\n\n    function parsePropertyPattern() {\n        var node = new Node(), key, computed = match('['), init;\n        if (lookahead.type === Token.Identifier) {\n            key = parseVariableIdentifier();\n            if (match('=')) {\n                lex();\n                init = parseAssignmentExpression();\n                return node.finishProperty(\n                    'init', key, false,\n                    new WrappingNode(key).finishAssignmentPattern(key, init), false, false);\n            } else if (!match(':')) {\n                return node.finishProperty('init', key, false, key, false, true);\n            }\n        } else {\n            key = parseObjectPropertyKey();\n        }\n        expect(':');\n        init = parsePatternWithDefault();\n        return node.finishProperty('init', key, computed, init, false, false);\n    }\n\n    function parseObjectPattern() {\n        var node = new Node(), properties = [];\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parsePropertyPattern());\n            if (!match('}')) {\n                expect(',');\n            }\n        }\n\n        lex();\n\n        return node.finishObjectPattern(properties);\n    }\n\n    function parsePattern() {\n        if (lookahead.type === Token.Identifier) {\n            return parseVariableIdentifier();\n        } else if (match('[')) {\n            return parseArrayPattern();\n        } else if (match('{')) {\n            return parseObjectPattern();\n        }\n        throwUnexpectedToken(lookahead);\n    }\n\n    function parsePatternWithDefault() {\n        var startToken = lookahead, pattern, right;\n        pattern = parsePattern();\n        if (match('=')) {\n            lex();\n            right = isolateCoverGrammar(parseAssignmentExpression);\n            pattern = new WrappingNode(startToken).finishAssignmentPattern(pattern, right);\n        }\n        return pattern;\n    }\n\n    // 11.1.4 Array Initialiser\n\n    function parseArrayInitialiser() {\n        var elements = [], node = new Node(), restSpread;\n\n        expect('[');\n\n        while (!match(']')) {\n            if (match(',')) {\n                lex();\n                elements.push(null);\n            } else if (match('...')) {\n                restSpread = new Node();\n                lex();\n                restSpread.finishSpreadElement(inheritCoverGrammar(parseAssignmentExpression));\n\n                if (!match(']')) {\n                    isAssignmentTarget = isBindingElement = false;\n                    expect(',');\n                }\n                elements.push(restSpread);\n            } else {\n                elements.push(inheritCoverGrammar(parseAssignmentExpression));\n\n                if (!match(']')) {\n                    expect(',');\n                }\n            }\n        }\n\n        lex();\n\n        return node.finishArrayExpression(elements);\n    }\n\n    // 11.1.5 Object Initialiser\n\n    function parsePropertyFunction(node, paramInfo) {\n        var previousStrict, body;\n\n        isAssignmentTarget = isBindingElement = false;\n\n        previousStrict = strict;\n        body = isolateCoverGrammar(parseFunctionSourceElements);\n\n        if (strict && paramInfo.firstRestricted) {\n            tolerateUnexpectedToken(paramInfo.firstRestricted, paramInfo.message);\n        }\n        if (strict && paramInfo.stricted) {\n            tolerateUnexpectedToken(paramInfo.stricted, paramInfo.message);\n        }\n\n        strict = previousStrict;\n        return node.finishFunctionExpression(null, paramInfo.params, paramInfo.defaults, body);\n    }\n\n    function parsePropertyMethodFunction() {\n        var params, method, node = new Node();\n\n        params = parseParams();\n        method = parsePropertyFunction(node, params);\n\n        return method;\n    }\n\n    function parseObjectPropertyKey() {\n        var token, node = new Node(), expr;\n\n        token = lex();\n\n        // Note: This function is called only from parseObjectProperty(), where\n        // EOF and Punctuator tokens are already filtered out.\n\n        switch (token.type) {\n        case Token.StringLiteral:\n        case Token.NumericLiteral:\n            if (strict && token.octal) {\n                tolerateUnexpectedToken(token, Messages.StrictOctalLiteral);\n            }\n            return node.finishLiteral(token);\n        case Token.Identifier:\n        case Token.BooleanLiteral:\n        case Token.NullLiteral:\n        case Token.Keyword:\n            return node.finishIdentifier(token.value);\n        case Token.Punctuator:\n            if (token.value === '[') {\n                expr = isolateCoverGrammar(parseAssignmentExpression);\n                expect(']');\n                return expr;\n            }\n            break;\n        }\n        throwUnexpectedToken(token);\n    }\n\n    function lookaheadPropertyName() {\n        switch (lookahead.type) {\n        case Token.Identifier:\n        case Token.StringLiteral:\n        case Token.BooleanLiteral:\n        case Token.NullLiteral:\n        case Token.NumericLiteral:\n        case Token.Keyword:\n            return true;\n        case Token.Punctuator:\n            return lookahead.value === '[';\n        }\n        return false;\n    }\n\n    // This function is to try to parse a MethodDefinition as defined in 14.3. But in the case of object literals,\n    // it might be called at a position where there is in fact a short hand identifier pattern or a data property.\n    // This can only be determined after we consumed up to the left parentheses.\n    //\n    // In order to avoid back tracking, it returns `null` if the position is not a MethodDefinition and the caller\n    // is responsible to visit other options.\n    function tryParseMethodDefinition(token, key, computed, node) {\n        var value, options, methodNode;\n\n        if (token.type === Token.Identifier) {\n            // check for `get` and `set`;\n\n            if (token.value === 'get' && lookaheadPropertyName()) {\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                methodNode = new Node();\n                expect('(');\n                expect(')');\n                value = parsePropertyFunction(methodNode, {\n                    params: [],\n                    defaults: [],\n                    stricted: null,\n                    firstRestricted: null,\n                    message: null\n                });\n                return node.finishProperty('get', key, computed, value, false, false);\n            } else if (token.value === 'set' && lookaheadPropertyName()) {\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                methodNode = new Node();\n                expect('(');\n\n                options = {\n                    params: [],\n                    defaultCount: 0,\n                    defaults: [],\n                    firstRestricted: null,\n                    paramSet: {}\n                };\n                if (match(')')) {\n                    tolerateUnexpectedToken(lookahead);\n                } else {\n                    parseParam(options);\n                    if (options.defaultCount === 0) {\n                        options.defaults = [];\n                    }\n                }\n                expect(')');\n\n                value = parsePropertyFunction(methodNode, options);\n                return node.finishProperty('set', key, computed, value, false, false);\n            }\n        }\n\n        if (match('(')) {\n            value = parsePropertyMethodFunction();\n            return node.finishProperty('init', key, computed, value, true, false);\n        }\n\n        // Not a MethodDefinition.\n        return null;\n    }\n\n    function checkProto(key, computed, hasProto) {\n        if (computed === false && (key.type === Syntax.Identifier && key.name === '__proto__' ||\n            key.type === Syntax.Literal && key.value === '__proto__')) {\n            if (hasProto.value) {\n                tolerateError(Messages.DuplicateProtoProperty);\n            } else {\n                hasProto.value = true;\n            }\n        }\n    }\n\n    function parseObjectProperty(hasProto) {\n        var token = lookahead, node = new Node(), computed, key, maybeMethod, value;\n\n        computed = match('[');\n        key = parseObjectPropertyKey();\n        maybeMethod = tryParseMethodDefinition(token, key, computed, node);\n\n        if (maybeMethod) {\n            checkProto(maybeMethod.key, maybeMethod.computed, hasProto);\n            // finished\n            return maybeMethod;\n        }\n\n        // init property or short hand property.\n        checkProto(key, computed, hasProto);\n\n        if (match(':')) {\n            lex();\n            value = inheritCoverGrammar(parseAssignmentExpression);\n            return node.finishProperty('init', key, computed, value, false, false);\n        }\n\n        if (token.type === Token.Identifier) {\n            if (match('=')) {\n                firstCoverInitializedNameError = lookahead;\n                lex();\n                value = isolateCoverGrammar(parseAssignmentExpression);\n                return node.finishProperty('init', key, computed,\n                    new WrappingNode(token).finishAssignmentPattern(key, value), false, true);\n            }\n            return node.finishProperty('init', key, computed, key, false, true);\n        }\n\n        throwUnexpectedToken(lookahead);\n    }\n\n    function parseObjectInitialiser() {\n        var properties = [], hasProto = {value: false}, node = new Node();\n\n        expect('{');\n\n        while (!match('}')) {\n            properties.push(parseObjectProperty(hasProto));\n\n            if (!match('}')) {\n                expectCommaSeparator();\n            }\n        }\n\n        expect('}');\n\n        return node.finishObjectExpression(properties);\n    }\n\n    function reinterpretExpressionAsPattern(expr) {\n        var i;\n        switch (expr.type) {\n        case Syntax.Identifier:\n        case Syntax.MemberExpression:\n        case Syntax.RestElement:\n        case Syntax.AssignmentPattern:\n            break;\n        case Syntax.SpreadElement:\n            expr.type = Syntax.RestElement;\n            reinterpretExpressionAsPattern(expr.argument);\n            break;\n        case Syntax.ArrayExpression:\n            expr.type = Syntax.ArrayPattern;\n            for (i = 0; i < expr.elements.length; i++) {\n                if (expr.elements[i] !== null) {\n                    reinterpretExpressionAsPattern(expr.elements[i]);\n                }\n            }\n            break;\n        case Syntax.ObjectExpression:\n            expr.type = Syntax.ObjectPattern;\n            for (i = 0; i < expr.properties.length; i++) {\n                reinterpretExpressionAsPattern(expr.properties[i].value);\n            }\n            break;\n        case Syntax.AssignmentExpression:\n            expr.type = Syntax.AssignmentPattern;\n            reinterpretExpressionAsPattern(expr.left);\n            break;\n        default:\n            // Allow other node type for tolerant parsing.\n            break;\n        }\n    }\n\n    function parseTemplateElement(option) {\n        var node, token;\n\n        if (lookahead.type !== Token.Template || (option.head && !lookahead.head)) {\n            throwUnexpectedToken();\n        }\n\n        node = new Node();\n        token = lex();\n\n        return node.finishTemplateElement({ raw: token.value.raw, cooked: token.value.cooked }, token.tail);\n    }\n\n    function parseTemplateLiteral() {\n        var quasi, quasis, expressions, node = new Node();\n\n        quasi = parseTemplateElement({ head: true });\n        quasis = [ quasi ];\n        expressions = [];\n\n        while (!quasi.tail) {\n            expressions.push(parseExpression());\n            quasi = parseTemplateElement({ head: false });\n            quasis.push(quasi);\n        }\n\n        return node.finishTemplateLiteral(quasis, expressions);\n    }\n\n    // 11.1.6 The Grouping Operator\n\n    function parseGroupExpression() {\n        var expr, expressions, startToken, i;\n\n        expect('(');\n\n        if (match(')')) {\n            lex();\n            if (!match('=>')) {\n                expect('=>');\n            }\n            return {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: []\n            };\n        }\n\n        startToken = lookahead;\n        if (match('...')) {\n            expr = parseRestElement();\n            expect(')');\n            if (!match('=>')) {\n                expect('=>');\n            }\n            return {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: [expr]\n            };\n        }\n\n        isBindingElement = true;\n        expr = inheritCoverGrammar(parseAssignmentExpression);\n\n        if (match(',')) {\n            isAssignmentTarget = false;\n            expressions = [expr];\n\n            while (startIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n\n                if (match('...')) {\n                    if (!isBindingElement) {\n                        throwUnexpectedToken(lookahead);\n                    }\n                    expressions.push(parseRestElement());\n                    expect(')');\n                    if (!match('=>')) {\n                        expect('=>');\n                    }\n                    isBindingElement = false;\n                    for (i = 0; i < expressions.length; i++) {\n                        reinterpretExpressionAsPattern(expressions[i]);\n                    }\n                    return {\n                        type: PlaceHolders.ArrowParameterPlaceHolder,\n                        params: expressions\n                    };\n                }\n\n                expressions.push(inheritCoverGrammar(parseAssignmentExpression));\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n\n        expect(')');\n\n        if (match('=>')) {\n            if (!isBindingElement) {\n                throwUnexpectedToken(lookahead);\n            }\n\n            if (expr.type === Syntax.SequenceExpression) {\n                for (i = 0; i < expr.expressions.length; i++) {\n                    reinterpretExpressionAsPattern(expr.expressions[i]);\n                }\n            } else {\n                reinterpretExpressionAsPattern(expr);\n            }\n\n            expr = {\n                type: PlaceHolders.ArrowParameterPlaceHolder,\n                params: expr.type === Syntax.SequenceExpression ? expr.expressions : [expr]\n            };\n        }\n        isBindingElement = false;\n        return expr;\n    }\n\n\n    // 11.1 Primary Expressions\n\n    function parsePrimaryExpression() {\n        var type, token, expr, node;\n\n        if (match('(')) {\n            isBindingElement = false;\n            return inheritCoverGrammar(parseGroupExpression);\n        }\n\n        if (match('[')) {\n            return inheritCoverGrammar(parseArrayInitialiser);\n        }\n\n        if (match('{')) {\n            return inheritCoverGrammar(parseObjectInitialiser);\n        }\n\n        type = lookahead.type;\n        node = new Node();\n\n        if (type === Token.Identifier) {\n            expr = node.finishIdentifier(lex().value);\n        } else if (type === Token.StringLiteral || type === Token.NumericLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            if (strict && lookahead.octal) {\n                tolerateUnexpectedToken(lookahead, Messages.StrictOctalLiteral);\n            }\n            expr = node.finishLiteral(lex());\n        } else if (type === Token.Keyword) {\n            isAssignmentTarget = isBindingElement = false;\n            if (matchKeyword('function')) {\n                return parseFunctionExpression();\n            }\n            if (matchKeyword('this')) {\n                lex();\n                return node.finishThisExpression();\n            }\n            if (matchKeyword('class')) {\n                return parseClassExpression();\n            }\n            throwUnexpectedToken(lex());\n        } else if (type === Token.BooleanLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            token = lex();\n            token.value = (token.value === 'true');\n            expr = node.finishLiteral(token);\n        } else if (type === Token.NullLiteral) {\n            isAssignmentTarget = isBindingElement = false;\n            token = lex();\n            token.value = null;\n            expr = node.finishLiteral(token);\n        } else if (match('/') || match('/=')) {\n            isAssignmentTarget = isBindingElement = false;\n            index = startIndex;\n\n            if (typeof extra.tokens !== 'undefined') {\n                token = collectRegex();\n            } else {\n                token = scanRegExp();\n            }\n            lex();\n            expr = node.finishLiteral(token);\n        } else if (type === Token.Template) {\n            expr = parseTemplateLiteral();\n        } else {\n            throwUnexpectedToken(lex());\n        }\n\n        return expr;\n    }\n\n    // 11.2 Left-Hand-Side Expressions\n\n    function parseArguments() {\n        var args = [];\n\n        expect('(');\n\n        if (!match(')')) {\n            while (startIndex < length) {\n                args.push(isolateCoverGrammar(parseAssignmentExpression));\n                if (match(')')) {\n                    break;\n                }\n                expectCommaSeparator();\n            }\n        }\n\n        expect(')');\n\n        return args;\n    }\n\n    function parseNonComputedProperty() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (!isIdentifierName(token)) {\n            throwUnexpectedToken(token);\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseNonComputedMember() {\n        expect('.');\n\n        return parseNonComputedProperty();\n    }\n\n    function parseComputedMember() {\n        var expr;\n\n        expect('[');\n\n        expr = isolateCoverGrammar(parseExpression);\n\n        expect(']');\n\n        return expr;\n    }\n\n    function parseNewExpression() {\n        var callee, args, node = new Node();\n\n        expectKeyword('new');\n        callee = isolateCoverGrammar(parseLeftHandSideExpression);\n        args = match('(') ? parseArguments() : [];\n\n        isAssignmentTarget = isBindingElement = false;\n\n        return node.finishNewExpression(callee, args);\n    }\n\n    function parseLeftHandSideExpressionAllowCall() {\n        var quasi, expr, args, property, startToken, previousAllowIn = state.allowIn;\n\n        startToken = lookahead;\n        state.allowIn = true;\n\n        if (matchKeyword('super') && state.inFunctionBody) {\n            expr = new Node();\n            lex();\n            expr = expr.finishSuper();\n            if (!match('(') && !match('.') && !match('[')) {\n                throwUnexpectedToken(lookahead);\n            }\n        } else {\n            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n        }\n\n        for (;;) {\n            if (match('.')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (match('(')) {\n                isBindingElement = false;\n                isAssignmentTarget = false;\n                args = parseArguments();\n                expr = new WrappingNode(startToken).finishCallExpression(expr, args);\n            } else if (match('[')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (lookahead.type === Token.Template && lookahead.head) {\n                quasi = parseTemplateLiteral();\n                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n            } else {\n                break;\n            }\n        }\n        state.allowIn = previousAllowIn;\n\n        return expr;\n    }\n\n    function parseLeftHandSideExpression() {\n        var quasi, expr, property, startToken;\n        assert(state.allowIn, 'callee of new expression always allow in keyword.');\n\n        startToken = lookahead;\n\n        if (matchKeyword('super') && state.inFunctionBody) {\n            expr = new Node();\n            lex();\n            expr = expr.finishSuper();\n            if (!match('[') && !match('.')) {\n                throwUnexpectedToken(lookahead);\n            }\n        } else {\n            expr = inheritCoverGrammar(matchKeyword('new') ? parseNewExpression : parsePrimaryExpression);\n        }\n\n        for (;;) {\n            if (match('[')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('[', expr, property);\n            } else if (match('.')) {\n                isBindingElement = false;\n                isAssignmentTarget = true;\n                property = parseNonComputedMember();\n                expr = new WrappingNode(startToken).finishMemberExpression('.', expr, property);\n            } else if (lookahead.type === Token.Template && lookahead.head) {\n                quasi = parseTemplateLiteral();\n                expr = new WrappingNode(startToken).finishTaggedTemplateExpression(expr, quasi);\n            } else {\n                break;\n            }\n        }\n        return expr;\n    }\n\n    // 11.3 Postfix Expressions\n\n    function parsePostfixExpression() {\n        var expr, token, startToken = lookahead;\n\n        expr = inheritCoverGrammar(parseLeftHandSideExpressionAllowCall);\n\n        if (!hasLineTerminator && lookahead.type === Token.Punctuator) {\n            if (match('++') || match('--')) {\n                // 11.3.1, 11.3.2\n                if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                    tolerateError(Messages.StrictLHSPostfix);\n                }\n\n                if (!isAssignmentTarget) {\n                    tolerateError(Messages.InvalidLHSInAssignment);\n                }\n\n                isAssignmentTarget = isBindingElement = false;\n\n                token = lex();\n                expr = new WrappingNode(startToken).finishPostfixExpression(token.value, expr);\n            }\n        }\n\n        return expr;\n    }\n\n    // 11.4 Unary Operators\n\n    function parseUnaryExpression() {\n        var token, expr, startToken;\n\n        if (lookahead.type !== Token.Punctuator && lookahead.type !== Token.Keyword) {\n            expr = parsePostfixExpression();\n        } else if (match('++') || match('--')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            // 11.4.4, 11.4.5\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateError(Messages.StrictLHSPrefix);\n            }\n\n            if (!isAssignmentTarget) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            isAssignmentTarget = isBindingElement = false;\n        } else if (match('+') || match('-') || match('~') || match('!')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            isAssignmentTarget = isBindingElement = false;\n        } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {\n            startToken = lookahead;\n            token = lex();\n            expr = inheritCoverGrammar(parseUnaryExpression);\n            expr = new WrappingNode(startToken).finishUnaryExpression(token.value, expr);\n            if (strict && expr.operator === 'delete' && expr.argument.type === Syntax.Identifier) {\n                tolerateError(Messages.StrictDelete);\n            }\n            isAssignmentTarget = isBindingElement = false;\n        } else {\n            expr = parsePostfixExpression();\n        }\n\n        return expr;\n    }\n\n    function binaryPrecedence(token, allowIn) {\n        var prec = 0;\n\n        if (token.type !== Token.Punctuator && token.type !== Token.Keyword) {\n            return 0;\n        }\n\n        switch (token.value) {\n        case '||':\n            prec = 1;\n            break;\n\n        case '&&':\n            prec = 2;\n            break;\n\n        case '|':\n            prec = 3;\n            break;\n\n        case '^':\n            prec = 4;\n            break;\n\n        case '&':\n            prec = 5;\n            break;\n\n        case '==':\n        case '!=':\n        case '===':\n        case '!==':\n            prec = 6;\n            break;\n\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n        case 'instanceof':\n            prec = 7;\n            break;\n\n        case 'in':\n            prec = allowIn ? 7 : 0;\n            break;\n\n        case '<<':\n        case '>>':\n        case '>>>':\n            prec = 8;\n            break;\n\n        case '+':\n        case '-':\n            prec = 9;\n            break;\n\n        case '*':\n        case '/':\n        case '%':\n            prec = 11;\n            break;\n\n        default:\n            break;\n        }\n\n        return prec;\n    }\n\n    // 11.5 Multiplicative Operators\n    // 11.6 Additive Operators\n    // 11.7 Bitwise Shift Operators\n    // 11.8 Relational Operators\n    // 11.9 Equality Operators\n    // 11.10 Binary Bitwise Operators\n    // 11.11 Binary Logical Operators\n\n    function parseBinaryExpression() {\n        var marker, markers, expr, token, prec, stack, right, operator, left, i;\n\n        marker = lookahead;\n        left = inheritCoverGrammar(parseUnaryExpression);\n\n        token = lookahead;\n        prec = binaryPrecedence(token, state.allowIn);\n        if (prec === 0) {\n            return left;\n        }\n        isAssignmentTarget = isBindingElement = false;\n        token.prec = prec;\n        lex();\n\n        markers = [marker, lookahead];\n        right = isolateCoverGrammar(parseUnaryExpression);\n\n        stack = [left, token, right];\n\n        while ((prec = binaryPrecedence(lookahead, state.allowIn)) > 0) {\n\n            // Reduce: make a binary expression from the three topmost entries.\n            while ((stack.length > 2) && (prec <= stack[stack.length - 2].prec)) {\n                right = stack.pop();\n                operator = stack.pop().value;\n                left = stack.pop();\n                markers.pop();\n                expr = new WrappingNode(markers[markers.length - 1]).finishBinaryExpression(operator, left, right);\n                stack.push(expr);\n            }\n\n            // Shift.\n            token = lex();\n            token.prec = prec;\n            stack.push(token);\n            markers.push(lookahead);\n            expr = isolateCoverGrammar(parseUnaryExpression);\n            stack.push(expr);\n        }\n\n        // Final reduce to clean-up the stack.\n        i = stack.length - 1;\n        expr = stack[i];\n        markers.pop();\n        while (i > 1) {\n            expr = new WrappingNode(markers.pop()).finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);\n            i -= 2;\n        }\n\n        return expr;\n    }\n\n\n    // 11.12 Conditional Operator\n\n    function parseConditionalExpression() {\n        var expr, previousAllowIn, consequent, alternate, startToken;\n\n        startToken = lookahead;\n\n        expr = inheritCoverGrammar(parseBinaryExpression);\n        if (match('?')) {\n            lex();\n            previousAllowIn = state.allowIn;\n            state.allowIn = true;\n            consequent = isolateCoverGrammar(parseAssignmentExpression);\n            state.allowIn = previousAllowIn;\n            expect(':');\n            alternate = isolateCoverGrammar(parseAssignmentExpression);\n\n            expr = new WrappingNode(startToken).finishConditionalExpression(expr, consequent, alternate);\n            isAssignmentTarget = isBindingElement = false;\n        }\n\n        return expr;\n    }\n\n    // [ES6] 14.2 Arrow Function\n\n    function parseConciseBody() {\n        if (match('{')) {\n            return parseFunctionSourceElements();\n        }\n        return isolateCoverGrammar(parseAssignmentExpression);\n    }\n\n    function checkPatternParam(options, param) {\n        var i;\n        switch (param.type) {\n        case Syntax.Identifier:\n            validateParam(options, param, param.name);\n            break;\n        case Syntax.RestElement:\n            checkPatternParam(options, param.argument);\n            break;\n        case Syntax.AssignmentPattern:\n            checkPatternParam(options, param.left);\n            break;\n        case Syntax.ArrayPattern:\n            for (i = 0; i < param.elements.length; i++) {\n                if (param.elements[i] !== null) {\n                    checkPatternParam(options, param.elements[i]);\n                }\n            }\n            break;\n        default:\n            assert(param.type === Syntax.ObjectPattern, 'Invalid type');\n            for (i = 0; i < param.properties.length; i++) {\n                checkPatternParam(options, param.properties[i].value);\n            }\n            break;\n        }\n    }\n    function reinterpretAsCoverFormalsList(expr) {\n        var i, len, param, params, defaults, defaultCount, options, token;\n\n        defaults = [];\n        defaultCount = 0;\n        params = [expr];\n\n        switch (expr.type) {\n        case Syntax.Identifier:\n            break;\n        case PlaceHolders.ArrowParameterPlaceHolder:\n            params = expr.params;\n            break;\n        default:\n            return null;\n        }\n\n        options = {\n            paramSet: {}\n        };\n\n        for (i = 0, len = params.length; i < len; i += 1) {\n            param = params[i];\n            switch (param.type) {\n            case Syntax.AssignmentPattern:\n                params[i] = param.left;\n                defaults.push(param.right);\n                ++defaultCount;\n                checkPatternParam(options, param.left);\n                break;\n            default:\n                checkPatternParam(options, param);\n                params[i] = param;\n                defaults.push(null);\n                break;\n            }\n        }\n\n        if (options.message === Messages.StrictParamDupe) {\n            token = strict ? options.stricted : options.firstRestricted;\n            throwUnexpectedToken(token, options.message);\n        }\n\n        if (defaultCount === 0) {\n            defaults = [];\n        }\n\n        return {\n            params: params,\n            defaults: defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseArrowFunctionExpression(options, node) {\n        var previousStrict, body;\n\n        if (hasLineTerminator) {\n            tolerateUnexpectedToken(lookahead);\n        }\n        expect('=>');\n        previousStrict = strict;\n\n        body = parseConciseBody();\n\n        if (strict && options.firstRestricted) {\n            throwUnexpectedToken(options.firstRestricted, options.message);\n        }\n        if (strict && options.stricted) {\n            tolerateUnexpectedToken(options.stricted, options.message);\n        }\n\n        strict = previousStrict;\n\n        return node.finishArrowFunctionExpression(options.params, options.defaults, body, body.type !== Syntax.BlockStatement);\n    }\n\n    // 11.13 Assignment Operators\n\n    function parseAssignmentExpression() {\n        var token, expr, right, list, startToken;\n\n        startToken = lookahead;\n        token = lookahead;\n\n        expr = parseConditionalExpression();\n\n        if (expr.type === PlaceHolders.ArrowParameterPlaceHolder || match('=>')) {\n            isAssignmentTarget = isBindingElement = false;\n            list = reinterpretAsCoverFormalsList(expr);\n\n            if (list) {\n                firstCoverInitializedNameError = null;\n                return parseArrowFunctionExpression(list, new WrappingNode(startToken));\n            }\n\n            return expr;\n        }\n\n        if (matchAssign()) {\n            if (!isAssignmentTarget) {\n                tolerateError(Messages.InvalidLHSInAssignment);\n            }\n\n            // 11.13.1\n            if (strict && expr.type === Syntax.Identifier && isRestrictedWord(expr.name)) {\n                tolerateUnexpectedToken(token, Messages.StrictLHSAssignment);\n            }\n\n            if (!match('=')) {\n                isAssignmentTarget = isBindingElement = false;\n            } else {\n                reinterpretExpressionAsPattern(expr);\n            }\n\n            token = lex();\n            right = isolateCoverGrammar(parseAssignmentExpression);\n            expr = new WrappingNode(startToken).finishAssignmentExpression(token.value, expr, right);\n            firstCoverInitializedNameError = null;\n        }\n\n        return expr;\n    }\n\n    // 11.14 Comma Operator\n\n    function parseExpression() {\n        var expr, startToken = lookahead, expressions;\n\n        expr = isolateCoverGrammar(parseAssignmentExpression);\n\n        if (match(',')) {\n            expressions = [expr];\n\n            while (startIndex < length) {\n                if (!match(',')) {\n                    break;\n                }\n                lex();\n                expressions.push(isolateCoverGrammar(parseAssignmentExpression));\n            }\n\n            expr = new WrappingNode(startToken).finishSequenceExpression(expressions);\n        }\n\n        return expr;\n    }\n\n    // 12.1 Block\n\n    function parseStatementListItem() {\n        if (lookahead.type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'export':\n                if (sourceType !== 'module') {\n                    tolerateUnexpectedToken(lookahead, Messages.IllegalExportDeclaration);\n                }\n                return parseExportDeclaration();\n            case 'import':\n                if (sourceType !== 'module') {\n                    tolerateUnexpectedToken(lookahead, Messages.IllegalImportDeclaration);\n                }\n                return parseImportDeclaration();\n            case 'const':\n            case 'let':\n                return parseLexicalDeclaration({inFor: false});\n            case 'function':\n                return parseFunctionDeclaration(new Node());\n            case 'class':\n                return parseClassDeclaration();\n            }\n        }\n\n        return parseStatement();\n    }\n\n    function parseStatementList() {\n        var list = [];\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            list.push(parseStatementListItem());\n        }\n\n        return list;\n    }\n\n    function parseBlock() {\n        var block, node = new Node();\n\n        expect('{');\n\n        block = parseStatementList();\n\n        expect('}');\n\n        return node.finishBlockStatement(block);\n    }\n\n    // 12.2 Variable Statement\n\n    function parseVariableIdentifier() {\n        var token, node = new Node();\n\n        token = lex();\n\n        if (token.type !== Token.Identifier) {\n            if (strict && token.type === Token.Keyword && isStrictModeReservedWord(token.value)) {\n                tolerateUnexpectedToken(token, Messages.StrictReservedWord);\n            } else {\n                throwUnexpectedToken(token);\n            }\n        }\n\n        return node.finishIdentifier(token.value);\n    }\n\n    function parseVariableDeclaration() {\n        var init = null, id, node = new Node();\n\n        id = parsePattern();\n\n        // 12.2.1\n        if (strict && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (match('=')) {\n            lex();\n            init = isolateCoverGrammar(parseAssignmentExpression);\n        } else if (id.type !== Syntax.Identifier) {\n            expect('=');\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseVariableDeclarationList() {\n        var list = [];\n\n        do {\n            list.push(parseVariableDeclaration());\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (startIndex < length);\n\n        return list;\n    }\n\n    function parseVariableStatement(node) {\n        var declarations;\n\n        expectKeyword('var');\n\n        declarations = parseVariableDeclarationList();\n\n        consumeSemicolon();\n\n        return node.finishVariableDeclaration(declarations);\n    }\n\n    function parseLexicalBinding(kind, options) {\n        var init = null, id, node = new Node();\n\n        id = parsePattern();\n\n        // 12.2.1\n        if (strict && id.type === Syntax.Identifier && isRestrictedWord(id.name)) {\n            tolerateError(Messages.StrictVarName);\n        }\n\n        if (kind === 'const') {\n            if (!matchKeyword('in')) {\n                expect('=');\n                init = isolateCoverGrammar(parseAssignmentExpression);\n            }\n        } else if ((!options.inFor && id.type !== Syntax.Identifier) || match('=')) {\n            expect('=');\n            init = isolateCoverGrammar(parseAssignmentExpression);\n        }\n\n        return node.finishVariableDeclarator(id, init);\n    }\n\n    function parseBindingList(kind, options) {\n        var list = [];\n\n        do {\n            list.push(parseLexicalBinding(kind, options));\n            if (!match(',')) {\n                break;\n            }\n            lex();\n        } while (startIndex < length);\n\n        return list;\n    }\n\n    function parseLexicalDeclaration(options) {\n        var kind, declarations, node = new Node();\n\n        kind = lex().value;\n        assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');\n\n        declarations = parseBindingList(kind, options);\n\n        consumeSemicolon();\n\n        return node.finishLexicalDeclaration(declarations, kind);\n    }\n\n    function parseRestElement() {\n        var param, node = new Node();\n\n        lex();\n\n        if (match('{')) {\n            throwError(Messages.ObjectPatternAsRestParameter);\n        }\n\n        param = parseVariableIdentifier();\n\n        if (match('=')) {\n            throwError(Messages.DefaultRestParameter);\n        }\n\n        if (!match(')')) {\n            throwError(Messages.ParameterAfterRestParameter);\n        }\n\n        return node.finishRestElement(param);\n    }\n\n    // 12.3 Empty Statement\n\n    function parseEmptyStatement(node) {\n        expect(';');\n        return node.finishEmptyStatement();\n    }\n\n    // 12.4 Expression Statement\n\n    function parseExpressionStatement(node) {\n        var expr = parseExpression();\n        consumeSemicolon();\n        return node.finishExpressionStatement(expr);\n    }\n\n    // 12.5 If statement\n\n    function parseIfStatement(node) {\n        var test, consequent, alternate;\n\n        expectKeyword('if');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        consequent = parseStatement();\n\n        if (matchKeyword('else')) {\n            lex();\n            alternate = parseStatement();\n        } else {\n            alternate = null;\n        }\n\n        return node.finishIfStatement(test, consequent, alternate);\n    }\n\n    // 12.6 Iteration Statements\n\n    function parseDoWhileStatement(node) {\n        var body, test, oldInIteration;\n\n        expectKeyword('do');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        if (match(';')) {\n            lex();\n        }\n\n        return node.finishDoWhileStatement(body, test);\n    }\n\n    function parseWhileStatement(node) {\n        var test, body, oldInIteration;\n\n        expectKeyword('while');\n\n        expect('(');\n\n        test = parseExpression();\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = parseStatement();\n\n        state.inIteration = oldInIteration;\n\n        return node.finishWhileStatement(test, body);\n    }\n\n    function parseForStatement(node) {\n        var init, initSeq, initStartToken, test, update, left, right, kind, declarations,\n            body, oldInIteration, previousAllowIn = state.allowIn;\n\n        init = test = update = null;\n\n        expectKeyword('for');\n\n        expect('(');\n\n        if (match(';')) {\n            lex();\n        } else {\n            if (matchKeyword('var')) {\n                init = new Node();\n                lex();\n\n                state.allowIn = false;\n                init = init.finishVariableDeclaration(parseVariableDeclarationList());\n                state.allowIn = previousAllowIn;\n\n                if (init.declarations.length === 1 && matchKeyword('in')) {\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else {\n                    expect(';');\n                }\n            } else if (matchKeyword('const') || matchKeyword('let')) {\n                init = new Node();\n                kind = lex().value;\n\n                state.allowIn = false;\n                declarations = parseBindingList(kind, {inFor: true});\n                state.allowIn = previousAllowIn;\n\n                if (declarations.length === 1 && declarations[0].init === null && matchKeyword('in')) {\n                    init = init.finishLexicalDeclaration(declarations, kind);\n                    lex();\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else {\n                    consumeSemicolon();\n                    init = init.finishLexicalDeclaration(declarations, kind);\n                }\n            } else {\n                initStartToken = lookahead;\n                state.allowIn = false;\n                init = inheritCoverGrammar(parseAssignmentExpression);\n                state.allowIn = previousAllowIn;\n\n                if (matchKeyword('in')) {\n                    if (!isAssignmentTarget) {\n                        tolerateError(Messages.InvalidLHSInForIn);\n                    }\n\n                    lex();\n                    reinterpretExpressionAsPattern(init);\n                    left = init;\n                    right = parseExpression();\n                    init = null;\n                } else {\n                    if (match(',')) {\n                        initSeq = [init];\n                        while (match(',')) {\n                            lex();\n                            initSeq.push(isolateCoverGrammar(parseAssignmentExpression));\n                        }\n                        init = new WrappingNode(initStartToken).finishSequenceExpression(initSeq);\n                    }\n                    expect(';');\n                }\n            }\n        }\n\n        if (typeof left === 'undefined') {\n\n            if (!match(';')) {\n                test = parseExpression();\n            }\n            expect(';');\n\n            if (!match(')')) {\n                update = parseExpression();\n            }\n        }\n\n        expect(')');\n\n        oldInIteration = state.inIteration;\n        state.inIteration = true;\n\n        body = isolateCoverGrammar(parseStatement);\n\n        state.inIteration = oldInIteration;\n\n        return (typeof left === 'undefined') ?\n                node.finishForStatement(init, test, update, body) :\n                node.finishForInStatement(left, right, body);\n    }\n\n    // 12.7 The continue statement\n\n    function parseContinueStatement(node) {\n        var label = null, key;\n\n        expectKeyword('continue');\n\n        // Optimize the most common form: 'continue;'.\n        if (source.charCodeAt(startIndex) === 0x3B) {\n            lex();\n\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (hasLineTerminator) {\n            if (!state.inIteration) {\n                throwError(Messages.IllegalContinue);\n            }\n\n            return node.finishContinueStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !state.inIteration) {\n            throwError(Messages.IllegalContinue);\n        }\n\n        return node.finishContinueStatement(label);\n    }\n\n    // 12.8 The break statement\n\n    function parseBreakStatement(node) {\n        var label = null, key;\n\n        expectKeyword('break');\n\n        // Catch the very common case first: immediately a semicolon (U+003B).\n        if (source.charCodeAt(lastIndex) === 0x3B) {\n            lex();\n\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (hasLineTerminator) {\n            if (!(state.inIteration || state.inSwitch)) {\n                throwError(Messages.IllegalBreak);\n            }\n\n            return node.finishBreakStatement(null);\n        }\n\n        if (lookahead.type === Token.Identifier) {\n            label = parseVariableIdentifier();\n\n            key = '$' + label.name;\n            if (!Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.UnknownLabel, label.name);\n            }\n        }\n\n        consumeSemicolon();\n\n        if (label === null && !(state.inIteration || state.inSwitch)) {\n            throwError(Messages.IllegalBreak);\n        }\n\n        return node.finishBreakStatement(label);\n    }\n\n    // 12.9 The return statement\n\n    function parseReturnStatement(node) {\n        var argument = null;\n\n        expectKeyword('return');\n\n        if (!state.inFunctionBody) {\n            tolerateError(Messages.IllegalReturn);\n        }\n\n        // 'return' followed by a space and an identifier is very common.\n        if (source.charCodeAt(lastIndex) === 0x20) {\n            if (isIdentifierStart(source.charCodeAt(lastIndex + 1))) {\n                argument = parseExpression();\n                consumeSemicolon();\n                return node.finishReturnStatement(argument);\n            }\n        }\n\n        if (hasLineTerminator) {\n            // HACK\n            return node.finishReturnStatement(null);\n        }\n\n        if (!match(';')) {\n            if (!match('}') && lookahead.type !== Token.EOF) {\n                argument = parseExpression();\n            }\n        }\n\n        consumeSemicolon();\n\n        return node.finishReturnStatement(argument);\n    }\n\n    // 12.10 The with statement\n\n    function parseWithStatement(node) {\n        var object, body;\n\n        if (strict) {\n            tolerateError(Messages.StrictModeWith);\n        }\n\n        expectKeyword('with');\n\n        expect('(');\n\n        object = parseExpression();\n\n        expect(')');\n\n        body = parseStatement();\n\n        return node.finishWithStatement(object, body);\n    }\n\n    // 12.10 The swith statement\n\n    function parseSwitchCase() {\n        var test, consequent = [], statement, node = new Node();\n\n        if (matchKeyword('default')) {\n            lex();\n            test = null;\n        } else {\n            expectKeyword('case');\n            test = parseExpression();\n        }\n        expect(':');\n\n        while (startIndex < length) {\n            if (match('}') || matchKeyword('default') || matchKeyword('case')) {\n                break;\n            }\n            statement = parseStatementListItem();\n            consequent.push(statement);\n        }\n\n        return node.finishSwitchCase(test, consequent);\n    }\n\n    function parseSwitchStatement(node) {\n        var discriminant, cases, clause, oldInSwitch, defaultFound;\n\n        expectKeyword('switch');\n\n        expect('(');\n\n        discriminant = parseExpression();\n\n        expect(')');\n\n        expect('{');\n\n        cases = [];\n\n        if (match('}')) {\n            lex();\n            return node.finishSwitchStatement(discriminant, cases);\n        }\n\n        oldInSwitch = state.inSwitch;\n        state.inSwitch = true;\n        defaultFound = false;\n\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            clause = parseSwitchCase();\n            if (clause.test === null) {\n                if (defaultFound) {\n                    throwError(Messages.MultipleDefaultsInSwitch);\n                }\n                defaultFound = true;\n            }\n            cases.push(clause);\n        }\n\n        state.inSwitch = oldInSwitch;\n\n        expect('}');\n\n        return node.finishSwitchStatement(discriminant, cases);\n    }\n\n    // 12.13 The throw statement\n\n    function parseThrowStatement(node) {\n        var argument;\n\n        expectKeyword('throw');\n\n        if (hasLineTerminator) {\n            throwError(Messages.NewlineAfterThrow);\n        }\n\n        argument = parseExpression();\n\n        consumeSemicolon();\n\n        return node.finishThrowStatement(argument);\n    }\n\n    // 12.14 The try statement\n\n    function parseCatchClause() {\n        var param, body, node = new Node();\n\n        expectKeyword('catch');\n\n        expect('(');\n        if (match(')')) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        param = parsePattern();\n\n        // 12.14.1\n        if (strict && isRestrictedWord(param.name)) {\n            tolerateError(Messages.StrictCatchVariable);\n        }\n\n        expect(')');\n        body = parseBlock();\n        return node.finishCatchClause(param, body);\n    }\n\n    function parseTryStatement(node) {\n        var block, handler = null, finalizer = null;\n\n        expectKeyword('try');\n\n        block = parseBlock();\n\n        if (matchKeyword('catch')) {\n            handler = parseCatchClause();\n        }\n\n        if (matchKeyword('finally')) {\n            lex();\n            finalizer = parseBlock();\n        }\n\n        if (!handler && !finalizer) {\n            throwError(Messages.NoCatchOrFinally);\n        }\n\n        return node.finishTryStatement(block, handler, finalizer);\n    }\n\n    // 12.15 The debugger statement\n\n    function parseDebuggerStatement(node) {\n        expectKeyword('debugger');\n\n        consumeSemicolon();\n\n        return node.finishDebuggerStatement();\n    }\n\n    // 12 Statements\n\n    function parseStatement() {\n        var type = lookahead.type,\n            expr,\n            labeledBody,\n            key,\n            node;\n\n        if (type === Token.EOF) {\n            throwUnexpectedToken(lookahead);\n        }\n\n        if (type === Token.Punctuator && lookahead.value === '{') {\n            return parseBlock();\n        }\n        isAssignmentTarget = isBindingElement = true;\n        node = new Node();\n\n        if (type === Token.Punctuator) {\n            switch (lookahead.value) {\n            case ';':\n                return parseEmptyStatement(node);\n            case '(':\n                return parseExpressionStatement(node);\n            default:\n                break;\n            }\n        } else if (type === Token.Keyword) {\n            switch (lookahead.value) {\n            case 'break':\n                return parseBreakStatement(node);\n            case 'continue':\n                return parseContinueStatement(node);\n            case 'debugger':\n                return parseDebuggerStatement(node);\n            case 'do':\n                return parseDoWhileStatement(node);\n            case 'for':\n                return parseForStatement(node);\n            case 'function':\n                return parseFunctionDeclaration(node);\n            case 'if':\n                return parseIfStatement(node);\n            case 'return':\n                return parseReturnStatement(node);\n            case 'switch':\n                return parseSwitchStatement(node);\n            case 'throw':\n                return parseThrowStatement(node);\n            case 'try':\n                return parseTryStatement(node);\n            case 'var':\n                return parseVariableStatement(node);\n            case 'while':\n                return parseWhileStatement(node);\n            case 'with':\n                return parseWithStatement(node);\n            default:\n                break;\n            }\n        }\n\n        expr = parseExpression();\n\n        // 12.12 Labelled Statements\n        if ((expr.type === Syntax.Identifier) && match(':')) {\n            lex();\n\n            key = '$' + expr.name;\n            if (Object.prototype.hasOwnProperty.call(state.labelSet, key)) {\n                throwError(Messages.Redeclaration, 'Label', expr.name);\n            }\n\n            state.labelSet[key] = true;\n            labeledBody = parseStatement();\n            delete state.labelSet[key];\n            return node.finishLabeledStatement(expr, labeledBody);\n        }\n\n        consumeSemicolon();\n\n        return node.finishExpressionStatement(expr);\n    }\n\n    // 13 Function Definition\n\n    function parseFunctionSourceElements() {\n        var statement, body = [], token, directive, firstRestricted,\n            oldLabelSet, oldInIteration, oldInSwitch, oldInFunctionBody, oldParenthesisCount,\n            node = new Node();\n\n        expect('{');\n\n        while (startIndex < length) {\n            if (lookahead.type !== Token.StringLiteral) {\n                break;\n            }\n            token = lookahead;\n\n            statement = parseStatementListItem();\n            body.push(statement);\n            if (statement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        oldLabelSet = state.labelSet;\n        oldInIteration = state.inIteration;\n        oldInSwitch = state.inSwitch;\n        oldInFunctionBody = state.inFunctionBody;\n        oldParenthesisCount = state.parenthesizedCount;\n\n        state.labelSet = {};\n        state.inIteration = false;\n        state.inSwitch = false;\n        state.inFunctionBody = true;\n        state.parenthesizedCount = 0;\n\n        while (startIndex < length) {\n            if (match('}')) {\n                break;\n            }\n            body.push(parseStatementListItem());\n        }\n\n        expect('}');\n\n        state.labelSet = oldLabelSet;\n        state.inIteration = oldInIteration;\n        state.inSwitch = oldInSwitch;\n        state.inFunctionBody = oldInFunctionBody;\n        state.parenthesizedCount = oldParenthesisCount;\n\n        return node.finishBlockStatement(body);\n    }\n\n    function validateParam(options, param, name) {\n        var key = '$' + name;\n        if (strict) {\n            if (isRestrictedWord(name)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamName;\n            }\n            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.stricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        } else if (!options.firstRestricted) {\n            if (isRestrictedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamName;\n            } else if (isStrictModeReservedWord(name)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictReservedWord;\n            } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {\n                options.firstRestricted = param;\n                options.message = Messages.StrictParamDupe;\n            }\n        }\n        options.paramSet[key] = true;\n    }\n\n    function parseParam(options) {\n        var token, param, def;\n\n        token = lookahead;\n        if (token.value === '...') {\n            param = parseRestElement();\n            validateParam(options, param.argument, param.argument.name);\n            options.params.push(param);\n            options.defaults.push(null);\n            return false;\n        }\n\n        param = parsePatternWithDefault();\n        validateParam(options, token, token.value);\n\n        if (param.type === Syntax.AssignmentPattern) {\n            def = param.right;\n            param = param.left;\n            ++options.defaultCount;\n        }\n\n        options.params.push(param);\n        options.defaults.push(def);\n\n        return !match(')');\n    }\n\n    function parseParams(firstRestricted) {\n        var options;\n\n        options = {\n            params: [],\n            defaultCount: 0,\n            defaults: [],\n            firstRestricted: firstRestricted\n        };\n\n        expect('(');\n\n        if (!match(')')) {\n            options.paramSet = {};\n            while (startIndex < length) {\n                if (!parseParam(options)) {\n                    break;\n                }\n                expect(',');\n            }\n        }\n\n        expect(')');\n\n        if (options.defaultCount === 0) {\n            options.defaults = [];\n        }\n\n        return {\n            params: options.params,\n            defaults: options.defaults,\n            stricted: options.stricted,\n            firstRestricted: options.firstRestricted,\n            message: options.message\n        };\n    }\n\n    function parseFunctionDeclaration(node, identifierIsOptional) {\n        var id = null, params = [], defaults = [], body, token, stricted, tmp, firstRestricted, message, previousStrict;\n\n        expectKeyword('function');\n        if (!identifierIsOptional || !match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n\n        return node.finishFunctionDeclaration(id, params, defaults, body);\n    }\n\n    function parseFunctionExpression() {\n        var token, id = null, stricted, firstRestricted, message, tmp,\n            params = [], defaults = [], body, previousStrict, node = new Node();\n\n        expectKeyword('function');\n\n        if (!match('(')) {\n            token = lookahead;\n            id = parseVariableIdentifier();\n            if (strict) {\n                if (isRestrictedWord(token.value)) {\n                    tolerateUnexpectedToken(token, Messages.StrictFunctionName);\n                }\n            } else {\n                if (isRestrictedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictFunctionName;\n                } else if (isStrictModeReservedWord(token.value)) {\n                    firstRestricted = token;\n                    message = Messages.StrictReservedWord;\n                }\n            }\n        }\n\n        tmp = parseParams(firstRestricted);\n        params = tmp.params;\n        defaults = tmp.defaults;\n        stricted = tmp.stricted;\n        firstRestricted = tmp.firstRestricted;\n        if (tmp.message) {\n            message = tmp.message;\n        }\n\n        previousStrict = strict;\n        body = parseFunctionSourceElements();\n        if (strict && firstRestricted) {\n            throwUnexpectedToken(firstRestricted, message);\n        }\n        if (strict && stricted) {\n            tolerateUnexpectedToken(stricted, message);\n        }\n        strict = previousStrict;\n\n        return node.finishFunctionExpression(id, params, defaults, body);\n    }\n\n\n    function parseClassBody() {\n        var classBody, token, isStatic, hasConstructor = false, body, method, computed, key;\n\n        classBody = new Node();\n\n        expect('{');\n        body = [];\n        while (!match('}')) {\n            if (match(';')) {\n                lex();\n            } else {\n                method = new Node();\n                token = lookahead;\n                isStatic = false;\n                computed = match('[');\n                key = parseObjectPropertyKey();\n                if (key.name === 'static' && lookaheadPropertyName()) {\n                    token = lookahead;\n                    isStatic = true;\n                    computed = match('[');\n                    key = parseObjectPropertyKey();\n                }\n                method = tryParseMethodDefinition(token, key, computed, method);\n                if (method) {\n                    method['static'] = isStatic;\n                    if (method.kind === 'init') {\n                        method.kind = 'method';\n                    }\n                    if (!isStatic) {\n                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'constructor') {\n                            if (method.kind !== 'method' || !method.method || method.value.generator) {\n                                throwUnexpectedToken(token, Messages.ConstructorSpecialMethod);\n                            }\n                            if (hasConstructor) {\n                                throwUnexpectedToken(token, Messages.DuplicateConstructor);\n                            } else {\n                                hasConstructor = true;\n                            }\n                            method.kind = 'constructor';\n                        }\n                    } else {\n                        if (!method.computed && (method.key.name || method.key.value.toString()) === 'prototype') {\n                            throwUnexpectedToken(token, Messages.StaticPrototype);\n                        }\n                    }\n                    method.type = Syntax.MethodDefinition;\n                    delete method.method;\n                    delete method.shorthand;\n                    body.push(method);\n                } else {\n                    throwUnexpectedToken(lookahead);\n                }\n            }\n        }\n        lex();\n        return classBody.finishClassBody(body);\n    }\n\n    function parseClassDeclaration(identifierIsOptional) {\n        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;\n        strict = true;\n\n        expectKeyword('class');\n\n        if (!identifierIsOptional || lookahead.type === Token.Identifier) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            lex();\n            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n        }\n        classBody = parseClassBody();\n        strict = previousStrict;\n\n        return classNode.finishClassDeclaration(id, superClass, classBody);\n    }\n\n    function parseClassExpression() {\n        var id = null, superClass = null, classNode = new Node(), classBody, previousStrict = strict;\n        strict = true;\n\n        expectKeyword('class');\n\n        if (lookahead.type === Token.Identifier) {\n            id = parseVariableIdentifier();\n        }\n\n        if (matchKeyword('extends')) {\n            lex();\n            superClass = isolateCoverGrammar(parseLeftHandSideExpressionAllowCall);\n        }\n        classBody = parseClassBody();\n        strict = previousStrict;\n\n        return classNode.finishClassExpression(id, superClass, classBody);\n    }\n\n    // Modules grammar from:\n    // people.mozilla.org/~jorendorff/es6-draft.html\n\n    function parseModuleSpecifier() {\n        var node = new Node();\n\n        if (lookahead.type !== Token.StringLiteral) {\n            throwError(Messages.InvalidModuleSpecifier);\n        }\n        return node.finishLiteral(lex());\n    }\n\n    function parseExportSpecifier() {\n        var exported, local, node = new Node(), def;\n        if (matchKeyword('default')) {\n            // export {default} from 'something';\n            def = new Node();\n            lex();\n            local = def.finishIdentifier('default');\n        } else {\n            local = parseVariableIdentifier();\n        }\n        if (matchContextualKeyword('as')) {\n            lex();\n            exported = parseNonComputedProperty();\n        }\n        return node.finishExportSpecifier(local, exported);\n    }\n\n    function parseExportNamedDeclaration(node) {\n        var declaration = null,\n            isExportFromIdentifier,\n            src = null, specifiers = [];\n\n        // non-default export\n        if (lookahead.type === Token.Keyword) {\n            // covers:\n            // export var f = 1;\n            switch (lookahead.value) {\n                case 'let':\n                case 'const':\n                case 'var':\n                case 'class':\n                case 'function':\n                    declaration = parseStatementListItem();\n                    return node.finishExportNamedDeclaration(declaration, specifiers, null);\n            }\n        }\n\n        expect('{');\n        if (!match('}')) {\n            do {\n                isExportFromIdentifier = isExportFromIdentifier || matchKeyword('default');\n                specifiers.push(parseExportSpecifier());\n            } while (match(',') && lex());\n        }\n        expect('}');\n\n        if (matchContextualKeyword('from')) {\n            // covering:\n            // export {default} from 'foo';\n            // export {foo} from 'foo';\n            lex();\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n        } else if (isExportFromIdentifier) {\n            // covering:\n            // export {default}; // missing fromClause\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        } else {\n            // cover\n            // export {foo};\n            consumeSemicolon();\n        }\n        return node.finishExportNamedDeclaration(declaration, specifiers, src);\n    }\n\n    function parseExportDefaultDeclaration(node) {\n        var declaration = null,\n            expression = null;\n\n        // covers:\n        // export default ...\n        expectKeyword('default');\n\n        if (matchKeyword('function')) {\n            // covers:\n            // export default function foo () {}\n            // export default function () {}\n            declaration = parseFunctionDeclaration(new Node(), true);\n            return node.finishExportDefaultDeclaration(declaration);\n        }\n        if (matchKeyword('class')) {\n            declaration = parseClassDeclaration(true);\n            return node.finishExportDefaultDeclaration(declaration);\n        }\n\n        if (matchContextualKeyword('from')) {\n            throwError(Messages.UnexpectedToken, lookahead.value);\n        }\n\n        // covers:\n        // export default {};\n        // export default [];\n        // export default (1 + 2);\n        if (match('{')) {\n            expression = parseObjectInitialiser();\n        } else if (match('[')) {\n            expression = parseArrayInitialiser();\n        } else {\n            expression = parseAssignmentExpression();\n        }\n        consumeSemicolon();\n        return node.finishExportDefaultDeclaration(expression);\n    }\n\n    function parseExportAllDeclaration(node) {\n        var src;\n\n        // covers:\n        // export * from 'foo';\n        expect('*');\n        if (!matchContextualKeyword('from')) {\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return node.finishExportAllDeclaration(src);\n    }\n\n    function parseExportDeclaration() {\n        var node = new Node();\n        if (state.inFunctionBody) {\n            throwError(Messages.IllegalExportDeclaration);\n        }\n\n        expectKeyword('export');\n\n        if (matchKeyword('default')) {\n            return parseExportDefaultDeclaration(node);\n        }\n        if (match('*')) {\n            return parseExportAllDeclaration(node);\n        }\n        return parseExportNamedDeclaration(node);\n    }\n\n    function parseImportSpecifier() {\n        // import {<foo as bar>} ...;\n        var local, imported, node = new Node();\n\n        imported = parseNonComputedProperty();\n        if (matchContextualKeyword('as')) {\n            lex();\n            local = parseVariableIdentifier();\n        }\n\n        return node.finishImportSpecifier(local, imported);\n    }\n\n    function parseNamedImports() {\n        var specifiers = [];\n        // {foo, bar as bas}\n        expect('{');\n        if (!match('}')) {\n            do {\n                specifiers.push(parseImportSpecifier());\n            } while (match(',') && lex());\n        }\n        expect('}');\n        return specifiers;\n    }\n\n    function parseImportDefaultSpecifier() {\n        // import <foo> ...;\n        var local, node = new Node();\n\n        local = parseNonComputedProperty();\n\n        return node.finishImportDefaultSpecifier(local);\n    }\n\n    function parseImportNamespaceSpecifier() {\n        // import <* as foo> ...;\n        var local, node = new Node();\n\n        expect('*');\n        if (!matchContextualKeyword('as')) {\n            throwError(Messages.NoAsAfterImportNamespace);\n        }\n        lex();\n        local = parseNonComputedProperty();\n\n        return node.finishImportNamespaceSpecifier(local);\n    }\n\n    function parseImportDeclaration() {\n        var specifiers, src, node = new Node();\n\n        if (state.inFunctionBody) {\n            throwError(Messages.IllegalImportDeclaration);\n        }\n\n        expectKeyword('import');\n        specifiers = [];\n\n        if (lookahead.type === Token.StringLiteral) {\n            // covers:\n            // import 'foo';\n            src = parseModuleSpecifier();\n            consumeSemicolon();\n            return node.finishImportDeclaration(specifiers, src);\n        }\n\n        if (!matchKeyword('default') && isIdentifierName(lookahead)) {\n            // covers:\n            // import foo\n            // import foo, ...\n            specifiers.push(parseImportDefaultSpecifier());\n            if (match(',')) {\n                lex();\n            }\n        }\n        if (match('*')) {\n            // covers:\n            // import foo, * as foo\n            // import * as foo\n            specifiers.push(parseImportNamespaceSpecifier());\n        } else if (match('{')) {\n            // covers:\n            // import foo, {bar}\n            // import {bar}\n            specifiers = specifiers.concat(parseNamedImports());\n        }\n\n        if (!matchContextualKeyword('from')) {\n            throwError(lookahead.value ?\n                    Messages.UnexpectedToken : Messages.MissingFromClause, lookahead.value);\n        }\n        lex();\n        src = parseModuleSpecifier();\n        consumeSemicolon();\n\n        return node.finishImportDeclaration(specifiers, src);\n    }\n\n    // 14 Program\n\n    function parseScriptBody() {\n        var statement, body = [], token, directive, firstRestricted;\n\n        while (startIndex < length) {\n            token = lookahead;\n            if (token.type !== Token.StringLiteral) {\n                break;\n            }\n\n            statement = parseStatementListItem();\n            body.push(statement);\n            if (statement.expression.type !== Syntax.Literal) {\n                // this is not directive\n                break;\n            }\n            directive = source.slice(token.start + 1, token.end - 1);\n            if (directive === 'use strict') {\n                strict = true;\n                if (firstRestricted) {\n                    tolerateUnexpectedToken(firstRestricted, Messages.StrictOctalLiteral);\n                }\n            } else {\n                if (!firstRestricted && token.octal) {\n                    firstRestricted = token;\n                }\n            }\n        }\n\n        while (startIndex < length) {\n            statement = parseStatementListItem();\n            /* istanbul ignore if */\n            if (typeof statement === 'undefined') {\n                break;\n            }\n            body.push(statement);\n        }\n        return body;\n    }\n\n    function parseProgram() {\n        var body, node;\n\n        peek();\n        node = new Node();\n\n        body = parseScriptBody();\n        return node.finishProgram(body);\n    }\n\n    function filterTokenLocation() {\n        var i, entry, token, tokens = [];\n\n        for (i = 0; i < extra.tokens.length; ++i) {\n            entry = extra.tokens[i];\n            token = {\n                type: entry.type,\n                value: entry.value\n            };\n            if (entry.regex) {\n                token.regex = {\n                    pattern: entry.regex.pattern,\n                    flags: entry.regex.flags\n                };\n            }\n            if (extra.range) {\n                token.range = entry.range;\n            }\n            if (extra.loc) {\n                token.loc = entry.loc;\n            }\n            tokens.push(token);\n        }\n\n        extra.tokens = tokens;\n    }\n\n    function tokenize(code, options) {\n        var toString,\n            tokens;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: []\n        };\n\n        extra = {};\n\n        // Options matching.\n        options = options || {};\n\n        // Of course we collect tokens here.\n        options.tokens = true;\n        extra.tokens = [];\n        extra.tokenize = true;\n        // The following two fields are necessary to compute the Regex tokens.\n        extra.openParenToken = -1;\n        extra.openCurlyToken = -1;\n\n        extra.range = (typeof options.range === 'boolean') && options.range;\n        extra.loc = (typeof options.loc === 'boolean') && options.loc;\n\n        if (typeof options.comment === 'boolean' && options.comment) {\n            extra.comments = [];\n        }\n        if (typeof options.tolerant === 'boolean' && options.tolerant) {\n            extra.errors = [];\n        }\n\n        try {\n            peek();\n            if (lookahead.type === Token.EOF) {\n                return extra.tokens;\n            }\n\n            lex();\n            while (lookahead.type !== Token.EOF) {\n                try {\n                    lex();\n                } catch (lexError) {\n                    if (extra.errors) {\n                        recordError(lexError);\n                        // We have to break on the first error\n                        // to avoid infinite loops.\n                        break;\n                    } else {\n                        throw lexError;\n                    }\n                }\n            }\n\n            filterTokenLocation();\n            tokens = extra.tokens;\n            if (typeof extra.comments !== 'undefined') {\n                tokens.comments = extra.comments;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                tokens.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n        return tokens;\n    }\n\n    function parse(code, options) {\n        var program, toString;\n\n        toString = String;\n        if (typeof code !== 'string' && !(code instanceof String)) {\n            code = toString(code);\n        }\n\n        source = code;\n        index = 0;\n        lineNumber = (source.length > 0) ? 1 : 0;\n        lineStart = 0;\n        startIndex = index;\n        startLineNumber = lineNumber;\n        startLineStart = lineStart;\n        length = source.length;\n        lookahead = null;\n        state = {\n            allowIn: true,\n            labelSet: {},\n            inFunctionBody: false,\n            inIteration: false,\n            inSwitch: false,\n            lastCommentStart: -1,\n            curlyStack: []\n        };\n        sourceType = 'script';\n        strict = false;\n\n        extra = {};\n        if (typeof options !== 'undefined') {\n            extra.range = (typeof options.range === 'boolean') && options.range;\n            extra.loc = (typeof options.loc === 'boolean') && options.loc;\n            extra.attachComment = (typeof options.attachComment === 'boolean') && options.attachComment;\n\n            if (extra.loc && options.source !== null && options.source !== undefined) {\n                extra.source = toString(options.source);\n            }\n\n            if (typeof options.tokens === 'boolean' && options.tokens) {\n                extra.tokens = [];\n            }\n            if (typeof options.comment === 'boolean' && options.comment) {\n                extra.comments = [];\n            }\n            if (typeof options.tolerant === 'boolean' && options.tolerant) {\n                extra.errors = [];\n            }\n            if (extra.attachComment) {\n                extra.range = true;\n                extra.comments = [];\n                extra.bottomRightStack = [];\n                extra.trailingComments = [];\n                extra.leadingComments = [];\n            }\n            if (options.sourceType === 'module') {\n                // very restrictive condition for now\n                sourceType = options.sourceType;\n                strict = true;\n            }\n        }\n\n        try {\n            program = parseProgram();\n            if (typeof extra.comments !== 'undefined') {\n                program.comments = extra.comments;\n            }\n            if (typeof extra.tokens !== 'undefined') {\n                filterTokenLocation();\n                program.tokens = extra.tokens;\n            }\n            if (typeof extra.errors !== 'undefined') {\n                program.errors = extra.errors;\n            }\n        } catch (e) {\n            throw e;\n        } finally {\n            extra = {};\n        }\n\n        return program;\n    }\n\n    // Sync with *.json manifests.\n    exports.version = '2.2.0';\n\n    exports.tokenize = tokenize;\n\n    exports.parse = parse;\n\n    // Deep copy.\n    /* istanbul ignore next */\n    exports.Syntax = (function () {\n        var name, types = {};\n\n        if (typeof Object.create === 'function') {\n            types = Object.create(null);\n        }\n\n        for (name in Syntax) {\n            if (Syntax.hasOwnProperty(name)) {\n                types[name] = Syntax[name];\n            }\n        }\n\n        if (typeof Object.freeze === 'function') {\n            Object.freeze(types);\n        }\n\n        return types;\n    }());\n\n}));\n/* vim: set sw=4 ts=4 et tw=80 : */\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}