{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\nvar Format = require('./format');\nvar _require = require(\"./constants\"),\n  stylePattern = _require.stylePattern,\n  isColan = _require.isColan,\n  isSemiColan = _require.isSemiColan,\n  isStyle = _require.isStyle,\n  isColorPattern = _require.isColorPattern,\n  isStopOpacity = _require.isStopOpacity,\n  isClassPattern = _require.isClassPattern,\n  isxmlPattern = _require.isxmlPattern,\n  cssObjects = _require.cssObjects,\n  isTitle = _require.isTitle,\n  enabledBackground = _require.enabledBackground,\n  isVersion = _require.isVersion,\n  isXML = _require.isXML,\n  isAdobeComment = _require.isAdobeComment;\n/**\n * Class to create new stringed svg element\n * \n */\n\nvar Convert = /*#__PURE__*/function () {\n  /**\n   * \n   * @param {String} string - path to svg file ex: './pathto/my.svg'\n   *\n   */\n  function Convert(string) {\n    (0, _classCallCheck2[\"default\"])(this, Convert);\n    this.string = string;\n    this.svgCSS = '';\n    this.removeStyleElement = false;\n  }\n  /**\n   * @property {Function} checkString Reads file from path given by client\n   * @returns {object}\n   */\n\n  (0, _createClass2[\"default\"])(Convert, [{\n    key: \"checkString\",\n    value: function checkString(string) {\n      if (typeof this.string !== 'string') {\n        console.log('not a string');\n        return {\n          error: \"<h1>File path or file is not of string path.</h1>\"\n        };\n      } else return string;\n    }\n    /** Adds a string version of inline style element to be used as JSX\n     * @property {Function} stringify_STYLE_ELEM - Optional if user wants to leave style element in svg xml document\n     * @param {String} string - Newly indented string\n     */\n  }, {\n    key: \"stringify_STYLE_ELEM\",\n    value: function stringify_STYLE_ELEM(string) {\n      //  True to return string of <style type=\"text/css\"> .someElement{someTyle:#A5A5A5;}  </style>\n      //    <style type=\"text/css\">{\n      //            '.photo-st0{fill:#C13838;}'+\n      //        }\n      // \t  </style>\n      //  Or leave it, stringify it and use it within React\n      if (stylePattern.test(string)) {\n        if (this.removeStyleElement) {\n          this.string = this.string.replace(stylePattern, ''); // Where the svg Style element exist for client\n\n          this.svgCSS = string.match(stylePattern)[0].replace(/\\t/g, ' ');\n        } else {\n          var CSSobjects = string.match(cssObjects);\n          var length = CSSobjects.length;\n          var _toString = '';\n          for (var i = 0; i < length; i++) {\n            var element = CSSobjects[i]; // If only one css object exist\n\n            if (length === 1) {\n              _toString += element.replace(/(\\..*;})/i, '<style type=\"text/css\">{\\n\"$1\"\\n}</style>');\n              break;\n            } // Replaces first line\n\n            if (i === 0) {\n              _toString += element.replace(/(\\..*;})/i, '<style type=\"text/css\">{\\n\"$1\"+\\n');\n            } // Replaces last line\n            else if (i === length - 1) {\n              _toString += element.replace(/(\\..*;})/i, '\"$1\"\\n}</style>');\n            } // Replaces every other line\n            else {\n              _toString += element.replace(/(\\..*;})/i, ' \"$1\"+\\n');\n            }\n          }\n          return this.string.replace(/<style.*[\\s\\S]*<\\/style>/gi, _toString);\n        }\n      } else return string;\n    }\n    /**\n     * \n     * @property {Function} inlineStyleJSX - Looks for all xml attributes that need to be replaced \n     * @param {String} string string after some replacement of attributes\n     * @param {object} Format Class object to format string; callback\n     * @returns {Object} - To strings sent; One for rendered version of svg and one for copy within Textarea\n     */\n  }, {\n    key: \"inlineStyleJSX\",\n    value: function inlineStyleJSX(string, Format) {\n      var cssStringed = this.stringify_STYLE_ELEM(string);\n      var individual_lines = cssStringed.split('\\n');\n      var i = individual_lines.length;\n      var regEx = new RegExp(/(style=)\"(.*:.*;)\"/, 'i');\n      var newStyleObj = '';\n      var newSTring = []; //Goes through each line\n\n      while (i--) {\n        // Checks for only lines that contain style attributes\n        if (regEx.test(individual_lines[i])) {\n          var split_style_obj = individual_lines[i].match(regEx)[2].split(';'); // Adds quotes to the values:   [ 'display:block', 'overflow:hidden', 'height: 100', '' ]  to  display:\"block\",overflow:\"hidden\",height:\"100\"\n\n          split_style_obj.forEach(function (string) {\n            return newStyleObj += string.replace(/(.*:)(\\s?[#\\w\\d\\.]+)/, '$1\"$2\",');\n          }); // replaces style=\"display:block;overflow:hidden;height:100;\"  to  style={{display:\"block\",overflow:\"hidden\",height:\"100\"}}\n\n          var x = individual_lines[i].replace(/(style=)\"(.*:.*;)\"/i, \"$1{{\".concat(newStyleObj, \"}}\"));\n          newSTring.unshift(x + '\\n');\n          newStyleObj = '';\n        } else {\n          newSTring.unshift(individual_lines[i] + '\\n');\n        }\n      }\n      return Format.indent(newSTring.join(''));\n    }\n    /**\n     * \n     * @property {Function} findAndReplace - Looks for all xml attributes that need to be replaced \n     * @returns {Object} - To strings sent; One for rendered version of svg and one for copy within Textarea\n     */\n  }, {\n    key: \"findAndReplace\",\n    value: function findAndReplace() {\n      var _this = this;\n      var string = this.string;\n      this.checkString(string);\n      if (!(0, _typeof2[\"default\"])(string)) return \"<div>Must be a valid string</div>\";\n      if (isxmlPattern.test(string)) {\n        switch (true) {\n          case /xmlns:xlink/gi.test(string):\n            this.string = this.string.replace(/xmlns:xlink=\".+\\/xlink\"\\s/gi, '');\n          case /xml:space/gi.test(string):\n            this.string = this.string.replace(/xml:space/gi, 'xmlSpace');\n          case /xlink:href/gi.test(string):\n            this.string = this.string.replace(/xlink:href/gi, 'href');\n        }\n      }\n      /* remove typical attributes and unnedded extra left over adobe file additions */\n\n      switch (true) {\n        case enabledBackground.test(string):\n          this.string = this.string.replace(/style=\"enable-background.+\"\\s/g, '');\n        case isColorPattern.test(string):\n          this.string = this.string.replace(isColorPattern, 'stopColor');\n        case isStopOpacity.test(string):\n          this.string = this.string.replace(isStopOpacity, 'stopOpacity');\n        case isXML.test(string):\n          this.string = this.string.replace(isXML, '');\n        case isClassPattern.test(string):\n          this.string = this.string.replace(isClassPattern, 'className=');\n        case isTitle.test(string):\n          this.string = this.string.replace(/<title>.*<\\/title>/, '');\n        case isVersion.test(string):\n          this.string = this.string.replace(isVersion, '');\n        case isAdobeComment.test(string):\n          this.string = this.string.replace(isAdobeComment, '');\n      }\n      this.string = this.string.replace(/(<.*style=\"stopColor|<.*style=\"stopColor)(:.*)(\"\\/>)/gmi, '$1$2;$3'); // Remove </path> and add / to end of path =>   />\n\n      this.string = this.string.replace(/(<path.*)(>)\\n?(<\\/path>)/igm, '$1/$2');\n      function catenate(match, p1, p2, p3) {\n        return p1 + p2.toUpperCase() + p3;\n      }\n      var hasDashedAttributes = function hasDashedAttributes(string) {\n        return /\\s\\w+-\\w+=/ig.test(string);\n      }; // Checks if style attributes not concatinated exist ex: font-size => fontSize, stroke-width => strokeWidth  ...\n\n      var findAttributedDashes = function findAttributedDashes(string) {\n        var stringArr = [];\n        if (hasDashedAttributes(string)) {\n          var individual_lines = string.split('\\n');\n          var i = individual_lines.length;\n          while (i--) {\n            var attribute = individual_lines[i].match(/\\s(?:\\w|=\")+-\\w+(=|:)/ig);\n            if (attribute != null) {\n              var replaced = individual_lines[i].replace(/(\\s(?:\\w|=\")+)-(\\w)(\\w+(:|=))/i, catenate);\n              stringArr.unshift(replaced);\n            } else {\n              stringArr.unshift(individual_lines[i] + '\\n');\n            }\n          }\n          var updatedString = stringArr.join(''); // Recursion till all attributes have been concatinated\n\n          hasDashedAttributes(updatedString) ? findAttributedDashes(updatedString) : _this.string = updatedString;\n        } else {\n          _this.string = string;\n        }\n      };\n      findAttributedDashes(this.string); // Checks if inline style attributes not concatinated exist ex: style=\"font-size: 12px;\"  =>  style=\"fontSize: 12px;\" ..\n\n      var catenateStyleAttribute = function catenateStyleAttribute(string) {\n        var replaced = string.replace(/(\\sstyle=\"\\w+)-(\\w)(.*)/ig, catenate);\n        _this.string = replaced;\n      };\n      /**\n       * Format\n       * See {@link Format}\n       */\n\n      var clientCopy = this.inlineStyleJSX(this.string, Format);\n      return {\n        renderedSVG: this.string,\n        forCopy: clientCopy\n      };\n    }\n  }]);\n  return Convert;\n}();\nmodule.exports = Convert;","map":{"version":3,"names":["_interopRequireDefault","require","_typeof2","_classCallCheck2","_createClass2","Format","_require","stylePattern","isColan","isSemiColan","isStyle","isColorPattern","isStopOpacity","isClassPattern","isxmlPattern","cssObjects","isTitle","enabledBackground","isVersion","isXML","isAdobeComment","Convert","string","svgCSS","removeStyleElement","key","value","checkString","console","log","error","stringify_STYLE_ELEM","test","replace","match","CSSobjects","length","_toString","i","element","inlineStyleJSX","cssStringed","individual_lines","split","regEx","RegExp","newStyleObj","newSTring","split_style_obj","forEach","x","concat","unshift","indent","join","findAndReplace","_this","catenate","p1","p2","p3","toUpperCase","hasDashedAttributes","findAttributedDashes","stringArr","attribute","replaced","updatedString","catenateStyleAttribute","clientCopy","renderedSVG","forCopy","module","exports"],"sources":["C:/Users/SashinTulsiram/Documents/Software/react-frontend-bulma/react-app/node_modules/convert-svg-react/lib/converter/svgconverter.js"],"sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar Format = require('./format');\n\nvar _require = require(\"./constants\"),\n    stylePattern = _require.stylePattern,\n    isColan = _require.isColan,\n    isSemiColan = _require.isSemiColan,\n    isStyle = _require.isStyle,\n    isColorPattern = _require.isColorPattern,\n    isStopOpacity = _require.isStopOpacity,\n    isClassPattern = _require.isClassPattern,\n    isxmlPattern = _require.isxmlPattern,\n    cssObjects = _require.cssObjects,\n    isTitle = _require.isTitle,\n    enabledBackground = _require.enabledBackground,\n    isVersion = _require.isVersion,\n    isXML = _require.isXML,\n    isAdobeComment = _require.isAdobeComment;\n/**\n * Class to create new stringed svg element\n * \n */\n\n\nvar Convert = /*#__PURE__*/function () {\n  /**\n   * \n   * @param {String} string - path to svg file ex: './pathto/my.svg'\n   *\n   */\n  function Convert(string) {\n    (0, _classCallCheck2[\"default\"])(this, Convert);\n    this.string = string;\n    this.svgCSS = '';\n    this.removeStyleElement = false;\n  }\n  /**\n   * @property {Function} checkString Reads file from path given by client\n   * @returns {object}\n   */\n\n\n  (0, _createClass2[\"default\"])(Convert, [{\n    key: \"checkString\",\n    value: function checkString(string) {\n      if (typeof this.string !== 'string') {\n        console.log('not a string');\n        return {\n          error: \"<h1>File path or file is not of string path.</h1>\"\n        };\n      } else return string;\n    }\n    /** Adds a string version of inline style element to be used as JSX\n     * @property {Function} stringify_STYLE_ELEM - Optional if user wants to leave style element in svg xml document\n     * @param {String} string - Newly indented string\n     */\n\n  }, {\n    key: \"stringify_STYLE_ELEM\",\n    value: function stringify_STYLE_ELEM(string) {\n      //  True to return string of <style type=\"text/css\"> .someElement{someTyle:#A5A5A5;}  </style>\n      //    <style type=\"text/css\">{\n      //            '.photo-st0{fill:#C13838;}'+\n      //        }\n      // \t  </style>\n      //  Or leave it, stringify it and use it within React\n      if (stylePattern.test(string)) {\n        if (this.removeStyleElement) {\n          this.string = this.string.replace(stylePattern, ''); // Where the svg Style element exist for client\n\n          this.svgCSS = string.match(stylePattern)[0].replace(/\\t/g, ' ');\n        } else {\n          var CSSobjects = string.match(cssObjects);\n          var length = CSSobjects.length;\n          var _toString = '';\n\n          for (var i = 0; i < length; i++) {\n            var element = CSSobjects[i]; // If only one css object exist\n\n            if (length === 1) {\n              _toString += element.replace(/(\\..*;})/i, '<style type=\"text/css\">{\\n\"$1\"\\n}</style>');\n              break;\n            } // Replaces first line\n\n\n            if (i === 0) {\n              _toString += element.replace(/(\\..*;})/i, '<style type=\"text/css\">{\\n\"$1\"+\\n');\n            } // Replaces last line\n            else if (i === length - 1) {\n              _toString += element.replace(/(\\..*;})/i, '\"$1\"\\n}</style>');\n            } // Replaces every other line\n            else {\n              _toString += element.replace(/(\\..*;})/i, ' \"$1\"+\\n');\n            }\n          }\n\n          return this.string.replace(/<style.*[\\s\\S]*<\\/style>/gi, _toString);\n        }\n      } else return string;\n    }\n    /**\n     * \n     * @property {Function} inlineStyleJSX - Looks for all xml attributes that need to be replaced \n     * @param {String} string string after some replacement of attributes\n     * @param {object} Format Class object to format string; callback\n     * @returns {Object} - To strings sent; One for rendered version of svg and one for copy within Textarea\n     */\n\n  }, {\n    key: \"inlineStyleJSX\",\n    value: function inlineStyleJSX(string, Format) {\n      var cssStringed = this.stringify_STYLE_ELEM(string);\n      var individual_lines = cssStringed.split('\\n');\n      var i = individual_lines.length;\n      var regEx = new RegExp(/(style=)\"(.*:.*;)\"/, 'i');\n      var newStyleObj = '';\n      var newSTring = []; //Goes through each line\n\n      while (i--) {\n        // Checks for only lines that contain style attributes\n        if (regEx.test(individual_lines[i])) {\n          var split_style_obj = individual_lines[i].match(regEx)[2].split(';'); // Adds quotes to the values:   [ 'display:block', 'overflow:hidden', 'height: 100', '' ]  to  display:\"block\",overflow:\"hidden\",height:\"100\"\n\n          split_style_obj.forEach(function (string) {\n            return newStyleObj += string.replace(/(.*:)(\\s?[#\\w\\d\\.]+)/, '$1\"$2\",');\n          }); // replaces style=\"display:block;overflow:hidden;height:100;\"  to  style={{display:\"block\",overflow:\"hidden\",height:\"100\"}}\n\n          var x = individual_lines[i].replace(/(style=)\"(.*:.*;)\"/i, \"$1{{\".concat(newStyleObj, \"}}\"));\n          newSTring.unshift(x + '\\n');\n          newStyleObj = '';\n        } else {\n          newSTring.unshift(individual_lines[i] + '\\n');\n        }\n      }\n\n      return Format.indent(newSTring.join(''));\n    }\n    /**\n     * \n     * @property {Function} findAndReplace - Looks for all xml attributes that need to be replaced \n     * @returns {Object} - To strings sent; One for rendered version of svg and one for copy within Textarea\n     */\n\n  }, {\n    key: \"findAndReplace\",\n    value: function findAndReplace() {\n      var _this = this;\n\n      var string = this.string;\n      this.checkString(string);\n      if (!(0, _typeof2[\"default\"])(string)) return \"<div>Must be a valid string</div>\";\n\n      if (isxmlPattern.test(string)) {\n        switch (true) {\n          case /xmlns:xlink/gi.test(string):\n            this.string = this.string.replace(/xmlns:xlink=\".+\\/xlink\"\\s/gi, '');\n\n          case /xml:space/gi.test(string):\n            this.string = this.string.replace(/xml:space/gi, 'xmlSpace');\n\n          case /xlink:href/gi.test(string):\n            this.string = this.string.replace(/xlink:href/gi, 'href');\n        }\n      }\n      /* remove typical attributes and unnedded extra left over adobe file additions */\n\n\n      switch (true) {\n        case enabledBackground.test(string):\n          this.string = this.string.replace(/style=\"enable-background.+\"\\s/g, '');\n\n        case isColorPattern.test(string):\n          this.string = this.string.replace(isColorPattern, 'stopColor');\n\n        case isStopOpacity.test(string):\n          this.string = this.string.replace(isStopOpacity, 'stopOpacity');\n\n        case isXML.test(string):\n          this.string = this.string.replace(isXML, '');\n\n        case isClassPattern.test(string):\n          this.string = this.string.replace(isClassPattern, 'className=');\n\n        case isTitle.test(string):\n          this.string = this.string.replace(/<title>.*<\\/title>/, '');\n\n        case isVersion.test(string):\n          this.string = this.string.replace(isVersion, '');\n\n        case isAdobeComment.test(string):\n          this.string = this.string.replace(isAdobeComment, '');\n      }\n\n      this.string = this.string.replace(/(<.*style=\"stopColor|<.*style=\"stopColor)(:.*)(\"\\/>)/gmi, '$1$2;$3'); // Remove </path> and add / to end of path =>   />\n\n      this.string = this.string.replace(/(<path.*)(>)\\n?(<\\/path>)/igm, '$1/$2');\n\n      function catenate(match, p1, p2, p3) {\n        return p1 + p2.toUpperCase() + p3;\n      }\n\n      var hasDashedAttributes = function hasDashedAttributes(string) {\n        return /\\s\\w+-\\w+=/ig.test(string);\n      }; // Checks if style attributes not concatinated exist ex: font-size => fontSize, stroke-width => strokeWidth  ...\n\n\n      var findAttributedDashes = function findAttributedDashes(string) {\n        var stringArr = [];\n\n        if (hasDashedAttributes(string)) {\n          var individual_lines = string.split('\\n');\n          var i = individual_lines.length;\n\n          while (i--) {\n            var attribute = individual_lines[i].match(/\\s(?:\\w|=\")+-\\w+(=|:)/ig);\n\n            if (attribute != null) {\n              var replaced = individual_lines[i].replace(/(\\s(?:\\w|=\")+)-(\\w)(\\w+(:|=))/i, catenate);\n              stringArr.unshift(replaced);\n            } else {\n              stringArr.unshift(individual_lines[i] + '\\n');\n            }\n          }\n\n          var updatedString = stringArr.join(''); // Recursion till all attributes have been concatinated\n\n          hasDashedAttributes(updatedString) ? findAttributedDashes(updatedString) : _this.string = updatedString;\n        } else {\n          _this.string = string;\n        }\n      };\n\n      findAttributedDashes(this.string); // Checks if inline style attributes not concatinated exist ex: style=\"font-size: 12px;\"  =>  style=\"fontSize: 12px;\" ..\n\n      var catenateStyleAttribute = function catenateStyleAttribute(string) {\n        var replaced = string.replace(/(\\sstyle=\"\\w+)-(\\w)(.*)/ig, catenate);\n        _this.string = replaced;\n      };\n      /**\n       * Format\n       * See {@link Format}\n       */\n\n\n      var clientCopy = this.inlineStyleJSX(this.string, Format);\n      return {\n        renderedSVG: this.string,\n        forCopy: clientCopy\n      };\n    }\n  }]);\n  return Convert;\n}();\n\nmodule.exports = Convert;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}