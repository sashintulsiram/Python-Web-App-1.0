{"ast":null,"code":"'use strict';\n\n/*eslint-disable no-use-before-define*/\nvar common = require('./common');\nvar YAMLException = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\nvar _toString = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\nvar CHAR_TAB = 0x09; /* Tab */\nvar CHAR_LINE_FEED = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN = 0x0D; /* CR */\nvar CHAR_SPACE = 0x20; /* Space */\nvar CHAR_EXCLAMATION = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE = 0x22; /* \" */\nvar CHAR_SHARP = 0x23; /* # */\nvar CHAR_PERCENT = 0x25; /* % */\nvar CHAR_AMPERSAND = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE = 0x27; /* ' */\nvar CHAR_ASTERISK = 0x2A; /* * */\nvar CHAR_COMMA = 0x2C; /* , */\nvar CHAR_MINUS = 0x2D; /* - */\nvar CHAR_COLON = 0x3A; /* : */\nvar CHAR_GREATER_THAN = 0x3E; /* > */\nvar CHAR_QUESTION = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\nESCAPE_SEQUENCES[0x00] = '\\\\0';\nESCAPE_SEQUENCES[0x07] = '\\\\a';\nESCAPE_SEQUENCES[0x08] = '\\\\b';\nESCAPE_SEQUENCES[0x09] = '\\\\t';\nESCAPE_SEQUENCES[0x0A] = '\\\\n';\nESCAPE_SEQUENCES[0x0B] = '\\\\v';\nESCAPE_SEQUENCES[0x0C] = '\\\\f';\nESCAPE_SEQUENCES[0x0D] = '\\\\r';\nESCAPE_SEQUENCES[0x1B] = '\\\\e';\nESCAPE_SEQUENCES[0x22] = '\\\\\"';\nESCAPE_SEQUENCES[0x5C] = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85] = '\\\\N';\nESCAPE_SEQUENCES[0xA0] = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\nvar DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n  if (null === map) {\n    return {};\n  }\n  result = {};\n  keys = Object.keys(map);\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n    if ('!!' === tag.slice(0, 2)) {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n    type = schema.compiledTypeMap[tag];\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n    result[tag] = style;\n  }\n  return result;\n}\nfunction encodeHex(character) {\n  var string, handle, length;\n  string = character.toString(16).toUpperCase();\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\nfunction State(options) {\n  this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent = Math.max(1, options['indent'] || 2);\n  this.skipInvalid = options['skipInvalid'] || false;\n  this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];\n  this.styleMap = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys = options['sortKeys'] || false;\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n  this.tag = null;\n  this.result = '';\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n    position = 0,\n    next = -1,\n    result = '',\n    line,\n    length = string.length;\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n    if (line.length && line !== '\\n') {\n      result += ind;\n    }\n    result += line;\n  }\n  return result;\n}\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction StringBuilder(source) {\n  this.source = source;\n  this.result = '';\n  this.checkpoint = 0;\n}\nStringBuilder.prototype.takeUpTo = function (position) {\n  var er;\n  if (position < this.checkpoint) {\n    er = new Error('position should be > checkpoint');\n    er.position = position;\n    er.checkpoint = this.checkpoint;\n    throw er;\n  }\n  this.result += this.source.slice(this.checkpoint, position);\n  this.checkpoint = position;\n  return this;\n};\nStringBuilder.prototype.escapeChar = function () {\n  var character, esc;\n  character = this.source.charCodeAt(this.checkpoint);\n  esc = ESCAPE_SEQUENCES[character] || encodeHex(character);\n  this.result += esc;\n  this.checkpoint += 1;\n  return this;\n};\nStringBuilder.prototype.finish = function () {\n  if (this.source.length > this.checkpoint) {\n    this.takeUpTo(this.source.length);\n  }\n};\nfunction writeScalar(state, object, level) {\n  var simple, first, spaceWrap, folded, literal, single, double, sawLineFeed, linePosition, longestLine, indent, max, character, position, escapeSeq, hexEsc, previous, lineLength, modifier, trailingLineBreaks, result;\n  if (0 === object.length) {\n    state.dump = \"''\";\n    return;\n  }\n  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {\n    state.dump = \"'\" + object + \"'\";\n    return;\n  }\n  simple = true;\n  first = object.length ? object.charCodeAt(0) : 0;\n  spaceWrap = CHAR_SPACE === first || CHAR_SPACE === object.charCodeAt(object.length - 1);\n\n  // Simplified check for restricted first characters\n  // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29\n  if (CHAR_MINUS === first || CHAR_QUESTION === first || CHAR_COMMERCIAL_AT === first || CHAR_GRAVE_ACCENT === first) {\n    simple = false;\n  }\n\n  // can only use > and | if not wrapped in spaces.\n  if (spaceWrap) {\n    simple = false;\n    folded = false;\n    literal = false;\n  } else {\n    folded = true;\n    literal = true;\n  }\n  single = true;\n  double = new StringBuilder(object);\n  sawLineFeed = false;\n  linePosition = 0;\n  longestLine = 0;\n  indent = state.indent * level;\n  max = 80;\n  if (indent < 40) {\n    max -= indent;\n  } else {\n    max = 40;\n  }\n  for (position = 0; position < object.length; position++) {\n    character = object.charCodeAt(position);\n    if (simple) {\n      // Characters that can never appear in the simple scalar\n      if (!simpleChar(character)) {\n        simple = false;\n      } else {\n        // Still simple.  If we make it all the way through like\n        // this, then we can just dump the string as-is.\n        continue;\n      }\n    }\n    if (single && character === CHAR_SINGLE_QUOTE) {\n      single = false;\n    }\n    escapeSeq = ESCAPE_SEQUENCES[character];\n    hexEsc = needsHexEscape(character);\n    if (!escapeSeq && !hexEsc) {\n      continue;\n    }\n    if (character !== CHAR_LINE_FEED && character !== CHAR_DOUBLE_QUOTE && character !== CHAR_SINGLE_QUOTE) {\n      folded = false;\n      literal = false;\n    } else if (character === CHAR_LINE_FEED) {\n      sawLineFeed = true;\n      single = false;\n      if (position > 0) {\n        previous = object.charCodeAt(position - 1);\n        if (previous === CHAR_SPACE) {\n          literal = false;\n          folded = false;\n        }\n      }\n      if (folded) {\n        lineLength = position - linePosition;\n        linePosition = position;\n        if (lineLength > longestLine) {\n          longestLine = lineLength;\n        }\n      }\n    }\n    if (character !== CHAR_DOUBLE_QUOTE) {\n      single = false;\n    }\n    double.takeUpTo(position);\n    double.escapeChar();\n  }\n  if (simple && testImplicitResolving(state, object)) {\n    simple = false;\n  }\n  modifier = '';\n  if (folded || literal) {\n    trailingLineBreaks = 0;\n    if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {\n      trailingLineBreaks += 1;\n      if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {\n        trailingLineBreaks += 1;\n      }\n    }\n    if (trailingLineBreaks === 0) {\n      modifier = '-';\n    } else if (trailingLineBreaks === 2) {\n      modifier = '+';\n    }\n  }\n  if (literal && longestLine < max) {\n    folded = false;\n  }\n\n  // If it's literally one line, then don't bother with the literal.\n  // We may still want to do a fold, though, if it's a super long line.\n  if (!sawLineFeed) {\n    literal = false;\n  }\n  if (simple) {\n    state.dump = object;\n  } else if (single) {\n    state.dump = '\\'' + object + '\\'';\n  } else if (folded) {\n    result = fold(object, max);\n    state.dump = '>' + modifier + '\\n' + indentString(result, indent);\n  } else if (literal) {\n    if (!modifier) {\n      object = object.replace(/\\n$/, '');\n    }\n    state.dump = '|' + modifier + '\\n' + indentString(object, indent);\n  } else if (double) {\n    double.finish();\n    state.dump = '\"' + double.result + '\"';\n  } else {\n    throw new Error('Failed to dump scalar value');\n  }\n  return;\n}\n\n// The `trailing` var is a regexp match of any trailing `\\n` characters.\n//\n// There are three cases we care about:\n//\n// 1. One trailing `\\n` on the string.  Just use `|` or `>`.\n//    This is the assumed default. (trailing = null)\n// 2. No trailing `\\n` on the string.  Use `|-` or `>-` to \"chomp\" the end.\n// 3. More than one trailing `\\n` on the string.  Use `|+` or `>+`.\n//\n// In the case of `>+`, these line breaks are *not* doubled (like the line\n// breaks within the string), so it's important to only end with the exact\n// same number as we started.\nfunction fold(object, max) {\n  var result = '',\n    position = 0,\n    length = object.length,\n    trailing = /\\n+$/.exec(object),\n    newLine;\n  if (trailing) {\n    length = trailing.index + 1;\n  }\n  while (position < length) {\n    newLine = object.indexOf('\\n', position);\n    if (newLine > length || newLine === -1) {\n      if (result) {\n        result += '\\n\\n';\n      }\n      result += foldLine(object.slice(position, length), max);\n      position = length;\n    } else {\n      if (result) {\n        result += '\\n\\n';\n      }\n      result += foldLine(object.slice(position, newLine), max);\n      position = newLine + 1;\n    }\n  }\n  if (trailing && trailing[0] !== '\\n') {\n    result += trailing[0];\n  }\n  return result;\n}\nfunction foldLine(line, max) {\n  if (line === '') {\n    return line;\n  }\n  var foldRe = /[^\\s] [^\\s]/g,\n    result = '',\n    prevMatch = 0,\n    foldStart = 0,\n    match = foldRe.exec(line),\n    index,\n    foldEnd,\n    folded;\n  while (match) {\n    index = match.index;\n\n    // when we cross the max len, if the previous match would've\n    // been ok, use that one, and carry on.  If there was no previous\n    // match on this fold section, then just have a long line.\n    if (index - foldStart > max) {\n      if (prevMatch !== foldStart) {\n        foldEnd = prevMatch;\n      } else {\n        foldEnd = index;\n      }\n      if (result) {\n        result += '\\n';\n      }\n      folded = line.slice(foldStart, foldEnd);\n      result += folded;\n      foldStart = foldEnd + 1;\n    }\n    prevMatch = index + 1;\n    match = foldRe.exec(line);\n  }\n  if (result) {\n    result += '\\n';\n  }\n\n  // if we end up with one last word at the end, then the last bit might\n  // be slightly bigger than we wanted, because we exited out of the loop.\n  if (foldStart !== prevMatch && line.length - foldStart > max) {\n    result += line.slice(foldStart, prevMatch) + '\\n' + line.slice(prevMatch + 1);\n  } else {\n    result += line.slice(foldStart);\n  }\n  return result;\n}\n\n// Returns true if character can be found in a simple scalar\nfunction simpleChar(character) {\n  return CHAR_TAB !== character && CHAR_LINE_FEED !== character && CHAR_CARRIAGE_RETURN !== character && CHAR_COMMA !== character && CHAR_LEFT_SQUARE_BRACKET !== character && CHAR_RIGHT_SQUARE_BRACKET !== character && CHAR_LEFT_CURLY_BRACKET !== character && CHAR_RIGHT_CURLY_BRACKET !== character && CHAR_SHARP !== character && CHAR_AMPERSAND !== character && CHAR_ASTERISK !== character && CHAR_EXCLAMATION !== character && CHAR_VERTICAL_LINE !== character && CHAR_GREATER_THAN !== character && CHAR_SINGLE_QUOTE !== character && CHAR_DOUBLE_QUOTE !== character && CHAR_PERCENT !== character && CHAR_COLON !== character && !ESCAPE_SEQUENCES[character] && !needsHexEscape(character);\n}\n\n// Returns true if the character code needs to be escaped.\nfunction needsHexEscape(character) {\n  return !(0x00020 <= character && character <= 0x00007E || 0x00085 === character || 0x000A0 <= character && character <= 0x00D7FF || 0x0E000 <= character && character <= 0x00FFFD || 0x10000 <= character && character <= 0x10FFFF);\n}\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n    _tag = state.tag,\n    index,\n    length;\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (0 !== index) {\n        _result += ', ';\n      }\n      _result += state.dump;\n    }\n  }\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n    _tag = state.tag,\n    index,\n    length;\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || 0 !== index) {\n        _result += generateNextLine(state, level);\n      }\n      _result += '- ' + state.dump;\n    }\n  }\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result = '',\n    _tag = state.tag,\n    objectKeyList = Object.keys(object),\n    index,\n    length,\n    objectKey,\n    objectValue,\n    pairBuffer;\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n    if (0 !== index) {\n      pairBuffer += ', ';\n    }\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) {\n      pairBuffer += '? ';\n    }\n    pairBuffer += state.dump + ': ';\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result = '',\n    _tag = state.tag,\n    objectKeyList = Object.keys(object),\n    index,\n    length,\n    objectKey,\n    objectValue,\n    explicitPair,\n    pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n    if (!compact || 0 !== index) {\n      pairBuffer += generateNextLine(state, level);\n    }\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n    if (!writeNode(state, level + 1, objectKey, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = null !== state.tag && '?' !== state.tag || state.dump && state.dump.length > 1024;\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n    pairBuffer += state.dump;\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n    if ((type.instanceOf || type.predicate) && (!type.instanceOf || 'object' === typeof object && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {\n      state.tag = explicit ? type.tag : '?';\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n        if ('[object Function]' === _toString.call(type.represent)) {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n        state.dump = _result;\n      }\n      return true;\n    }\n  }\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact) {\n  state.tag = null;\n  state.dump = object;\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n  var type = _toString.call(state.dump);\n  if (block) {\n    block = 0 > state.flowLevel || state.flowLevel > level;\n  }\n  if (null !== state.tag && '?' !== state.tag || 2 !== state.indent && level > 0) {\n    compact = false;\n  }\n  var objectOrArray = '[object Object]' === type || '[object Array]' === type,\n    duplicateIndex,\n    duplicate;\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if ('[object Object]' === type) {\n      if (block && 0 !== Object.keys(state.dump).length) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\\n' : '') + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if ('[object Array]' === type) {\n      if (block && 0 !== state.dump.length) {\n        writeBlockSequence(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\\n' : '') + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if ('[object String]' === type) {\n      if ('?' !== state.tag) {\n        writeScalar(state, state.dump, level);\n      }\n    } else {\n      if (state.skipInvalid) {\n        return false;\n      }\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n    if (null !== state.tag && '?' !== state.tag) {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n  return true;\n}\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n    duplicatesIndexes = [],\n    index,\n    length;\n  inspectNode(object, objects, duplicatesIndexes);\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var type = _toString.call(object),\n    objectKeyList,\n    index,\n    length;\n  if (null !== object && 'object' === typeof object) {\n    index = objects.indexOf(object);\n    if (-1 !== index) {\n      if (-1 === duplicatesIndexes.indexOf(index)) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\nfunction dump(input, options) {\n  options = options || {};\n  var state = new State(options);\n  getDuplicateReferences(input, state);\n  if (writeNode(state, 0, input, true, true)) {\n    return state.dump + '\\n';\n  }\n  return '';\n}\nfunction safeDump(input, options) {\n  return dump(input, common.extend({\n    schema: DEFAULT_SAFE_SCHEMA\n  }, options));\n}\nmodule.exports.dump = dump;\nmodule.exports.safeDump = safeDump;","map":{"version":3,"names":["common","require","YAMLException","DEFAULT_FULL_SCHEMA","DEFAULT_SAFE_SCHEMA","_toString","Object","prototype","toString","_hasOwnProperty","hasOwnProperty","CHAR_TAB","CHAR_LINE_FEED","CHAR_CARRIAGE_RETURN","CHAR_SPACE","CHAR_EXCLAMATION","CHAR_DOUBLE_QUOTE","CHAR_SHARP","CHAR_PERCENT","CHAR_AMPERSAND","CHAR_SINGLE_QUOTE","CHAR_ASTERISK","CHAR_COMMA","CHAR_MINUS","CHAR_COLON","CHAR_GREATER_THAN","CHAR_QUESTION","CHAR_COMMERCIAL_AT","CHAR_LEFT_SQUARE_BRACKET","CHAR_RIGHT_SQUARE_BRACKET","CHAR_GRAVE_ACCENT","CHAR_LEFT_CURLY_BRACKET","CHAR_VERTICAL_LINE","CHAR_RIGHT_CURLY_BRACKET","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","compileStyleMap","schema","map","result","keys","index","length","tag","style","type","String","slice","compiledTypeMap","call","styleAliases","encodeHex","character","string","handle","toUpperCase","repeat","State","options","indent","Math","max","skipInvalid","flowLevel","isNothing","styleMap","sortKeys","implicitTypes","compiledImplicit","explicitTypes","compiledExplicit","duplicates","usedDuplicates","indentString","spaces","ind","position","next","line","indexOf","generateNextLine","state","level","testImplicitResolving","str","resolve","StringBuilder","source","checkpoint","takeUpTo","er","Error","escapeChar","esc","charCodeAt","finish","writeScalar","object","simple","first","spaceWrap","folded","literal","single","double","sawLineFeed","linePosition","longestLine","escapeSeq","hexEsc","previous","lineLength","modifier","trailingLineBreaks","dump","simpleChar","needsHexEscape","fold","replace","trailing","exec","newLine","foldLine","foldRe","prevMatch","foldStart","match","foldEnd","writeFlowSequence","_result","_tag","writeNode","writeBlockSequence","compact","writeFlowMapping","objectKeyList","objectKey","objectValue","pairBuffer","writeBlockMapping","explicitPair","sort","detectType","explicit","typeList","instanceOf","predicate","represent","defaultStyle","block","objectOrArray","duplicateIndex","duplicate","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","push","Array","isArray","input","safeDump","extend","module","exports"],"sources":["C:/Users/SashinTulsiram/Documents/Software/react-frontend-bulma/node_modules/svgo/node_modules/js-yaml/lib/js-yaml/dumper.js"],"sourcesContent":["'use strict';\n\n/*eslint-disable no-use-before-define*/\n\nvar common              = require('./common');\nvar YAMLException       = require('./exception');\nvar DEFAULT_FULL_SCHEMA = require('./schema/default_full');\nvar DEFAULT_SAFE_SCHEMA = require('./schema/default_safe');\n\nvar _toString       = Object.prototype.toString;\nvar _hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar CHAR_TAB                  = 0x09; /* Tab */\nvar CHAR_LINE_FEED            = 0x0A; /* LF */\nvar CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\nvar CHAR_SPACE                = 0x20; /* Space */\nvar CHAR_EXCLAMATION          = 0x21; /* ! */\nvar CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\nvar CHAR_SHARP                = 0x23; /* # */\nvar CHAR_PERCENT              = 0x25; /* % */\nvar CHAR_AMPERSAND            = 0x26; /* & */\nvar CHAR_SINGLE_QUOTE         = 0x27; /* ' */\nvar CHAR_ASTERISK             = 0x2A; /* * */\nvar CHAR_COMMA                = 0x2C; /* , */\nvar CHAR_MINUS                = 0x2D; /* - */\nvar CHAR_COLON                = 0x3A; /* : */\nvar CHAR_GREATER_THAN         = 0x3E; /* > */\nvar CHAR_QUESTION             = 0x3F; /* ? */\nvar CHAR_COMMERCIAL_AT        = 0x40; /* @ */\nvar CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\nvar CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\nvar CHAR_GRAVE_ACCENT         = 0x60; /* ` */\nvar CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\nvar CHAR_VERTICAL_LINE        = 0x7C; /* | */\nvar CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\nvar ESCAPE_SEQUENCES = {};\n\nESCAPE_SEQUENCES[0x00]   = '\\\\0';\nESCAPE_SEQUENCES[0x07]   = '\\\\a';\nESCAPE_SEQUENCES[0x08]   = '\\\\b';\nESCAPE_SEQUENCES[0x09]   = '\\\\t';\nESCAPE_SEQUENCES[0x0A]   = '\\\\n';\nESCAPE_SEQUENCES[0x0B]   = '\\\\v';\nESCAPE_SEQUENCES[0x0C]   = '\\\\f';\nESCAPE_SEQUENCES[0x0D]   = '\\\\r';\nESCAPE_SEQUENCES[0x1B]   = '\\\\e';\nESCAPE_SEQUENCES[0x22]   = '\\\\\"';\nESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\nESCAPE_SEQUENCES[0x85]   = '\\\\N';\nESCAPE_SEQUENCES[0xA0]   = '\\\\_';\nESCAPE_SEQUENCES[0x2028] = '\\\\L';\nESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\nvar DEPRECATED_BOOLEANS_SYNTAX = [\n  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n];\n\nfunction compileStyleMap(schema, map) {\n  var result, keys, index, length, tag, style, type;\n\n  if (null === map) {\n    return {};\n  }\n\n  result = {};\n  keys = Object.keys(map);\n\n  for (index = 0, length = keys.length; index < length; index += 1) {\n    tag = keys[index];\n    style = String(map[tag]);\n\n    if ('!!' === tag.slice(0, 2)) {\n      tag = 'tag:yaml.org,2002:' + tag.slice(2);\n    }\n\n    type = schema.compiledTypeMap[tag];\n\n    if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n      style = type.styleAliases[style];\n    }\n\n    result[tag] = style;\n  }\n\n  return result;\n}\n\nfunction encodeHex(character) {\n  var string, handle, length;\n\n  string = character.toString(16).toUpperCase();\n\n  if (character <= 0xFF) {\n    handle = 'x';\n    length = 2;\n  } else if (character <= 0xFFFF) {\n    handle = 'u';\n    length = 4;\n  } else if (character <= 0xFFFFFFFF) {\n    handle = 'U';\n    length = 8;\n  } else {\n    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');\n  }\n\n  return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n}\n\nfunction State(options) {\n  this.schema      = options['schema'] || DEFAULT_FULL_SCHEMA;\n  this.indent      = Math.max(1, (options['indent'] || 2));\n  this.skipInvalid = options['skipInvalid'] || false;\n  this.flowLevel   = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n  this.styleMap    = compileStyleMap(this.schema, options['styles'] || null);\n  this.sortKeys    = options['sortKeys'] || false;\n\n  this.implicitTypes = this.schema.compiledImplicit;\n  this.explicitTypes = this.schema.compiledExplicit;\n\n  this.tag = null;\n  this.result = '';\n\n  this.duplicates = [];\n  this.usedDuplicates = null;\n}\n\nfunction indentString(string, spaces) {\n  var ind = common.repeat(' ', spaces),\n      position = 0,\n      next = -1,\n      result = '',\n      line,\n      length = string.length;\n\n  while (position < length) {\n    next = string.indexOf('\\n', position);\n    if (next === -1) {\n      line = string.slice(position);\n      position = length;\n    } else {\n      line = string.slice(position, next + 1);\n      position = next + 1;\n    }\n    if (line.length && line !== '\\n') {\n      result += ind;\n    }\n    result += line;\n  }\n\n  return result;\n}\n\nfunction generateNextLine(state, level) {\n  return '\\n' + common.repeat(' ', state.indent * level);\n}\n\nfunction testImplicitResolving(state, str) {\n  var index, length, type;\n\n  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n    type = state.implicitTypes[index];\n\n    if (type.resolve(str)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction StringBuilder(source) {\n  this.source = source;\n  this.result = '';\n  this.checkpoint = 0;\n}\n\nStringBuilder.prototype.takeUpTo = function (position) {\n  var er;\n\n  if (position < this.checkpoint) {\n    er = new Error('position should be > checkpoint');\n    er.position = position;\n    er.checkpoint = this.checkpoint;\n    throw er;\n  }\n\n  this.result += this.source.slice(this.checkpoint, position);\n  this.checkpoint = position;\n  return this;\n};\n\nStringBuilder.prototype.escapeChar = function () {\n  var character, esc;\n\n  character = this.source.charCodeAt(this.checkpoint);\n  esc = ESCAPE_SEQUENCES[character] || encodeHex(character);\n  this.result += esc;\n  this.checkpoint += 1;\n\n  return this;\n};\n\nStringBuilder.prototype.finish = function () {\n  if (this.source.length > this.checkpoint) {\n    this.takeUpTo(this.source.length);\n  }\n};\n\nfunction writeScalar(state, object, level) {\n  var simple, first, spaceWrap, folded, literal, single, double,\n      sawLineFeed, linePosition, longestLine, indent, max, character,\n      position, escapeSeq, hexEsc, previous, lineLength, modifier,\n      trailingLineBreaks, result;\n\n  if (0 === object.length) {\n    state.dump = \"''\";\n    return;\n  }\n\n  if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {\n    state.dump = \"'\" + object + \"'\";\n    return;\n  }\n\n  simple = true;\n  first = object.length ? object.charCodeAt(0) : 0;\n  spaceWrap = (CHAR_SPACE === first ||\n               CHAR_SPACE === object.charCodeAt(object.length - 1));\n\n  // Simplified check for restricted first characters\n  // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29\n  if (CHAR_MINUS         === first ||\n      CHAR_QUESTION      === first ||\n      CHAR_COMMERCIAL_AT === first ||\n      CHAR_GRAVE_ACCENT  === first) {\n    simple = false;\n  }\n\n  // can only use > and | if not wrapped in spaces.\n  if (spaceWrap) {\n    simple = false;\n    folded = false;\n    literal = false;\n  } else {\n    folded = true;\n    literal = true;\n  }\n\n  single = true;\n  double = new StringBuilder(object);\n\n  sawLineFeed = false;\n  linePosition = 0;\n  longestLine = 0;\n\n  indent = state.indent * level;\n  max = 80;\n  if (indent < 40) {\n    max -= indent;\n  } else {\n    max = 40;\n  }\n\n  for (position = 0; position < object.length; position++) {\n    character = object.charCodeAt(position);\n    if (simple) {\n      // Characters that can never appear in the simple scalar\n      if (!simpleChar(character)) {\n        simple = false;\n      } else {\n        // Still simple.  If we make it all the way through like\n        // this, then we can just dump the string as-is.\n        continue;\n      }\n    }\n\n    if (single && character === CHAR_SINGLE_QUOTE) {\n      single = false;\n    }\n\n    escapeSeq = ESCAPE_SEQUENCES[character];\n    hexEsc = needsHexEscape(character);\n\n    if (!escapeSeq && !hexEsc) {\n      continue;\n    }\n\n    if (character !== CHAR_LINE_FEED &&\n        character !== CHAR_DOUBLE_QUOTE &&\n        character !== CHAR_SINGLE_QUOTE) {\n      folded = false;\n      literal = false;\n    } else if (character === CHAR_LINE_FEED) {\n      sawLineFeed = true;\n      single = false;\n      if (position > 0) {\n        previous = object.charCodeAt(position - 1);\n        if (previous === CHAR_SPACE) {\n          literal = false;\n          folded = false;\n        }\n      }\n      if (folded) {\n        lineLength = position - linePosition;\n        linePosition = position;\n        if (lineLength > longestLine) {\n          longestLine = lineLength;\n        }\n      }\n    }\n\n    if (character !== CHAR_DOUBLE_QUOTE) {\n      single = false;\n    }\n\n    double.takeUpTo(position);\n    double.escapeChar();\n  }\n\n  if (simple && testImplicitResolving(state, object)) {\n    simple = false;\n  }\n\n  modifier = '';\n  if (folded || literal) {\n    trailingLineBreaks = 0;\n    if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {\n      trailingLineBreaks += 1;\n      if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {\n        trailingLineBreaks += 1;\n      }\n    }\n\n    if (trailingLineBreaks === 0) {\n      modifier = '-';\n    } else if (trailingLineBreaks === 2) {\n      modifier = '+';\n    }\n  }\n\n  if (literal && longestLine < max) {\n    folded = false;\n  }\n\n  // If it's literally one line, then don't bother with the literal.\n  // We may still want to do a fold, though, if it's a super long line.\n  if (!sawLineFeed) {\n    literal = false;\n  }\n\n  if (simple) {\n    state.dump = object;\n  } else if (single) {\n    state.dump = '\\'' + object + '\\'';\n  } else if (folded) {\n    result = fold(object, max);\n    state.dump = '>' + modifier + '\\n' + indentString(result, indent);\n  } else if (literal) {\n    if (!modifier) {\n      object = object.replace(/\\n$/, '');\n    }\n    state.dump = '|' + modifier + '\\n' + indentString(object, indent);\n  } else if (double) {\n    double.finish();\n    state.dump = '\"' + double.result + '\"';\n  } else {\n    throw new Error('Failed to dump scalar value');\n  }\n\n  return;\n}\n\n// The `trailing` var is a regexp match of any trailing `\\n` characters.\n//\n// There are three cases we care about:\n//\n// 1. One trailing `\\n` on the string.  Just use `|` or `>`.\n//    This is the assumed default. (trailing = null)\n// 2. No trailing `\\n` on the string.  Use `|-` or `>-` to \"chomp\" the end.\n// 3. More than one trailing `\\n` on the string.  Use `|+` or `>+`.\n//\n// In the case of `>+`, these line breaks are *not* doubled (like the line\n// breaks within the string), so it's important to only end with the exact\n// same number as we started.\nfunction fold(object, max) {\n  var result = '',\n      position = 0,\n      length = object.length,\n      trailing = /\\n+$/.exec(object),\n      newLine;\n\n  if (trailing) {\n    length = trailing.index + 1;\n  }\n\n  while (position < length) {\n    newLine = object.indexOf('\\n', position);\n    if (newLine > length || newLine === -1) {\n      if (result) {\n        result += '\\n\\n';\n      }\n      result += foldLine(object.slice(position, length), max);\n      position = length;\n    } else {\n      if (result) {\n        result += '\\n\\n';\n      }\n      result += foldLine(object.slice(position, newLine), max);\n      position = newLine + 1;\n    }\n  }\n  if (trailing && trailing[0] !== '\\n') {\n    result += trailing[0];\n  }\n\n  return result;\n}\n\nfunction foldLine(line, max) {\n  if (line === '') {\n    return line;\n  }\n\n  var foldRe = /[^\\s] [^\\s]/g,\n      result = '',\n      prevMatch = 0,\n      foldStart = 0,\n      match = foldRe.exec(line),\n      index,\n      foldEnd,\n      folded;\n\n  while (match) {\n    index = match.index;\n\n    // when we cross the max len, if the previous match would've\n    // been ok, use that one, and carry on.  If there was no previous\n    // match on this fold section, then just have a long line.\n    if (index - foldStart > max) {\n      if (prevMatch !== foldStart) {\n        foldEnd = prevMatch;\n      } else {\n        foldEnd = index;\n      }\n\n      if (result) {\n        result += '\\n';\n      }\n      folded = line.slice(foldStart, foldEnd);\n      result += folded;\n      foldStart = foldEnd + 1;\n    }\n    prevMatch = index + 1;\n    match = foldRe.exec(line);\n  }\n\n  if (result) {\n    result += '\\n';\n  }\n\n  // if we end up with one last word at the end, then the last bit might\n  // be slightly bigger than we wanted, because we exited out of the loop.\n  if (foldStart !== prevMatch && line.length - foldStart > max) {\n    result += line.slice(foldStart, prevMatch) + '\\n' +\n              line.slice(prevMatch + 1);\n  } else {\n    result += line.slice(foldStart);\n  }\n\n  return result;\n}\n\n// Returns true if character can be found in a simple scalar\nfunction simpleChar(character) {\n  return CHAR_TAB                  !== character &&\n         CHAR_LINE_FEED            !== character &&\n         CHAR_CARRIAGE_RETURN      !== character &&\n         CHAR_COMMA                !== character &&\n         CHAR_LEFT_SQUARE_BRACKET  !== character &&\n         CHAR_RIGHT_SQUARE_BRACKET !== character &&\n         CHAR_LEFT_CURLY_BRACKET   !== character &&\n         CHAR_RIGHT_CURLY_BRACKET  !== character &&\n         CHAR_SHARP                !== character &&\n         CHAR_AMPERSAND            !== character &&\n         CHAR_ASTERISK             !== character &&\n         CHAR_EXCLAMATION          !== character &&\n         CHAR_VERTICAL_LINE        !== character &&\n         CHAR_GREATER_THAN         !== character &&\n         CHAR_SINGLE_QUOTE         !== character &&\n         CHAR_DOUBLE_QUOTE         !== character &&\n         CHAR_PERCENT              !== character &&\n         CHAR_COLON                !== character &&\n         !ESCAPE_SEQUENCES[character]            &&\n         !needsHexEscape(character);\n}\n\n// Returns true if the character code needs to be escaped.\nfunction needsHexEscape(character) {\n  return !((0x00020 <= character && character <= 0x00007E) ||\n           (0x00085 === character)                         ||\n           (0x000A0 <= character && character <= 0x00D7FF) ||\n           (0x0E000 <= character && character <= 0x00FFFD) ||\n           (0x10000 <= character && character <= 0x10FFFF));\n}\n\nfunction writeFlowSequence(state, level, object) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level, object[index], false, false)) {\n      if (0 !== index) {\n        _result += ', ';\n      }\n      _result += state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = '[' + _result + ']';\n}\n\nfunction writeBlockSequence(state, level, object, compact) {\n  var _result = '',\n      _tag    = state.tag,\n      index,\n      length;\n\n  for (index = 0, length = object.length; index < length; index += 1) {\n    // Write only valid elements.\n    if (writeNode(state, level + 1, object[index], true, true)) {\n      if (!compact || 0 !== index) {\n        _result += generateNextLine(state, level);\n      }\n      _result += '- ' + state.dump;\n    }\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '[]'; // Empty sequence if no valid values.\n}\n\nfunction writeFlowMapping(state, level, object) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      pairBuffer;\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (0 !== index) {\n      pairBuffer += ', ';\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level, objectKey, false, false)) {\n      continue; // Skip this pair because of invalid key;\n    }\n\n    if (state.dump.length > 1024) {\n      pairBuffer += '? ';\n    }\n\n    pairBuffer += state.dump + ': ';\n\n    if (!writeNode(state, level, objectValue, false, false)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = '{' + _result + '}';\n}\n\nfunction writeBlockMapping(state, level, object, compact) {\n  var _result       = '',\n      _tag          = state.tag,\n      objectKeyList = Object.keys(object),\n      index,\n      length,\n      objectKey,\n      objectValue,\n      explicitPair,\n      pairBuffer;\n\n  // Allow sorting keys so that the output file is deterministic\n  if (state.sortKeys === true) {\n    // Default sorting\n    objectKeyList.sort();\n  } else if (typeof state.sortKeys === 'function') {\n    // Custom sort function\n    objectKeyList.sort(state.sortKeys);\n  } else if (state.sortKeys) {\n    // Something is wrong\n    throw new YAMLException('sortKeys must be a boolean or a function');\n  }\n\n  for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n    pairBuffer = '';\n\n    if (!compact || 0 !== index) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    objectKey = objectKeyList[index];\n    objectValue = object[objectKey];\n\n    if (!writeNode(state, level + 1, objectKey, true, true)) {\n      continue; // Skip this pair because of invalid key.\n    }\n\n    explicitPair = (null !== state.tag && '?' !== state.tag) ||\n                   (state.dump && state.dump.length > 1024);\n\n    if (explicitPair) {\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += '?';\n      } else {\n        pairBuffer += '? ';\n      }\n    }\n\n    pairBuffer += state.dump;\n\n    if (explicitPair) {\n      pairBuffer += generateNextLine(state, level);\n    }\n\n    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n      continue; // Skip this pair because of invalid value.\n    }\n\n    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n      pairBuffer += ':';\n    } else {\n      pairBuffer += ': ';\n    }\n\n    pairBuffer += state.dump;\n\n    // Both key and value are valid.\n    _result += pairBuffer;\n  }\n\n  state.tag = _tag;\n  state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n}\n\nfunction detectType(state, object, explicit) {\n  var _result, typeList, index, length, type, style;\n\n  typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n  for (index = 0, length = typeList.length; index < length; index += 1) {\n    type = typeList[index];\n\n    if ((type.instanceOf  || type.predicate) &&\n        (!type.instanceOf || (('object' === typeof object) && (object instanceof type.instanceOf))) &&\n        (!type.predicate  || type.predicate(object))) {\n\n      state.tag = explicit ? type.tag : '?';\n\n      if (type.represent) {\n        style = state.styleMap[type.tag] || type.defaultStyle;\n\n        if ('[object Function]' === _toString.call(type.represent)) {\n          _result = type.represent(object, style);\n        } else if (_hasOwnProperty.call(type.represent, style)) {\n          _result = type.represent[style](object, style);\n        } else {\n          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n        }\n\n        state.dump = _result;\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// Serializes `object` and writes it to global `result`.\n// Returns true on success, or false on invalid object.\n//\nfunction writeNode(state, level, object, block, compact) {\n  state.tag = null;\n  state.dump = object;\n\n  if (!detectType(state, object, false)) {\n    detectType(state, object, true);\n  }\n\n  var type = _toString.call(state.dump);\n\n  if (block) {\n    block = (0 > state.flowLevel || state.flowLevel > level);\n  }\n\n  if ((null !== state.tag && '?' !== state.tag) || (2 !== state.indent && level > 0)) {\n    compact = false;\n  }\n\n  var objectOrArray = '[object Object]' === type || '[object Array]' === type,\n      duplicateIndex,\n      duplicate;\n\n  if (objectOrArray) {\n    duplicateIndex = state.duplicates.indexOf(object);\n    duplicate = duplicateIndex !== -1;\n  }\n\n  if (duplicate && state.usedDuplicates[duplicateIndex]) {\n    state.dump = '*ref_' + duplicateIndex;\n  } else {\n    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n      state.usedDuplicates[duplicateIndex] = true;\n    }\n    if ('[object Object]' === type) {\n      if (block && (0 !== Object.keys(state.dump).length)) {\n        writeBlockMapping(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\\n' : '') + state.dump;\n        }\n      } else {\n        writeFlowMapping(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if ('[object Array]' === type) {\n      if (block && (0 !== state.dump.length)) {\n        writeBlockSequence(state, level, state.dump, compact);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + (0 === level ? '\\n' : '') + state.dump;\n        }\n      } else {\n        writeFlowSequence(state, level, state.dump);\n        if (duplicate) {\n          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n        }\n      }\n    } else if ('[object String]' === type) {\n      if ('?' !== state.tag) {\n        writeScalar(state, state.dump, level);\n      }\n    } else {\n      if (state.skipInvalid) {\n        return false;\n      }\n      throw new YAMLException('unacceptable kind of an object to dump ' + type);\n    }\n\n    if (null !== state.tag && '?' !== state.tag) {\n      state.dump = '!<' + state.tag + '> ' + state.dump;\n    }\n  }\n\n  return true;\n}\n\nfunction getDuplicateReferences(object, state) {\n  var objects = [],\n      duplicatesIndexes = [],\n      index,\n      length;\n\n  inspectNode(object, objects, duplicatesIndexes);\n\n  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n    state.duplicates.push(objects[duplicatesIndexes[index]]);\n  }\n  state.usedDuplicates = new Array(length);\n}\n\nfunction inspectNode(object, objects, duplicatesIndexes) {\n  var type = _toString.call(object),\n      objectKeyList,\n      index,\n      length;\n\n  if (null !== object && 'object' === typeof object) {\n    index = objects.indexOf(object);\n    if (-1 !== index) {\n      if (-1 === duplicatesIndexes.indexOf(index)) {\n        duplicatesIndexes.push(index);\n      }\n    } else {\n      objects.push(object);\n\n      if (Array.isArray(object)) {\n        for (index = 0, length = object.length; index < length; index += 1) {\n          inspectNode(object[index], objects, duplicatesIndexes);\n        }\n      } else {\n        objectKeyList = Object.keys(object);\n\n        for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n        }\n      }\n    }\n  }\n}\n\nfunction dump(input, options) {\n  options = options || {};\n\n  var state = new State(options);\n\n  getDuplicateReferences(input, state);\n\n  if (writeNode(state, 0, input, true, true)) {\n    return state.dump + '\\n';\n  }\n  return '';\n}\n\nfunction safeDump(input, options) {\n  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));\n}\n\nmodule.exports.dump     = dump;\nmodule.exports.safeDump = safeDump;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}