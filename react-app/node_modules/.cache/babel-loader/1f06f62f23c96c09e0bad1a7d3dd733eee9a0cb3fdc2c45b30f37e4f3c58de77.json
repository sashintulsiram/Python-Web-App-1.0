{"ast":null,"code":"// Generated by CoffeeScript 2.4.1\n(function () {\n  var NodeType,\n    WriterState,\n    XMLAttribute,\n    XMLCData,\n    XMLComment,\n    XMLDTDAttList,\n    XMLDTDElement,\n    XMLDTDEntity,\n    XMLDTDNotation,\n    XMLDeclaration,\n    XMLDocType,\n    XMLDocument,\n    XMLDocumentCB,\n    XMLElement,\n    XMLProcessingInstruction,\n    XMLRaw,\n    XMLStringWriter,\n    XMLStringifier,\n    XMLText,\n    getValue,\n    isFunction,\n    isObject,\n    isPlainObject,\n    hasProp = {}.hasOwnProperty;\n  ({\n    isObject,\n    isFunction,\n    isPlainObject,\n    getValue\n  } = require('./Utility'));\n  NodeType = require('./NodeType');\n  XMLDocument = require('./XMLDocument');\n  XMLElement = require('./XMLElement');\n  XMLCData = require('./XMLCData');\n  XMLComment = require('./XMLComment');\n  XMLRaw = require('./XMLRaw');\n  XMLText = require('./XMLText');\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n  XMLDeclaration = require('./XMLDeclaration');\n  XMLDocType = require('./XMLDocType');\n  XMLDTDAttList = require('./XMLDTDAttList');\n  XMLDTDEntity = require('./XMLDTDEntity');\n  XMLDTDElement = require('./XMLDTDElement');\n  XMLDTDNotation = require('./XMLDTDNotation');\n  XMLAttribute = require('./XMLAttribute');\n  XMLStringifier = require('./XMLStringifier');\n  XMLStringWriter = require('./XMLStringWriter');\n  WriterState = require('./WriterState');\n\n  // Represents an XML builder\n  module.exports = XMLDocumentCB = class XMLDocumentCB {\n    // Initializes a new instance of `XMLDocumentCB`\n\n    // `options.keepNullNodes` whether nodes with null values will be kept\n    //     or ignored: true or false\n    // `options.keepNullAttributes` whether attributes with null values will be\n    //     kept or ignored: true or false\n    // `options.ignoreDecorators` whether decorator strings will be ignored when\n    //     converting JS objects: true or false\n    // `options.separateArrayItems` whether array items are created as separate\n    //     nodes when passed as an object value: true or false\n    // `options.noDoubleEncoding` whether existing html entities are encoded:\n    //     true or false\n    // `options.stringify` a set of functions to use for converting values to\n    //     strings\n    // `options.writer` the default XML writer to use for converting nodes to\n    //     string. If the default writer is not set, the built-in XMLStringWriter\n    //     will be used instead.\n\n    // `onData` the function to be called when a new chunk of XML is output. The\n    //          string containing the XML chunk is passed to `onData` as its first\n    //          argument, and the current indentation level as its second argument.\n    // `onEnd`  the function to be called when the XML document is completed with\n    //          `end`. `onEnd` does not receive any arguments.\n    constructor(options, onData, onEnd) {\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n      this.onDataCallback = onData || function () {};\n      this.onEndCallback = onEnd || function () {};\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    }\n\n    // Creates a child element node from the given XMLNode\n\n    // `node` the child node\n    createChildNode(node) {\n      var att, attName, attributes, child, i, len, ref, ref1;\n      switch (node.type) {\n        case NodeType.CData:\n          this.cdata(node.value);\n          break;\n        case NodeType.Comment:\n          this.comment(node.value);\n          break;\n        case NodeType.Element:\n          attributes = {};\n          ref = node.attribs;\n          for (attName in ref) {\n            if (!hasProp.call(ref, attName)) continue;\n            att = ref[attName];\n            attributes[attName] = att.value;\n          }\n          this.node(node.name, attributes);\n          break;\n        case NodeType.Dummy:\n          this.dummy();\n          break;\n        case NodeType.Raw:\n          this.raw(node.value);\n          break;\n        case NodeType.Text:\n          this.text(node.value);\n          break;\n        case NodeType.ProcessingInstruction:\n          this.instruction(node.target, node.value);\n          break;\n        default:\n          throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n      }\n      ref1 = node.children;\n      // write child nodes recursively\n      for (i = 0, len = ref1.length; i < len; i++) {\n        child = ref1[i];\n        this.createChildNode(child);\n        if (child.type === NodeType.Element) {\n          this.up();\n        }\n      }\n      return this;\n    }\n\n    // Creates a dummy node\n\n    dummy() {\n      // no-op, just return this\n      return this;\n    }\n\n    // Creates a node\n\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n    node(name, attributes, text) {\n      if (name == null) {\n        throw new Error(\"Missing node name.\");\n      }\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n      }\n      this.openCurrent();\n      name = getValue(name);\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = getValue(attributes);\n      // swap argument order: text <-> attributes\n      if (!isObject(attributes)) {\n        [text, attributes] = [attributes, text];\n      }\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      if (text != null) {\n        this.text(text);\n      }\n      return this;\n    }\n\n    // Creates a child element node or an element type declaration when called\n    // inside the DTD\n\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n    element(name, attributes, text) {\n      var child, i, len, oldValidationFlag, ref, root;\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        this.dtdElement(...arguments);\n      } else {\n        if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n          oldValidationFlag = this.options.noValidation;\n          this.options.noValidation = true;\n          root = new XMLDocument(this.options).element('TEMP_ROOT');\n          root.element(name);\n          this.options.noValidation = oldValidationFlag;\n          ref = root.children;\n          for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            this.createChildNode(child);\n            if (child.type === NodeType.Element) {\n              this.up();\n            }\n          }\n        } else {\n          this.node(name, attributes, text);\n        }\n      }\n      return this;\n    }\n\n    // Adds or modifies an attribute\n\n    // `name` attribute name\n    // `value` attribute value\n    attribute(name, value) {\n      var attName, attValue;\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n      }\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (isObject(name)) {\n        // expand if object\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (this.options.keepNullAttributes && value == null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    }\n\n    // Creates a text node\n\n    // `value` element text\n    text(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a CDATA node\n\n    // `value` element text without CDATA delimiters\n    cdata(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a comment node\n\n    // `value` comment text\n    comment(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Adds unescaped raw text\n\n    // `value` text\n    raw(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Adds a processing instruction\n\n    // `target` instruction target\n    // `value` instruction value\n    instruction(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n      if (target != null) {\n        target = getValue(target);\n      }\n      if (value != null) {\n        value = getValue(value);\n      }\n      if (Array.isArray(target)) {\n        // expand if array\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) {\n        // expand if object\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      }\n      return this;\n    }\n\n    // Creates the xml declaration\n\n    // `version` A version number string, e.g. 1.0\n    // `encoding` Encoding declaration, e.g. UTF-8\n    // `standalone` standalone document declaration: true or false\n    declaration(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node.\");\n      }\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates the document type declaration\n\n    // `root`  the name of the root node\n    // `pubID` the public identifier of the external subset\n    // `sysID` the system identifier of the external subset\n    doctype(root, pubID, sysID) {\n      this.openCurrent();\n      if (root == null) {\n        throw new Error(\"Missing root node name.\");\n      }\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node.\");\n      }\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    }\n\n    // Creates an element type declaration\n\n    // `name` element name\n    // `value` element content (defaults to #PCDATA)\n    dtdElement(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates an attribute declaration\n\n    // `elementName` the name of the element containing this attribute\n    // `attributeName` attribute name\n    // `attributeType` type of the attribute (defaults to CDATA)\n    // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or\n    //                    #DEFAULT) (defaults to #IMPLIED)\n    // `defaultValue` default value of the attribute\n    //                (only used for #FIXED or #DEFAULT)\n    attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a general entity declaration\n\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    // `value.nData` notation declaration\n    entity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a parameter entity declaration\n\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    pEntity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a NOTATION declaration\n\n    // `name` the name of the notation\n    // `value` an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    notation(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Gets the parent node\n    up() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent.\");\n      }\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    }\n\n    // Ends the document\n    end() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n      return this.onEnd();\n    }\n\n    // Opens the current parent node\n    openCurrent() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    }\n\n    // Writes the opening tag of the current node or the entire node if it has\n    // no child nodes\n    openNode(node) {\n      var att, chunk, name, ref;\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n          this.root = node;\n        }\n        chunk = '';\n        if (node.type === NodeType.Element) {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n          ref = node.attribs;\n          for (name in ref) {\n            if (!hasProp.call(ref, name)) continue;\n            att = ref[name];\n            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n          }\n          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType\n        } else {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;\n\n          // external identifier\n          if (node.pubID && node.sysID) {\n            chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n          } else if (node.sysID) {\n            chunk += ' SYSTEM \"' + node.sysID + '\"';\n          }\n\n          // internal subset\n          if (node.children) {\n            chunk += ' [';\n            this.writerOptions.state = WriterState.InsideTag;\n          } else {\n            this.writerOptions.state = WriterState.CloseTag;\n            chunk += '>';\n          }\n          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.onData(chunk, this.currentLevel);\n        return node.isOpen = true;\n      }\n    }\n\n    // Writes the closing tag of the current node\n    closeNode(node) {\n      var chunk;\n      if (!node.isClosed) {\n        chunk = '';\n        this.writerOptions.state = WriterState.CloseTag;\n        if (node.type === NodeType.Element) {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel); // if node.type is NodeType.DocType\n        } else {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.writerOptions.state = WriterState.None;\n        this.onData(chunk, this.currentLevel);\n        return node.isClosed = true;\n      }\n    }\n\n    // Called when a new chunk of XML is output\n\n    // `chunk` a string containing the XML chunk\n    // `level` current indentation level\n    onData(chunk, level) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk, level + 1);\n    }\n\n    // Called when the XML document is completed\n    onEnd() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    }\n\n    // Returns debug string\n    debugInfo(name) {\n      if (name == null) {\n        return \"\";\n      } else {\n        return \"node: <\" + name + \">\";\n      }\n    }\n\n    // Node aliases\n    ele() {\n      return this.element(...arguments);\n    }\n    nod(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n    txt(value) {\n      return this.text(value);\n    }\n    dat(value) {\n      return this.cdata(value);\n    }\n    com(value) {\n      return this.comment(value);\n    }\n    ins(target, value) {\n      return this.instruction(target, value);\n    }\n    dec(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    }\n    dtd(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    }\n    e(name, attributes, text) {\n      return this.element(name, attributes, text);\n    }\n    n(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n    t(value) {\n      return this.text(value);\n    }\n    d(value) {\n      return this.cdata(value);\n    }\n    c(value) {\n      return this.comment(value);\n    }\n    r(value) {\n      return this.raw(value);\n    }\n    i(target, value) {\n      return this.instruction(target, value);\n    }\n\n    // Attribute aliases\n    att() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n    a() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    // DTD aliases\n    // att() and ele() are defined above\n    ent(name, value) {\n      return this.entity(name, value);\n    }\n    pent(name, value) {\n      return this.pEntity(name, value);\n    }\n    not(name, value) {\n      return this.notation(name, value);\n    }\n  };\n}).call(this);","map":{"version":3,"names":["NodeType","WriterState","XMLAttribute","XMLCData","XMLComment","XMLDTDAttList","XMLDTDElement","XMLDTDEntity","XMLDTDNotation","XMLDeclaration","XMLDocType","XMLDocument","XMLDocumentCB","XMLElement","XMLProcessingInstruction","XMLRaw","XMLStringWriter","XMLStringifier","XMLText","getValue","isFunction","isObject","isPlainObject","hasProp","hasOwnProperty","require","module","exports","constructor","options","onData","onEnd","writerOptions","name","type","Document","writer","filterOptions","stringify","onDataCallback","onEndCallback","currentNode","currentLevel","openTags","documentStarted","documentCompleted","root","createChildNode","node","att","attName","attributes","child","i","len","ref","ref1","CData","cdata","value","Comment","comment","Element","attribs","call","Dummy","dummy","Raw","raw","Text","text","ProcessingInstruction","instruction","target","Error","children","length","up","debugInfo","openCurrent","element","oldValidationFlag","DocType","dtdElement","arguments","Array","isArray","noValidation","attribute","attValue","apply","keepNullAttributes","insTarget","insValue","processingInstruction","declaration","version","encoding","standalone","doctype","pubID","sysID","rootNodeName","attList","elementName","attributeName","attributeType","defaultValueType","defaultValue","dtdAttList","entity","dtdEntity","pEntity","notation","dtdNotation","closeNode","openNode","end","chunk","isOpen","state","OpenTag","indent","endline","InsideTag","CloseTag","isClosed","None","level","ele","nod","txt","dat","com","ins","dec","dtd","e","n","t","d","c","r","a","ent","pent","not"],"sources":["C:/Users/SashinTulsiram/Documents/Software/react-frontend-bulma/react-app/node_modules/xmlbuilder/lib/XMLDocumentCB.js"],"sourcesContent":["// Generated by CoffeeScript 2.4.1\n(function() {\n  var NodeType, WriterState, XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocument, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction, isObject, isPlainObject,\n    hasProp = {}.hasOwnProperty;\n\n  ({isObject, isFunction, isPlainObject, getValue} = require('./Utility'));\n\n  NodeType = require('./NodeType');\n\n  XMLDocument = require('./XMLDocument');\n\n  XMLElement = require('./XMLElement');\n\n  XMLCData = require('./XMLCData');\n\n  XMLComment = require('./XMLComment');\n\n  XMLRaw = require('./XMLRaw');\n\n  XMLText = require('./XMLText');\n\n  XMLProcessingInstruction = require('./XMLProcessingInstruction');\n\n  XMLDeclaration = require('./XMLDeclaration');\n\n  XMLDocType = require('./XMLDocType');\n\n  XMLDTDAttList = require('./XMLDTDAttList');\n\n  XMLDTDEntity = require('./XMLDTDEntity');\n\n  XMLDTDElement = require('./XMLDTDElement');\n\n  XMLDTDNotation = require('./XMLDTDNotation');\n\n  XMLAttribute = require('./XMLAttribute');\n\n  XMLStringifier = require('./XMLStringifier');\n\n  XMLStringWriter = require('./XMLStringWriter');\n\n  WriterState = require('./WriterState');\n\n  // Represents an XML builder\n  module.exports = XMLDocumentCB = class XMLDocumentCB {\n    // Initializes a new instance of `XMLDocumentCB`\n\n    // `options.keepNullNodes` whether nodes with null values will be kept\n    //     or ignored: true or false\n    // `options.keepNullAttributes` whether attributes with null values will be\n    //     kept or ignored: true or false\n    // `options.ignoreDecorators` whether decorator strings will be ignored when\n    //     converting JS objects: true or false\n    // `options.separateArrayItems` whether array items are created as separate\n    //     nodes when passed as an object value: true or false\n    // `options.noDoubleEncoding` whether existing html entities are encoded:\n    //     true or false\n    // `options.stringify` a set of functions to use for converting values to\n    //     strings\n    // `options.writer` the default XML writer to use for converting nodes to\n    //     string. If the default writer is not set, the built-in XMLStringWriter\n    //     will be used instead.\n\n    // `onData` the function to be called when a new chunk of XML is output. The\n    //          string containing the XML chunk is passed to `onData` as its first\n    //          argument, and the current indentation level as its second argument.\n    // `onEnd`  the function to be called when the XML document is completed with\n    //          `end`. `onEnd` does not receive any arguments.\n    constructor(options, onData, onEnd) {\n      var writerOptions;\n      this.name = \"?xml\";\n      this.type = NodeType.Document;\n      options || (options = {});\n      writerOptions = {};\n      if (!options.writer) {\n        options.writer = new XMLStringWriter();\n      } else if (isPlainObject(options.writer)) {\n        writerOptions = options.writer;\n        options.writer = new XMLStringWriter();\n      }\n      this.options = options;\n      this.writer = options.writer;\n      this.writerOptions = this.writer.filterOptions(writerOptions);\n      this.stringify = new XMLStringifier(options);\n      this.onDataCallback = onData || function() {};\n      this.onEndCallback = onEnd || function() {};\n      this.currentNode = null;\n      this.currentLevel = -1;\n      this.openTags = {};\n      this.documentStarted = false;\n      this.documentCompleted = false;\n      this.root = null;\n    }\n\n    // Creates a child element node from the given XMLNode\n\n    // `node` the child node\n    createChildNode(node) {\n      var att, attName, attributes, child, i, len, ref, ref1;\n      switch (node.type) {\n        case NodeType.CData:\n          this.cdata(node.value);\n          break;\n        case NodeType.Comment:\n          this.comment(node.value);\n          break;\n        case NodeType.Element:\n          attributes = {};\n          ref = node.attribs;\n          for (attName in ref) {\n            if (!hasProp.call(ref, attName)) continue;\n            att = ref[attName];\n            attributes[attName] = att.value;\n          }\n          this.node(node.name, attributes);\n          break;\n        case NodeType.Dummy:\n          this.dummy();\n          break;\n        case NodeType.Raw:\n          this.raw(node.value);\n          break;\n        case NodeType.Text:\n          this.text(node.value);\n          break;\n        case NodeType.ProcessingInstruction:\n          this.instruction(node.target, node.value);\n          break;\n        default:\n          throw new Error(\"This XML node type is not supported in a JS object: \" + node.constructor.name);\n      }\n      ref1 = node.children;\n      // write child nodes recursively\n      for (i = 0, len = ref1.length; i < len; i++) {\n        child = ref1[i];\n        this.createChildNode(child);\n        if (child.type === NodeType.Element) {\n          this.up();\n        }\n      }\n      return this;\n    }\n\n    // Creates a dummy node\n\n    dummy() {\n      // no-op, just return this\n      return this;\n    }\n\n    // Creates a node\n\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n    node(name, attributes, text) {\n      if (name == null) {\n        throw new Error(\"Missing node name.\");\n      }\n      if (this.root && this.currentLevel === -1) {\n        throw new Error(\"Document can only have one root node. \" + this.debugInfo(name));\n      }\n      this.openCurrent();\n      name = getValue(name);\n      if (attributes == null) {\n        attributes = {};\n      }\n      attributes = getValue(attributes);\n      // swap argument order: text <-> attributes\n      if (!isObject(attributes)) {\n        [text, attributes] = [attributes, text];\n      }\n      this.currentNode = new XMLElement(this, name, attributes);\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      if (text != null) {\n        this.text(text);\n      }\n      return this;\n    }\n\n    // Creates a child element node or an element type declaration when called\n    // inside the DTD\n\n    // `name` name of the node\n    // `attributes` an object containing name/value pairs of attributes\n    // `text` element text\n    element(name, attributes, text) {\n      var child, i, len, oldValidationFlag, ref, root;\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        this.dtdElement(...arguments);\n      } else {\n        if (Array.isArray(name) || isObject(name) || isFunction(name)) {\n          oldValidationFlag = this.options.noValidation;\n          this.options.noValidation = true;\n          root = new XMLDocument(this.options).element('TEMP_ROOT');\n          root.element(name);\n          this.options.noValidation = oldValidationFlag;\n          ref = root.children;\n          for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            this.createChildNode(child);\n            if (child.type === NodeType.Element) {\n              this.up();\n            }\n          }\n        } else {\n          this.node(name, attributes, text);\n        }\n      }\n      return this;\n    }\n\n    // Adds or modifies an attribute\n\n    // `name` attribute name\n    // `value` attribute value\n    attribute(name, value) {\n      var attName, attValue;\n      if (!this.currentNode || this.currentNode.children) {\n        throw new Error(\"att() can only be used immediately after an ele() call in callback mode. \" + this.debugInfo(name));\n      }\n      if (name != null) {\n        name = getValue(name);\n      }\n      if (isObject(name)) { // expand if object\n        for (attName in name) {\n          if (!hasProp.call(name, attName)) continue;\n          attValue = name[attName];\n          this.attribute(attName, attValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        if (this.options.keepNullAttributes && (value == null)) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, \"\");\n        } else if (value != null) {\n          this.currentNode.attribs[name] = new XMLAttribute(this, name, value);\n        }\n      }\n      return this;\n    }\n\n    // Creates a text node\n\n    // `value` element text\n    text(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLText(this, value);\n      this.onData(this.writer.text(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a CDATA node\n\n    // `value` element text without CDATA delimiters\n    cdata(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLCData(this, value);\n      this.onData(this.writer.cdata(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a comment node\n\n    // `value` comment text\n    comment(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLComment(this, value);\n      this.onData(this.writer.comment(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Adds unescaped raw text\n\n    // `value` text\n    raw(value) {\n      var node;\n      this.openCurrent();\n      node = new XMLRaw(this, value);\n      this.onData(this.writer.raw(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Adds a processing instruction\n\n    // `target` instruction target\n    // `value` instruction value\n    instruction(target, value) {\n      var i, insTarget, insValue, len, node;\n      this.openCurrent();\n      if (target != null) {\n        target = getValue(target);\n      }\n      if (value != null) {\n        value = getValue(value);\n      }\n      if (Array.isArray(target)) { // expand if array\n        for (i = 0, len = target.length; i < len; i++) {\n          insTarget = target[i];\n          this.instruction(insTarget);\n        }\n      } else if (isObject(target)) { // expand if object\n        for (insTarget in target) {\n          if (!hasProp.call(target, insTarget)) continue;\n          insValue = target[insTarget];\n          this.instruction(insTarget, insValue);\n        }\n      } else {\n        if (isFunction(value)) {\n          value = value.apply();\n        }\n        node = new XMLProcessingInstruction(this, target, value);\n        this.onData(this.writer.processingInstruction(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      }\n      return this;\n    }\n\n    // Creates the xml declaration\n\n    // `version` A version number string, e.g. 1.0\n    // `encoding` Encoding declaration, e.g. UTF-8\n    // `standalone` standalone document declaration: true or false\n    declaration(version, encoding, standalone) {\n      var node;\n      this.openCurrent();\n      if (this.documentStarted) {\n        throw new Error(\"declaration() must be the first node.\");\n      }\n      node = new XMLDeclaration(this, version, encoding, standalone);\n      this.onData(this.writer.declaration(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates the document type declaration\n\n    // `root`  the name of the root node\n    // `pubID` the public identifier of the external subset\n    // `sysID` the system identifier of the external subset\n    doctype(root, pubID, sysID) {\n      this.openCurrent();\n      if (root == null) {\n        throw new Error(\"Missing root node name.\");\n      }\n      if (this.root) {\n        throw new Error(\"dtd() must come before the root node.\");\n      }\n      this.currentNode = new XMLDocType(this, pubID, sysID);\n      this.currentNode.rootNodeName = root;\n      this.currentNode.children = false;\n      this.currentLevel++;\n      this.openTags[this.currentLevel] = this.currentNode;\n      return this;\n    }\n\n    // Creates an element type declaration\n\n    // `name` element name\n    // `value` element content (defaults to #PCDATA)\n    dtdElement(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDElement(this, name, value);\n      this.onData(this.writer.dtdElement(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates an attribute declaration\n\n    // `elementName` the name of the element containing this attribute\n    // `attributeName` attribute name\n    // `attributeType` type of the attribute (defaults to CDATA)\n    // `defaultValueType` default value type (either #REQUIRED, #IMPLIED, #FIXED or\n    //                    #DEFAULT) (defaults to #IMPLIED)\n    // `defaultValue` default value of the attribute\n    //                (only used for #FIXED or #DEFAULT)\n    attList(elementName, attributeName, attributeType, defaultValueType, defaultValue) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);\n      this.onData(this.writer.dtdAttList(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a general entity declaration\n\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    // `value.nData` notation declaration\n    entity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, false, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a parameter entity declaration\n\n    // `name` the name of the entity\n    // `value` internal entity value or an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    pEntity(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDEntity(this, true, name, value);\n      this.onData(this.writer.dtdEntity(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Creates a NOTATION declaration\n\n    // `name` the name of the notation\n    // `value` an object with external entity details\n    // `value.pubID` public identifier\n    // `value.sysID` system identifier\n    notation(name, value) {\n      var node;\n      this.openCurrent();\n      node = new XMLDTDNotation(this, name, value);\n      this.onData(this.writer.dtdNotation(node, this.writerOptions, this.currentLevel + 1), this.currentLevel + 1);\n      return this;\n    }\n\n    // Gets the parent node\n    up() {\n      if (this.currentLevel < 0) {\n        throw new Error(\"The document node has no parent.\");\n      }\n      if (this.currentNode) {\n        if (this.currentNode.children) {\n          this.closeNode(this.currentNode);\n        } else {\n          this.openNode(this.currentNode);\n        }\n        this.currentNode = null;\n      } else {\n        this.closeNode(this.openTags[this.currentLevel]);\n      }\n      delete this.openTags[this.currentLevel];\n      this.currentLevel--;\n      return this;\n    }\n\n    // Ends the document\n    end() {\n      while (this.currentLevel >= 0) {\n        this.up();\n      }\n      return this.onEnd();\n    }\n\n    // Opens the current parent node\n    openCurrent() {\n      if (this.currentNode) {\n        this.currentNode.children = true;\n        return this.openNode(this.currentNode);\n      }\n    }\n\n    // Writes the opening tag of the current node or the entire node if it has\n    // no child nodes\n    openNode(node) {\n      var att, chunk, name, ref;\n      if (!node.isOpen) {\n        if (!this.root && this.currentLevel === 0 && node.type === NodeType.Element) {\n          this.root = node;\n        }\n        chunk = '';\n        if (node.type === NodeType.Element) {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<' + node.name;\n          ref = node.attribs;\n          for (name in ref) {\n            if (!hasProp.call(ref, name)) continue;\n            att = ref[name];\n            chunk += this.writer.attribute(att, this.writerOptions, this.currentLevel);\n          }\n          chunk += (node.children ? '>' : '/>') + this.writer.endline(node, this.writerOptions, this.currentLevel);\n          this.writerOptions.state = WriterState.InsideTag; // if node.type is NodeType.DocType\n        } else {\n          this.writerOptions.state = WriterState.OpenTag;\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '<!DOCTYPE ' + node.rootNodeName;\n          \n          // external identifier\n          if (node.pubID && node.sysID) {\n            chunk += ' PUBLIC \"' + node.pubID + '\" \"' + node.sysID + '\"';\n          } else if (node.sysID) {\n            chunk += ' SYSTEM \"' + node.sysID + '\"';\n          }\n          \n          // internal subset\n          if (node.children) {\n            chunk += ' [';\n            this.writerOptions.state = WriterState.InsideTag;\n          } else {\n            this.writerOptions.state = WriterState.CloseTag;\n            chunk += '>';\n          }\n          chunk += this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.onData(chunk, this.currentLevel);\n        return node.isOpen = true;\n      }\n    }\n\n    // Writes the closing tag of the current node\n    closeNode(node) {\n      var chunk;\n      if (!node.isClosed) {\n        chunk = '';\n        this.writerOptions.state = WriterState.CloseTag;\n        if (node.type === NodeType.Element) {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + '</' + node.name + '>' + this.writer.endline(node, this.writerOptions, this.currentLevel); // if node.type is NodeType.DocType\n        } else {\n          chunk = this.writer.indent(node, this.writerOptions, this.currentLevel) + ']>' + this.writer.endline(node, this.writerOptions, this.currentLevel);\n        }\n        this.writerOptions.state = WriterState.None;\n        this.onData(chunk, this.currentLevel);\n        return node.isClosed = true;\n      }\n    }\n\n    // Called when a new chunk of XML is output\n\n    // `chunk` a string containing the XML chunk\n    // `level` current indentation level\n    onData(chunk, level) {\n      this.documentStarted = true;\n      return this.onDataCallback(chunk, level + 1);\n    }\n\n    // Called when the XML document is completed\n    onEnd() {\n      this.documentCompleted = true;\n      return this.onEndCallback();\n    }\n\n    // Returns debug string\n    debugInfo(name) {\n      if (name == null) {\n        return \"\";\n      } else {\n        return \"node: <\" + name + \">\";\n      }\n    }\n\n    // Node aliases\n    ele() {\n      return this.element(...arguments);\n    }\n\n    nod(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    txt(value) {\n      return this.text(value);\n    }\n\n    dat(value) {\n      return this.cdata(value);\n    }\n\n    com(value) {\n      return this.comment(value);\n    }\n\n    ins(target, value) {\n      return this.instruction(target, value);\n    }\n\n    dec(version, encoding, standalone) {\n      return this.declaration(version, encoding, standalone);\n    }\n\n    dtd(root, pubID, sysID) {\n      return this.doctype(root, pubID, sysID);\n    }\n\n    e(name, attributes, text) {\n      return this.element(name, attributes, text);\n    }\n\n    n(name, attributes, text) {\n      return this.node(name, attributes, text);\n    }\n\n    t(value) {\n      return this.text(value);\n    }\n\n    d(value) {\n      return this.cdata(value);\n    }\n\n    c(value) {\n      return this.comment(value);\n    }\n\n    r(value) {\n      return this.raw(value);\n    }\n\n    i(target, value) {\n      return this.instruction(target, value);\n    }\n\n    // Attribute aliases\n    att() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    a() {\n      if (this.currentNode && this.currentNode.type === NodeType.DocType) {\n        return this.attList(...arguments);\n      } else {\n        return this.attribute(...arguments);\n      }\n    }\n\n    // DTD aliases\n    // att() and ele() are defined above\n    ent(name, value) {\n      return this.entity(name, value);\n    }\n\n    pent(name, value) {\n      return this.pEntity(name, value);\n    }\n\n    not(name, value) {\n      return this.notation(name, value);\n    }\n\n  };\n\n}).call(this);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}