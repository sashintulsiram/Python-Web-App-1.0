{"ast":null,"code":"'use strict';\n\nvar regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/,\n  regTransformSplit = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/,\n  regTransformDataSplit = /[\\s,]+/;\n\n/**\n * Convert transform string to JS representation.\n *\n * @param {String} transformString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\nexports.transform2js = function (transformString) {\n  // JS representation of the transform data\n  var transforms = [],\n    // current transform context\n    current;\n\n  // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']\n  transformString.split(regTransformSplit).forEach(function (item) {\n    if (item) {\n      // if item is a translate function\n      if (regTransformTypes.test(item)) {\n        // then collect it and change current context\n        transforms.push(current = {\n          name: item\n        });\n        // else if item is data\n      } else {\n        // then split it into [10, 50] and collect as context.data\n        current.data = item.split(regTransformDataSplit).map(Number);\n      }\n    }\n  });\n  return transforms;\n};\n\n/**\n * Multiply transforms into one.\n *\n * @param {Array} input transforms array\n * @return {Array} output matrix array\n */\nexports.transformsMultiply = function (transforms) {\n  // convert transforms objects to the matrices\n  transforms = transforms.map(function (transform) {\n    if (transform.name === 'matrix') {\n      return transform.data;\n    }\n    return transformToMatrix(transform);\n  });\n\n  // multiply all matrices into one\n  transforms = {\n    name: 'matrix',\n    data: transforms.reduce(function (a, b) {\n      return multiplyTransformMatrices(a, b);\n    })\n  };\n  return transforms;\n};\n\n/**\n * Do math like a schoolgirl.\n *\n * @type {Object}\n */\nvar mth = exports.mth = {\n  rad: function (deg) {\n    return deg * Math.PI / 180;\n  },\n  deg: function (rad) {\n    return rad * 180 / Math.PI;\n  },\n  cos: function (deg) {\n    return Math.cos(this.rad(deg));\n  },\n  acos: function (val, floatPrecision) {\n    return +this.deg(Math.acos(val)).toFixed(floatPrecision);\n  },\n  sin: function (deg) {\n    return Math.sin(this.rad(deg));\n  },\n  asin: function (val, floatPrecision) {\n    return +this.deg(Math.asin(val)).toFixed(floatPrecision);\n  },\n  tan: function (deg) {\n    return Math.tan(this.rad(deg));\n  },\n  atan: function (val, floatPrecision) {\n    return +this.deg(Math.atan(val)).toFixed(floatPrecision);\n  }\n};\n\n/**\n * Decompose matrix into simple transforms. See\n * http://www.maths-informatique-jeux.com/blog/frederic/?post/2013/12/01/Decomposition-of-2D-transform-matrices\n *\n * @param {Object} data matrix transform object\n * @return {Object|Array} transforms array or original transform object\n */\nexports.matrixToTransform = function (transform, params) {\n  var floatPrecision = params.floatPrecision,\n    data = transform.data,\n    transforms = [],\n    sx = +Math.sqrt(data[0] * data[0] + data[1] * data[1]).toFixed(params.transformPrecision),\n    sy = +((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(params.transformPrecision),\n    colsSum = data[0] * data[2] + data[1] * data[3],\n    rowsSum = data[0] * data[1] + data[2] * data[3],\n    scaleBefore = rowsSum || +(sx == sy);\n\n  // [..., ..., ..., ..., tx, ty] → translate(tx, ty)\n  if (data[4] || data[5]) {\n    transforms.push({\n      name: 'translate',\n      data: data.slice(4, data[5] ? 6 : 5)\n    });\n  }\n\n  // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)\n  if (!data[1] && data[2]) {\n    transforms.push({\n      name: 'skewX',\n      data: [mth.atan(data[2] / sy, floatPrecision)]\n    });\n\n    // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)\n  } else if (data[1] && !data[2]) {\n    transforms.push({\n      name: 'skewY',\n      data: [mth.atan(data[1] / data[0], floatPrecision)]\n    });\n    sx = data[0];\n    sy = data[3];\n\n    // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or\n    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)\n  } else if (!colsSum || sx == 1 && sy == 1 || !scaleBefore) {\n    if (!scaleBefore) {\n      sx = Math.sqrt(data[0] * data[0] + data[2] * data[2]);\n      sy = Math.sqrt(data[1] * data[1] + data[3] * data[3]);\n      transforms.push({\n        name: 'scale',\n        data: [sx, sy]\n      });\n    }\n    var a1 = mth.acos(data[0] / sx, floatPrecision),\n      rotate = [a1.toFixed(floatPrecision) * (data[1] < 0 ? -1 : 1)];\n    if (rotate[0]) transforms.push({\n      name: 'rotate',\n      data: rotate\n    });\n    if (rowsSum && colsSum) transforms.push({\n      name: 'skewX',\n      data: [mth.atan(colsSum / (sx * sx), floatPrecision)]\n    });\n\n    // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)\n    if (rotate[0] && (data[4] || data[5])) {\n      transforms.shift();\n      var cos = data[0] / sx,\n        sin = data[1] / (scaleBefore ? sx : sy),\n        x = data[4] * (scaleBefore || sy),\n        y = data[5] * (scaleBefore || sx),\n        denom = (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore || sx * sy);\n      rotate.push(((1 - cos) * x - sin * y) / denom);\n      rotate.push(((1 - cos) * y + sin * x) / denom);\n    }\n\n    // Too many transformations, return original matrix if it isn't just a scale/translate\n  } else if (data[1] || data[2]) {\n    return transform;\n  }\n  if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length) transforms.push({\n    name: 'scale',\n    data: sx == sy ? [sx] : [sx, sy]\n  });\n  return transforms;\n};\n\n/**\n * Convert transform to the matrix data.\n *\n * @param {Object} transform transform object\n * @return {Array} matrix data\n */\nfunction transformToMatrix(transform) {\n  if (transform.name === 'matrix') return transform.data;\n  var matrix;\n  switch (transform.name) {\n    case 'translate':\n      // [1, 0, 0, 1, tx, ty]\n      matrix = [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];\n      break;\n    case 'scale':\n      // [sx, 0, 0, sy, 0, 0]\n      matrix = [transform.data[0], 0, 0, transform.data[1] || transform.data[0], 0, 0];\n      break;\n    case 'rotate':\n      // [cos(a), sin(a), -sin(a), cos(a), x, y]\n      var cos = mth.cos(transform.data[0]),\n        sin = mth.sin(transform.data[0]),\n        cx = transform.data[1] || 0,\n        cy = transform.data[2] || 0;\n      matrix = [cos, sin, -sin, cos, (1 - cos) * cx + sin * cy, (1 - cos) * cy - sin * cx];\n      break;\n    case 'skewX':\n      // [1, 0, tan(a), 1, 0, 0]\n      matrix = [1, 0, mth.tan(transform.data[0]), 1, 0, 0];\n      break;\n    case 'skewY':\n      // [1, tan(a), 0, 1, 0, 0]\n      matrix = [1, mth.tan(transform.data[0]), 0, 1, 0, 0];\n      break;\n  }\n  return matrix;\n}\n\n/**\n * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it\n * by the transformation matrix and use a singular value decomposition to represent in a form\n * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.\n * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})\n *\n * @param {Array} arc [a, b, rotation in deg]\n * @param {Array} transform transformation matrix\n * @return {Array} arc transformed input arc\n */\nexports.transformArc = function (arc, transform) {\n  var a = arc[0],\n    b = arc[1],\n    rot = arc[2] * Math.PI / 180,\n    cos = Math.cos(rot),\n    sin = Math.sin(rot),\n    h = Math.pow(arc[5] * cos + arc[6] * sin, 2) / (4 * a * a) + Math.pow(arc[6] * cos - arc[5] * sin, 2) / (4 * b * b);\n  if (h > 1) {\n    h = Math.sqrt(h);\n    a *= h;\n    b *= h;\n  }\n  var ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0],\n    m = multiplyTransformMatrices(transform, ellipse),\n    // Decompose the new ellipse matrix\n    lastCol = m[2] * m[2] + m[3] * m[3],\n    squareSum = m[0] * m[0] + m[1] * m[1] + lastCol,\n    root = Math.sqrt((Math.pow(m[0] - m[3], 2) + Math.pow(m[1] + m[2], 2)) * (Math.pow(m[0] + m[3], 2) + Math.pow(m[1] - m[2], 2)));\n  if (!root) {\n    // circle\n    arc[0] = arc[1] = Math.sqrt(squareSum / 2);\n    arc[2] = 0;\n  } else {\n    var majorAxisSqr = (squareSum + root) / 2,\n      minorAxisSqr = (squareSum - root) / 2,\n      major = Math.abs(majorAxisSqr - lastCol) > 1e-6,\n      sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol,\n      rowsSum = m[0] * m[2] + m[1] * m[3],\n      term1 = m[0] * sub + m[2] * rowsSum,\n      term2 = m[1] * sub + m[3] * rowsSum;\n    arc[0] = Math.sqrt(majorAxisSqr);\n    arc[1] = Math.sqrt(minorAxisSqr);\n    arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) * Math.acos((major ? term1 : term2) / Math.sqrt(term1 * term1 + term2 * term2)) * 180 / Math.PI;\n  }\n  return arc;\n};\n\n/**\n * Multiply transformation matrices.\n *\n * @param {Array} a matrix A data\n * @param {Array} b matrix B data\n * @return {Array} result\n */\nfunction multiplyTransformMatrices(a, b) {\n  return [a[0] * b[0] + a[2] * b[1], a[1] * b[0] + a[3] * b[1], a[0] * b[2] + a[2] * b[3], a[1] * b[2] + a[3] * b[3], a[0] * b[4] + a[2] * b[5] + a[4], a[1] * b[4] + a[3] * b[5] + a[5]];\n}","map":{"version":3,"names":["regTransformTypes","regTransformSplit","regTransformDataSplit","exports","transform2js","transformString","transforms","current","split","forEach","item","test","push","name","data","map","Number","transformsMultiply","transform","transformToMatrix","reduce","a","b","multiplyTransformMatrices","mth","rad","deg","Math","PI","cos","acos","val","floatPrecision","toFixed","sin","asin","tan","atan","matrixToTransform","params","sx","sqrt","transformPrecision","sy","colsSum","rowsSum","scaleBefore","slice","a1","rotate","shift","x","y","denom","pow","length","matrix","cx","cy","transformArc","arc","rot","h","ellipse","m","lastCol","squareSum","root","majorAxisSqr","minorAxisSqr","major","abs","sub","term1","term2"],"sources":["C:/Users/SashinTulsiram/Documents/Software/react-frontend-bulma/node_modules/svgo/plugins/_transforms.js"],"sourcesContent":["'use strict';\n\nvar regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/,\n    regTransformSplit = /\\s*(matrix|translate|scale|rotate|skewX|skewY)\\s*\\(\\s*(.+?)\\s*\\)[\\s,]*/,\n    regTransformDataSplit = /[\\s,]+/;\n\n/**\n * Convert transform string to JS representation.\n *\n * @param {String} transformString input string\n * @param {Object} params plugin params\n * @return {Array} output array\n */\nexports.transform2js = function(transformString) {\n\n        // JS representation of the transform data\n    var transforms = [],\n        // current transform context\n        current;\n\n    // split value into ['', 'translate', '10 50', '', 'scale', '2', '', 'rotate', '-45', '']\n    transformString.split(regTransformSplit).forEach(function(item) {\n\n        if (item) {\n            // if item is a translate function\n            if (regTransformTypes.test(item)) {\n                // then collect it and change current context\n                transforms.push(current = { name: item });\n            // else if item is data\n            } else {\n                // then split it into [10, 50] and collect as context.data\n                current.data = item.split(regTransformDataSplit).map(Number);\n            }\n        }\n\n    });\n\n    return transforms;\n\n};\n\n/**\n * Multiply transforms into one.\n *\n * @param {Array} input transforms array\n * @return {Array} output matrix array\n */\nexports.transformsMultiply = function(transforms) {\n\n    // convert transforms objects to the matrices\n    transforms = transforms.map(function(transform) {\n        if (transform.name === 'matrix') {\n            return transform.data;\n        }\n        return transformToMatrix(transform);\n    });\n\n    // multiply all matrices into one\n    transforms = {\n        name: 'matrix',\n        data: transforms.reduce(function(a, b) {\n            return multiplyTransformMatrices(a, b);\n        })\n    };\n\n    return transforms;\n\n};\n\n/**\n * Do math like a schoolgirl.\n *\n * @type {Object}\n */\nvar mth = exports.mth = {\n\n    rad: function(deg) {\n        return deg * Math.PI / 180;\n    },\n\n    deg: function(rad) {\n        return rad * 180 / Math.PI;\n    },\n\n    cos: function(deg) {\n        return Math.cos(this.rad(deg));\n    },\n\n    acos: function(val, floatPrecision) {\n        return +(this.deg(Math.acos(val)).toFixed(floatPrecision));\n    },\n\n    sin: function(deg) {\n        return Math.sin(this.rad(deg));\n    },\n\n    asin: function(val, floatPrecision) {\n        return +(this.deg(Math.asin(val)).toFixed(floatPrecision));\n    },\n\n    tan: function(deg) {\n        return Math.tan(this.rad(deg));\n    },\n\n    atan: function(val, floatPrecision) {\n        return +(this.deg(Math.atan(val)).toFixed(floatPrecision));\n    }\n\n};\n\n/**\n * Decompose matrix into simple transforms. See\n * http://www.maths-informatique-jeux.com/blog/frederic/?post/2013/12/01/Decomposition-of-2D-transform-matrices\n *\n * @param {Object} data matrix transform object\n * @return {Object|Array} transforms array or original transform object\n */\nexports.matrixToTransform = function(transform, params) {\n    var floatPrecision = params.floatPrecision,\n        data = transform.data,\n        transforms = [],\n        sx = +Math.sqrt(data[0] * data[0] + data[1] * data[1]).toFixed(params.transformPrecision),\n        sy = +((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(params.transformPrecision),\n        colsSum = data[0] * data[2] + data[1] * data[3],\n        rowsSum = data[0] * data[1] + data[2] * data[3],\n        scaleBefore = rowsSum || +(sx == sy);\n\n    // [..., ..., ..., ..., tx, ty] → translate(tx, ty)\n    if (data[4] || data[5]) {\n        transforms.push({ name: 'translate', data: data.slice(4, data[5] ? 6 : 5) });\n    }\n\n    // [sx, 0, tan(a)·sy, sy, 0, 0] → skewX(a)·scale(sx, sy)\n    if (!data[1] && data[2]) {\n        transforms.push({ name: 'skewX', data: [mth.atan(data[2] / sy, floatPrecision)] });\n\n    // [sx, sx·tan(a), 0, sy, 0, 0] → skewY(a)·scale(sx, sy)\n    } else if (data[1] && !data[2]) {\n        transforms.push({ name: 'skewY', data: [mth.atan(data[1] / data[0], floatPrecision)] });\n        sx = data[0];\n        sy = data[3];\n\n    // [sx·cos(a), sx·sin(a), sy·-sin(a), sy·cos(a), x, y] → rotate(a[, cx, cy])·(scale or skewX) or\n    // [sx·cos(a), sy·sin(a), sx·-sin(a), sy·cos(a), x, y] → scale(sx, sy)·rotate(a[, cx, cy]) (if !scaleBefore)\n    } else if (!colsSum || (sx == 1 && sy == 1) || !scaleBefore) {\n        if (!scaleBefore) {\n            sx = Math.sqrt(data[0] * data[0] + data[2] * data[2]);\n            sy = Math.sqrt(data[1] * data[1] + data[3] * data[3]);\n            transforms.push({ name: 'scale', data: [sx, sy] });\n        }\n        var a1 = mth.acos(data[0] / sx, floatPrecision),\n            rotate = [a1.toFixed(floatPrecision) * (data[1] < 0 ? -1 : 1)];\n\n        if (rotate[0]) transforms.push({ name: 'rotate', data: rotate });\n\n        if (rowsSum && colsSum) transforms.push({\n            name: 'skewX',\n            data: [mth.atan(colsSum / (sx * sx), floatPrecision)]\n        });\n\n        // rotate(a, cx, cy) can consume translate() within optional arguments cx, cy (rotation point)\n        if (rotate[0] && (data[4] || data[5])) {\n            transforms.shift();\n            var cos = data[0] / sx,\n                sin = data[1] / (scaleBefore ? sx : sy),\n                x = data[4] * (scaleBefore || sy),\n                y = data[5] * (scaleBefore || sx),\n                denom = (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore || sx * sy);\n            rotate.push(((1 - cos) * x - sin * y) / denom);\n            rotate.push(((1 - cos) * y + sin * x) / denom);\n        }\n\n    // Too many transformations, return original matrix if it isn't just a scale/translate\n    } else if (data[1] || data[2]) {\n        return transform;\n    }\n\n    if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length) transforms.push({\n        name: 'scale',\n        data: sx == sy ? [sx] : [sx, sy]\n    });\n\n    return transforms;\n};\n\n/**\n * Convert transform to the matrix data.\n *\n * @param {Object} transform transform object\n * @return {Array} matrix data\n */\nfunction transformToMatrix(transform) {\n\n    if (transform.name === 'matrix') return transform.data;\n\n    var matrix;\n\n    switch (transform.name) {\n        case 'translate':\n            // [1, 0, 0, 1, tx, ty]\n            matrix = [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];\n            break;\n        case 'scale':\n            // [sx, 0, 0, sy, 0, 0]\n            matrix = [transform.data[0], 0, 0, transform.data[1] || transform.data[0], 0, 0];\n            break;\n        case 'rotate':\n            // [cos(a), sin(a), -sin(a), cos(a), x, y]\n            var cos = mth.cos(transform.data[0]),\n                sin = mth.sin(transform.data[0]),\n                cx = transform.data[1] || 0,\n                cy = transform.data[2] || 0;\n\n            matrix = [cos, sin, -sin, cos, (1 - cos) * cx + sin * cy, (1 - cos) * cy - sin * cx];\n            break;\n        case 'skewX':\n            // [1, 0, tan(a), 1, 0, 0]\n            matrix = [1, 0, mth.tan(transform.data[0]), 1, 0, 0];\n            break;\n        case 'skewY':\n            // [1, tan(a), 0, 1, 0, 0]\n            matrix = [1, mth.tan(transform.data[0]), 0, 1, 0, 0];\n            break;\n    }\n\n    return matrix;\n\n}\n\n/**\n * Applies transformation to an arc. To do so, we represent ellipse as a matrix, multiply it\n * by the transformation matrix and use a singular value decomposition to represent in a form\n * rotate(θ)·scale(a b)·rotate(φ). This gives us new ellipse params a, b and θ.\n * SVD is being done with the formulae provided by Wolffram|Alpha (svd {{m0, m2}, {m1, m3}})\n *\n * @param {Array} arc [a, b, rotation in deg]\n * @param {Array} transform transformation matrix\n * @return {Array} arc transformed input arc\n */\nexports.transformArc = function(arc, transform) {\n\n    var a = arc[0],\n        b = arc[1],\n        rot = arc[2] * Math.PI / 180,\n        cos = Math.cos(rot),\n        sin = Math.sin(rot),\n        h = Math.pow(arc[5] * cos + arc[6] * sin, 2) / (4 * a * a) +\n            Math.pow(arc[6] * cos - arc[5] * sin, 2) / (4 * b * b);\n    if (h > 1) {\n        h = Math.sqrt(h);\n        a *= h;\n        b *= h;\n    }\n    var ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0],\n        m = multiplyTransformMatrices(transform, ellipse),\n        // Decompose the new ellipse matrix\n        lastCol = m[2] * m[2] + m[3] * m[3],\n        squareSum = m[0] * m[0] + m[1] * m[1] + lastCol,\n        root = Math.sqrt(\n            (Math.pow(m[0] - m[3], 2) + Math.pow(m[1] + m[2], 2)) *\n            (Math.pow(m[0] + m[3], 2) + Math.pow(m[1] - m[2], 2))\n        );\n\n    if (!root) { // circle\n        arc[0] = arc[1] = Math.sqrt(squareSum / 2);\n        arc[2] = 0;\n    } else {\n        var majorAxisSqr = (squareSum + root) / 2,\n            minorAxisSqr = (squareSum - root) / 2,\n            major = Math.abs(majorAxisSqr - lastCol) > 1e-6,\n            sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol,\n            rowsSum = m[0] * m[2] + m[1] * m[3],\n            term1 = m[0] * sub + m[2] * rowsSum,\n            term2 = m[1] * sub + m[3] * rowsSum;\n        arc[0] = Math.sqrt(majorAxisSqr);\n        arc[1] = Math.sqrt(minorAxisSqr);\n        arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) *\n            Math.acos((major ? term1 : term2) / Math.sqrt(term1 * term1 + term2 * term2)) * 180 / Math.PI;\n    }\n    return arc;\n\n};\n\n/**\n * Multiply transformation matrices.\n *\n * @param {Array} a matrix A data\n * @param {Array} b matrix B data\n * @return {Array} result\n */\nfunction multiplyTransformMatrices(a, b) {\n\n    return [\n        a[0] * b[0] + a[2] * b[1],\n        a[1] * b[0] + a[3] * b[1],\n        a[0] * b[2] + a[2] * b[3],\n        a[1] * b[2] + a[3] * b[3],\n        a[0] * b[4] + a[2] * b[5] + a[4],\n        a[1] * b[4] + a[3] * b[5] + a[5]\n    ];\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}